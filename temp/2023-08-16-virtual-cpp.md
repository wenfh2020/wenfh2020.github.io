---
layout: post
title:  "[c++] 虚拟继承"
categories: c/c++
author: wenfh2020
---

fdsfds
。
fdsfdsfdsaf

* content
{:toc}




---

## 1. 概述

但是如果我们应用虚拟继承呢？C++ 虚拟继承允许我们指定钻石层次结构，但只能保证虚拟继承基的一个副本。所以让我们这样编写代码：

```cpp
class A {
public:
  int a;
  virtual void v();
};

class B : public virtual A {
public:
  int b;
  virtual void w();
};

class C : public virtual A {
public:
  int c;
  virtual void x();
};

class D : public B, public C {
public:
  int d;
  virtual void y();
};
```

突然之间，事情变得更加复杂。A如果我们在 的表示中只能拥有 的一个副本D，那么我们就无法再摆脱将 a 嵌入C到 a 中的“技巧”（并为in的 vtable部分D嵌入 vtable ）。但如果我们不能这样做，我们如何处理通常的类型替换呢？CDD

让我们尝试绘制布局图：

```shell
                                   +-----------------------+
                                   |   20 (vbase_offset)   |
                                   +-----------------------+
                                   |     0 (top_offset)    |
                                   +-----------------------+
                                   | ptr to typeinfo for D |
                      +----------> +-----------------------+
d --> +----------+    |            |         B::w()        |
      |  vtable  |----+            +-----------------------+
      +----------+                 |         D::y()        |
      |     b    |                 +-----------------------+
      +----------+                 |   12 (vbase_offset)   |
      |  vtable  |---------+       +-----------------------+
      +----------+         |       |    -8 (top_offset)    |
      |     c    |         |       +-----------------------+
      +----------+         |       | ptr to typeinfo for D |
      |     d    |         +-----> +-----------------------+
      +----------+                 |         C::x()        |
      |  vtable  |----+            +-----------------------+
      +----------+    |            |    0 (vbase_offset)   |
      |     a    |    |            +-----------------------+
      +----------+    |            |   -20 (top_offset)    |
                      |            +-----------------------+
                      |            | ptr to typeinfo for D |
                      +----------> +-----------------------+
                                   |         A::v()        |
                                   +-----------------------+
```

好的。所以你看，A现在它的嵌入方式D基本上与其他基地相同。但它嵌入在 D 中，而不是初始化其直接派生类。

---

## 2. 存在多重继承时的构造/销毁

上面的对象在构造对象本身的时候，是如何在内存中构造出来的呢？我们如何确保部分构造的对象（及其 vtable）对于构造函数来说是安全的？

幸运的是，我们都非常小心地处理了这一切。假设我们正在构造一个新类型的对象D（例如，通过 new D）。首先，在堆中分配对象的内存并返回一个指针。D 的构造函数被调用，但在执行任何D特定构造之前，它会调用A对象上的构造函数（this当然是在调整指针之后！）。A 的构造函数填充对象 A 的一部分 D，就好像它是 的实例一样 A。

```shell
d --> +----------+
      |          |
      +----------+
      |          |
      +----------+
      |          |
      +----------+
      |          |       +-----------------------+
      +----------+       |     0 (top_offset)    |
      |          |       +-----------------------+
      +----------+       | ptr to typeinfo for A |
      |  vtable  |-----> +-----------------------+
      +----------+       |         A::v()        |
      |    a     |       +-----------------------+
      +----------+
```

控制权返回到D的构造函数，该B构造函数调用 的构造函数。（这里不需要调整指针。）当B的构造函数完成后，对象看起来像这样：

```shell
                                             B-in-D
                          +-----------------------+
                          |   20 (vbase_offset)   |
                          +-----------------------+
                          |     0 (top_offset)    |
                          +-----------------------+
d --> +----------+        | ptr to typeinfo for B |
      |  vtable  |------> +-----------------------+
      +----------+        |         B::w()        |
      |    b     |        +-----------------------+
      +----------+        |    0 (vbase_offset)   |
      |          |        +-----------------------+
      +----------+        |   -20 (top_offset)    |
      |          |        +-----------------------+
      +----------+        | ptr to typeinfo for B |
      |          |   +--> +-----------------------+
      +----------+   |    |         A::v()        |
      |  vtable  |---+    +-----------------------+
      +----------+
      |    a     |
      +----------+
```

但是等等...B的构造函数A通过更改它的 vtable 指针来修改对象的一部分！它如何知道将这种 B-in-D 与 B-in-其他东西（或独立的B）区分开来？简单的。虚拟表 table告诉它这样做。该结构缩写为VTT，是构造中使用的 vtable 表。在我们的例子中，VTTD如下所示：

```shell
                                                                  B-in-D
                                               +-----------------------+
                                               |   20 (vbase_offset)   |
            VTT for D                          +-----------------------+
+-------------------+                          |     0 (top_offset)    |
|    vtable for D   |-------------+            +-----------------------+
+-------------------+             |            | ptr to typeinfo for B |
| vtable for B-in-D |-------------|----------> +-----------------------+
+-------------------+             |            |         B::w()        |
| vtable for B-in-D |-------------|--------+   +-----------------------+
+-------------------+             |        |   |    0 (vbase_offset)   |
| vtable for C-in-D |-------------|-----+  |   +-----------------------+
+-------------------+             |     |  |   |   -20 (top_offset)    |
| vtable for C-in-D |-------------|--+  |  |   +-----------------------+
+-------------------+             |  |  |  |   | ptr to typeinfo for B |
|    vtable for D   |----------+  |  |  |  +-> +-----------------------+
+-------------------+          |  |  |  |      |         A::v()        |
|    vtable for D   |-------+  |  |  |  |      +-----------------------+
+-------------------+       |  |  |  |  |
                            |  |  |  |  |                         C-in-D
                            |  |  |  |  |      +-----------------------+
                            |  |  |  |  |      |   12 (vbase_offset)   |
                            |  |  |  |  |      +-----------------------+
                            |  |  |  |  |      |     0 (top_offset)    |
                            |  |  |  |  |      +-----------------------+
                            |  |  |  |  |      | ptr to typeinfo for C |
                            |  |  |  |  +----> +-----------------------+
                            |  |  |  |         |         C::x()        |
                            |  |  |  |         +-----------------------+
                            |  |  |  |         |    0 (vbase_offset)   |
                            |  |  |  |         +-----------------------+
                            |  |  |  |         |   -12 (top_offset)    |
                            |  |  |  |         +-----------------------+
                            |  |  |  |         | ptr to typeinfo for C |
                            |  |  |  +-------> +-----------------------+
                            |  |  |            |         A::v()        |
                            |  |  |            +-----------------------+
                            |  |  |
                            |  |  |                                    D
                            |  |  |            +-----------------------+
                            |  |  |            |   20 (vbase_offset)   |
                            |  |  |            +-----------------------+
                            |  |  |            |     0 (top_offset)    |
                            |  |  |            +-----------------------+
                            |  |  |            | ptr to typeinfo for D |
                            |  |  +----------> +-----------------------+
                            |  |               |         B::w()        |
                            |  |               +-----------------------+
                            |  |               |         D::y()        |
                            |  |               +-----------------------+
                            |  |               |   12 (vbase_offset)   |
                            |  |               +-----------------------+
                            |  |               |    -8 (top_offset)    |
                            |  |               +-----------------------+
                            |  |               | ptr to typeinfo for D |
                            +----------------> +-----------------------+
                               |               |         C::x()        |
                               |               +-----------------------+
                               |               |    0 (vbase_offset)   |
                               |               +-----------------------+
                               |               |   -20 (top_offset)    |
                               |               +-----------------------+
                               |               | ptr to typeinfo for D |
                               +-------------> +-----------------------+
                                               |         A::v()        |
                                               +-----------------------+
```

D 的构造函数将 D 的 VTT 中的指针传递给 B 的构造函数（在本例中，它传递第一个 B-in-D 条目的地址）。事实上，上面用于对象布局的 vtable 是一个特殊的 vtable，仅用于构建 B-in-D。

控制权返回给 D 构造函数，它调用 C 构造函数（带有指向“C-in-D+12”条目的 VTT 地址参数）。当 C 的构造函数处理完对象后，它看起来像这样：

```shell
                                                                           B-in-D
                                                        +-----------------------+
                                                        |   20 (vbase_offset)   |
                                                        +-----------------------+
                                                        |     0 (top_offset)    |
                                                        +-----------------------+
                                                        | ptr to typeinfo for B |
                    +---------------------------------> +-----------------------+
                    |                                   |         B::w()        |
                    |                                   +-----------------------+
                    |                          C-in-D   |    0 (vbase_offset)   |
                    |       +-----------------------+   +-----------------------+
d --> +----------+  |       |   12 (vbase_offset)   |   |   -20 (top_offset)    |
      |  vtable  |--+       +-----------------------+   +-----------------------+
      +----------+          |     0 (top_offset)    |   | ptr to typeinfo for B |
      |    b     |          +-----------------------+   +-----------------------+
      +----------+          | ptr to typeinfo for C |   |         A::v()        |
      |  vtable  |--------> +-----------------------+   +-----------------------+
      +----------+          |         C::x()        |
      |    c     |          +-----------------------+
      +----------+          |    0 (vbase_offset)   |
      |          |          +-----------------------+
      +----------+          |   -12 (top_offset)    |
      |  vtable  |--+       +-----------------------+
      +----------+  |       | ptr to typeinfo for C |
      |    a     |  +-----> +-----------------------+
      +----------+          |         A::v()        |
                            +-----------------------+
```

如您所见，C 的构造函数再次修改了嵌入的 A 的 vtable 指针。嵌入的 C 和 A 对象现在使用特殊构造 C-in-D vtable，嵌入 B 对象使用特殊构造 B-in-D vtable。最后，D 的构造函数完成了工作，我们最终得到了与之前相同的图表：

```shell
                                   +-----------------------+
                                   |   20 (vbase_offset)   |
                                   +-----------------------+
                                   |     0 (top_offset)    |
                                   +-----------------------+
                                   | ptr to typeinfo for D |
                      +----------> +-----------------------+
d --> +----------+    |            |         B::w()        |
      |  vtable  |----+            +-----------------------+
      +----------+                 |         D::y()        |
      |     b    |                 +-----------------------+
      +----------+                 |   12 (vbase_offset)   |
      |  vtable  |---------+       +-----------------------+
      +----------+         |       |    -8 (top_offset)    |
      |     c    |         |       +-----------------------+
      +----------+         |       | ptr to typeinfo for D |
      |     d    |         +-----> +-----------------------+
      +----------+                 |         C::x()        |
      |  vtable  |----+            +-----------------------+
      +----------+    |            |    0 (vbase_offset)   |
      |     a    |    |            +-----------------------+
      +----------+    |            |   -20 (top_offset)    |
                      |            +-----------------------+
                      |            | ptr to typeinfo for D |
                      +----------> +-----------------------+
                                   |         A::v()        |
                                   +-----------------------+
```

破坏以相同的方式发生，但方向相反。D 的析构函数被调用。用户的销毁代码运行后，析构函数调用C的析构函数并指示它使用D的VTT的相关部分。C 的析构函数以与构造期间相同的方式操作 vtable 指针；也就是说，相关的 vtable 指针现在指向 C-in-D 构造 vtable。然后，它运行 C 的用户销毁代码，并将控制权返回给 D 的析构函数，接下来 D 的析构函数通过对 D 的 VTT 的引用来调用 B 的析构函数。B 的析构函数设置对象的相关部分以引用 B-in-D 构造 vtable。它运行 B 的用户销毁代码并将控制权返回给 D 的析构函数，D 的析构函数最终调用 A 的析构函数。A 的析构函数更改对象 A 部分的 vtable，以引用 A 的 vtable。最后，控制权返回到 D 的析构函数，对象的销毁完成。对象曾经使用过的内存将返回给系统。

事实上，现在的故事有些复杂了。您是否曾在 GCC 生成的警告和错误消息或 GCC 生成的二进制文件中看到过那些“负责”和“不负责”构造函数和析构函数规范？事实上，可以有两个构造函数实现和最多三个析构函数实现。

“负责”（或完整对象）构造函数是构造虚拟基的构造函数，“非负责”（或基对象）构造函数是不构造虚拟基的构造函数。考虑我们上面的例子。如果构造了一个B，它的构造函数需要调用A的构造函数来构造它。类似地，C 的构造函数需要构造 A。但是，如果 B 和 C 是作为 D 构造的一部分构造的，则它们的构造函数不应构造 A，因为 A 是虚拟基，而 D 的构造函数将只负责构造它一次以 D 为例。考虑以下情况：

如果您执行 new A，则将调用 A 的“负责”构造函数来构造 A。当您执行 new B 时，将调用 B 的“负责”构造函数。它将调用 A 的“非负责”构造函数。

新C与新B类似。

新的 D 调用 D 的“负责”构造函数。我们浏览了这个例子。D 的“负责”构造函数调用 A、B 和 C 的构造函数的“非负责”版本（按该顺序）。

“负责”析构函数与“负责”构造函数类似——它负责销毁虚拟基。类似地，生成“不负责”析构函数。但还有第三种。“负责删除”析构函数是一种解除分配存储并销毁对象的析构函数。那么什么时候一个优先于另一个被调用呢？

好吧，有两种类型的对象可以被破坏——分配在堆栈上的对象和分配在堆上的对象。考虑这段代码（考虑到我们的钻石层次结构和之前的虚拟继承）：

```cpp
D d;            // allocates a D on the stack and constructs it
D *pd = new D;  // allocates a D in the heap and constructs it
/* ... */
delete pd;      // calls "in-charge deleting" destructor for D
return;         // calls "in-charge" destructor for stack-allocated D
```

我们看到实际的删除运算符不是由执行删除的代码调用的，而是由正在删除的对象的负责删除析构函数调用的。为什么要这样做呢？为什么不让调用者调用负责的析构函数，然后删除该对象？那么你就只有两个析构函数实现的副本，而不是三个......

好吧，编译器可以做这样的事情，但由于其他原因它会更加复杂。考虑这段代码（假设有一个虚拟析构函数，您总是使用它，对吧？...对吗？！？）：

```cpp
D *pd = new D;  // allocates a D in the heap and constructs it
    C *pc = d;      // we have a pointer-to-C that points to our heap-allocated D
    /* ... */
    delete pc;      // call destructor thunk through vtable, but what about delete?
```

如果您没有 D 析构函数的“负责删除”类型，则删除操作将需要像析构函数 thunk 一样调整指针。请记住，C 对象嵌入在 D 中，因此我们上面的 C 指针被调整为指向 D 对象的中间。我们不能直接删除这个指针，因为它不是原来的指针。malloc()当我们构建它时返回。

因此，如果我们没有负责删除的析构函数，我们就必须对删除运算符进行 thunk（并在我们的 vtable 中表示它们），或者其他类似的东西。

---

## 3. 一侧具有虚拟方法的多重继承

好的。最后一项练习。如果我们像以前一样有一个带有虚拟继承的菱形继承层次结构，但只有一侧有虚拟方法怎么办？所以：

```cpp
class A {
public:
  int a;
};

class B : public virtual A {
public:
  int b;
  virtual void w();
};

class C : public virtual A {
public:
  int c;
};

class D : public B, public C {
public:
  int d;
  virtual void y();
};
```

在这种情况下，对象布局如下：

```shell
                                   +-----------------------+
                                   |   20 (vbase_offset)   |
                                   +-----------------------+
                                   |     0 (top_offset)    |
                                   +-----------------------+
                                   | ptr to typeinfo for D |
                      +----------> +-----------------------+
d --> +----------+    |            |         B::w()        |
      |  vtable  |----+            +-----------------------+
      +----------+                 |         D::y()        |
      |     b    |                 +-----------------------+
      +----------+                 |   12 (vbase_offset)   |
      |  vtable  |---------+       +-----------------------+
      +----------+         |       |    -8 (top_offset)    |
      |     c    |         |       +-----------------------+
      +----------+         |       | ptr to typeinfo for D |
      |     d    |         +-----> +-----------------------+
      +----------+
      |     a    |
      +----------+
```

所以你可以看到没有虚拟方法的C子对象仍然有一个vtable（尽管是空的）。事实上，C 的所有实例都有一个空的 vtable。