---
layout: post
title:  "通过 dynamic_cast 去理解多态"
categories: c/c++
author: wenfh2020
---

本文将通过 dynamic_cast 运行时进行类型转换的运算符探索多态的实现机制。



* content
{:toc}



---

## 1. 概念

在C++11中，`dynamic_cast` 是一个用于在运行时进行类型转换的运算符。它可以用于将一个指向基类的指针或引用转换为指向派生类的指针或引用。它的语法如下：

```cpp
dynamic_cast<new_type>(expression)
```

其中，`new_type` 是要转换的目标类型，`expression` 是要转换的表达式。dynamic_cast 会在运行时检查类型信息，如果转换是合法的，则返回指向目标类型的指针或引用，否则返回 `nullptr`。

需要注意的是，dynamic_cast 只能用于具有多态性的类层次结构中，即其中至少有一个虚函数。否则，编译器会报错。此外，dynamic_cast 的性能相对较低，因为它需要在运行时进行类型检查。因此，在使用 dynamic_cast 时要谨慎考虑性能问题。

> 文字来源：ChatGPT 3.5，详细定义请参考：[dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)

---

## 2. 系统版本

```shell
# cat /etc/redhat-release
CentOS Linux release 7.9.2009 (Core)
# cat /proc/version
Linux version 3.10.0-1127.19.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) 
(gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) )
```

---

## 3. 测试实例

通过调试去观测 dynamic_cast 函数的内部源码相关数据信息。

* 源码。

```cpp
/* g++ -O0 -std=c++11 test.cpp -o test && ./test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() { std::cout << "Base::vBaseFunc2" << std::endl; }
    virtual void vBaseFunc2() { std::cout << "Base::vBaseFunc2" << std::endl; }
};

class Drived : public Base {
   public:
    virtual void vBaseFunc2() { std::cout << "Drived::vBaseFunc2" << std::endl; }
    virtual void vDrivedFunc() { std::cout << "Drived::vDrivedFunc" << std::endl; }
};

int main() {
    Base *b = new Drived;
    auto d = dynamic_cast<Drived *>(b);
    if (d) {
        d->vBaseFunc2();
    }
    return 0;
}
```

* 反汇编查看该函数的调用，以及变量参数数据。

<div align=center><img src="/images/2023/2023-08-09-13-51-26.png" data-action="zoom"></div>

```shell
# objdump -dS test > asm.log
  ; src2dst
  40098f:    b9 00 00 00 00           mov    $0x0,%ecx
  ; dst_type
  400994:    ba 70 0c 40 00           mov    $0x400c70,%edx
  ; src_ptr
  400999:    be 90 0c 40 00           mov    $0x400c90,%esi
  ; src_ptr
  40099e:    48 89 c7                 mov    %rax,%rdi
  ; 调用 dynamic_cast 函数
  4009a1:    e8 8a fe ff ff           callq  400830 <__dynamic_cast@plt>
```

* 通过调试，我们可以比较直观看到该函数的参数变量相关信息。

<div align=center><img src="/images/2023/2023-08-09-13-49-18.png" data-action="zoom"></div>

> 调试方式请参考：[《(ubuntu) vscode + gdb 调试 c++》](https://www.wenfh2020.com/2022/02/19/vscode-gdb-cpp/)

---

## 4. 多态重要数据结构

经过调试，我们已经对 dynamic_cast 的实现有了一些了解，上图的 __dynamic_cast 源码出现了两个十分重要的数据结构：`__class_type_info`，`type_info`。

---

### 4.1. type_info

`__class_type_info`：类的类型信息，它是 `type_info` 的一个派生类。

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/typeinfo */
// The type_info class describes type information generated by an implementation.
class type_info {
 protected:
    const char* __name;
};

/* /usr/include/c++/4.8.2/cxxabi.h */
// Type information for a class.
class __class_type_info : public std::type_info {
 public:
    ...
};
```

---

### 4.2. 虚表描述结构

`vtable_prefix`：虚表描述结构。一个对象可能有多个虚指针，对个虚表描述结构；`每个虚指针指向对应的 vtable_prefix.origin`。

1. whole_object：我认为定义为：top_offset，更贴切一点。对象内存中的离顶端偏移位置，因为对象有可能有多个虚表，通过偏移量可以找到对象内存布局上对应的虚指针。
2. whole_type: 类的类型信息。
3. origin：虚指针指向虚表的位置。

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/tinfo.h */
// Initial part of a vtable, this structure is used with offsetof, so we don't
// have to keep alignments consistent manually.
struct vtable_prefix {
    // Offset to most derived object.
    ptrdiff_t whole_object;

    // Pointer to most derived type_info.
    const __class_type_info *whole_type;
    
    // What a class's vptr points to.
    const void *origin;
};
```

---

## 5. 关键源码

```cpp
/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)

template <typename T>
inline const T *adjust_pointer(const void *base, ptrdiff_t offset) {
    return reinterpret_cast<const T *>(reinterpret_cast<const char *>(base) +
                                       offset);
}
```

---

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/dyncast.cc */

// this is the external interface to the dynamic cast machinery
/* sub: source address to be adjusted; nonnull, and since the
 *      source object is polymorphic, *(void**)sub is a virtual pointer.
 * src: static type of the source object.
 * dst: destination type (the "T" in "dynamic_cast<T>(v)").
 * src2dst_offset: a static hint about the location of the
 *    source subobject with respect to the complete object;
 *    special negative values are:
 *       -1: no hint
 *       -2: src is not a public base of dst
 *       -3: src is a multiple public base type but never a virtual base type
 *    otherwise, the src type is a unique public nonvirtual
 *    base type of dst at offset src2dst_offset from the origin of dst.  */
extern "C" void *__dynamic_cast(
    const void *src_ptr,                // object started from
    const __class_type_info *src_type,  // type of the starting object
    const __class_type_info *dst_type,  // desired target type
    ptrdiff_t src2dst)                  // how src and dst are related
{
    const void *vtable = *static_cast<const void *const *>(src_ptr);
    const vtable_prefix *prefix =
        adjust_pointer<vtable_prefix>(vtable, -offsetof(vtable_prefix, origin));
    const void *whole_ptr = adjust_pointer<void>(src_ptr, prefix->whole_object);
    const __class_type_info *whole_type = prefix->whole_type;
    __class_type_info::__dyncast_result result;

    // If the whole object vptr doesn't refer to the whole object type, we're
    // in the middle of constructing a primary base, and src is a separate
    // base.  This has undefined behavior and we can't find anything outside
    // of the base we're actually constructing, so fail now rather than
    // segfault later trying to use a vbase offset that doesn't exist.
    const void *whole_vtable = *static_cast<const void *const *>(whole_ptr);
    const vtable_prefix *whole_prefix = adjust_pointer<vtable_prefix>(
        whole_vtable, -offsetof(vtable_prefix, origin));
    if (whole_prefix->whole_type != whole_type) {
        return NULL;
    }

    whole_type->__do_dyncast(src2dst, __class_type_info::__contained_public,
                             dst_type, whole_ptr, src_type, src_ptr, result);
    if (!result.dst_ptr) {
        return NULL;
    }
    if (contained_public_p(result.dst2src)) {
        // Src is known to be a public base of dst.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_public_p(__class_type_info::__sub_kind(result.whole2src &
                                                         result.whole2dst))) {
        // Both src and dst are known to be public bases of whole. Found a valid
        // cross cast.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_nonvirtual_p(result.whole2src)) {
        // Src is known to be a non-public nonvirtual base of whole, and not a
        // base of dst. Found an invalid cross cast, which cannot also be a down
        // cast
        return NULL;
    }
    if (result.dst2src == __class_type_info::__unknown) {
        result.dst2src = dst_type->__find_public_src(src2dst, result.dst_ptr,
                                                     src_type, src_ptr);
    }
    if (contained_public_p(result.dst2src)) {
        // Found a valid down cast
        return const_cast<void *>(result.dst_ptr);
    }
    // Must be an invalid down cast, or the cross cast wasn't bettered
    return NULL;
}
```

---

* deep。

```cpp
/* g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test */

// find / -name 'tinfo.h'
#include </usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/tinfo.h>
#include <cxxabi.h>
#include <stddef.h>

#include <iostream>
#include <typeinfo>

class Base {
   public:
    virtual void vBaseFunc() {}
    virtual void vBaseFunc2() {}

    double m_base_data;
    double m_base_data2;
};

class Base2 {
   public:
    virtual void vBase2Func() {}
    virtual void vBase2Func2() {}

    double m_base2_data;
    double m_base2_data2;
};

class Base3 {
   public:
    virtual void vBase3Func() {}
    virtual void vBase3Func2() {}

    double m_base3_data;
    double m_base3_data2;
};

class Drived : public Base, public Base2, public Base3 {
   public:
    virtual void vBaseFunc() {}
    virtual void vBase2Func2() {}
    virtual void vBase3Func2() {}
    virtual void vDrivedFunc() {}
    virtual void vDrivedFunc2() {}

    double m_drived_data;
    double m_drived_data2;
};

using namespace __cxxabiv1;

void debugVtableInfo(const void *src_ptr) {
    const void *vtable = *static_cast<const void *const *>(src_ptr);
    const vtable_prefix *prefix =
        adjust_pointer<vtable_prefix>(vtable,
                                      -offsetof(vtable_prefix, origin));
    const void *whole_ptr =
        adjust_pointer<void>(src_ptr, prefix->whole_object);
    const __class_type_info *whole_type = prefix->whole_type;

    const void *whole_vtable = *static_cast<const void *const *>(whole_ptr);
    const vtable_prefix *whole_prefix =
        adjust_pointer<vtable_prefix>(whole_vtable,
                                      -offsetof(vtable_prefix, origin));
    std::cout << "debug: " << src_ptr << std::endl;
}

struct AA {
    virtual void vfn() {}
    int a = 0;
    int b = 0;
    int c = 0;
};

int main() {
    std::cout << sizeof(AA) << std::endl;
    Base *b = new Drived;
    delete b;
    // debugVtableInfo(b);

    // Base2 *b2 = new Drived;
    // debugVtableInfo(b2);

    // auto d = dynamic_cast<Drived *>(b2);
    // auto d2 = dynamic_cast<Drived *>(b2);

    // debugVtableInfo(d);
    // Base2 *b2 = new Drived;
    // debugVtableInfo(b2);
    return 0;
}
```

---

## 6. dynamic_cast

`dynamic_cast` 是 C++ 中的一个类型转换运算符，用于在运行时进行类型转换。它可以将一个指向基类的指针或引用转换为指向派生类的指针或引用。dynamic_cast 会检查转换是否安全，如果转换不安全，则返回一个空指针或引发一个std::bad_cast异常。它主要用于在多态的情况下进行安全的向下转型。它的语法如下：

```cpp
dynamic_cast<new_type>(expression)
```

其中，`new_type` 是要转换的目标类型，`expression` 是要转换的表达式。dynamic_cast 会在运行时检查类型信息，如果转换是合法的，则返回指向目标类型的指针或引用，否则返回 `nullptr`。

需要注意的是，dynamic_cast 只能用于具有多态性的类层次结构中，即其中至少有一个虚函数。否则，编译器会报错。此外，dynamic_cast 的性能相对较低，因为它需要在运行时进行类型检查。因此，在使用 dynamic_cast 时要谨慎考虑性能问题。

> 部分文字来源：ChatGPT 3.5，详细定义请参考：[dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)

---

### 6.1. 测试实例

通过调试去观测 dynamic_cast 函数的内部源码相关数据信息。

* 源码。

```cpp
/* g++ -O0 -std=c++11 test.cpp -o test && ./test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() { std::cout << "Base::vBaseFunc2" << std::endl; }
    virtual void vBaseFunc2() { std::cout << "Base::vBaseFunc2" << std::endl; }
};

class Drived : public Base {
   public:
    virtual void vBaseFunc2() { std::cout << "Drived::vBaseFunc2" << std::endl; }
    virtual void vDrivedFunc() { std::cout << "Drived::vDrivedFunc" << std::endl; }
};

int main() {
    Base *b = new Drived;
    auto d = dynamic_cast<Drived *>(b);
    if (d) {
        d->vBaseFunc2();
    }
    return 0;
}
```

* 反汇编查看该函数的调用，以及变量参数数据。

<div align=center><img src="/images/2023/2023-08-09-13-51-26.png" data-action="zoom"></div>

```shell
# objdump -dS test > asm.log
  ; src2dst
  40098f:    b9 00 00 00 00           mov    $0x0,%ecx
  ; dst_type
  400994:    ba 70 0c 40 00           mov    $0x400c70,%edx
  ; src_ptr
  400999:    be 90 0c 40 00           mov    $0x400c90,%esi
  ; src_ptr
  40099e:    48 89 c7                 mov    %rax,%rdi
  ; 调用 dynamic_cast 函数
  4009a1:    e8 8a fe ff ff           callq  400830 <__dynamic_cast@plt>
```

* 通过调试，我们可以比较直观看到该函数的参数变量相关信息。

<div align=center><img src="/images/2023/2023-08-09-13-49-18.png" data-action="zoom"></div>

> 调试方式请参考：[《(ubuntu) vscode + gdb 调试 c++》](https://www.wenfh2020.com/2022/02/19/vscode-gdb-cpp/)

---

### 6.2. 源码剖析

`待续...`

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/dyncast.cc */

// this is the external interface to the dynamic cast machinery
/* sub: source address to be adjusted; nonnull, and since the
 *      source object is polymorphic, *(void**)sub is a virtual pointer.
 * src: static type of the source object.
 * dst: destination type (the "T" in "dynamic_cast<T>(v)").
 * src2dst_offset: a static hint about the location of the
 *    source subobject with respect to the complete object;
 *    special negative values are:
 *       -1: no hint
 *       -2: src is not a public base of dst
 *       -3: src is a multiple public base type but never a virtual base type
 *    otherwise, the src type is a unique public nonvirtual
 *    base type of dst at offset src2dst_offset from the origin of dst.  */
extern "C" void *__dynamic_cast(
    const void *src_ptr,                // object started from
    const __class_type_info *src_type,  // type of the starting object
    const __class_type_info *dst_type,  // desired target type
    ptrdiff_t src2dst)                  // how src and dst are related
{
    const void *vtable = *static_cast<const void *const *>(src_ptr);
    const vtable_prefix *prefix =
        adjust_pointer<vtable_prefix>(vtable, -offsetof(vtable_prefix, origin));
    const void *whole_ptr = adjust_pointer<void>(src_ptr, prefix->whole_object);
    const __class_type_info *whole_type = prefix->whole_type;
    __class_type_info::__dyncast_result result;

    // If the whole object vptr doesn't refer to the whole object type, we're
    // in the middle of constructing a primary base, and src is a separate
    // base.  This has undefined behavior and we can't find anything outside
    // of the base we're actually constructing, so fail now rather than
    // segfault later trying to use a vbase offset that doesn't exist.
    const void *whole_vtable = *static_cast<const void *const *>(whole_ptr);
    const vtable_prefix *whole_prefix = adjust_pointer<vtable_prefix>(
        whole_vtable, -offsetof(vtable_prefix, origin));
    if (whole_prefix->whole_type != whole_type) {
        return NULL;
    }

    whole_type->__do_dyncast(src2dst, __class_type_info::__contained_public,
                             dst_type, whole_ptr, src_type, src_ptr, result);
    if (!result.dst_ptr) {
        return NULL;
    }
    if (contained_public_p(result.dst2src)) {
        // Src is known to be a public base of dst.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_public_p(__class_type_info::__sub_kind(result.whole2src &
                                                         result.whole2dst))) {
        // Both src and dst are known to be public bases of whole. Found a valid
        // cross cast.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_nonvirtual_p(result.whole2src)) {
        // Src is known to be a non-public nonvirtual base of whole, and not a
        // base of dst. Found an invalid cross cast, which cannot also be a down
        // cast
        return NULL;
    }
    if (result.dst2src == __class_type_info::__unknown) {
        result.dst2src = dst_type->__find_public_src(src2dst, result.dst_ptr,
                                                     src_type, src_ptr);
    }
    if (contained_public_p(result.dst2src)) {
        // Found a valid down cast
        return const_cast<void *>(result.dst_ptr);
    }
    // Must be an invalid down cast, or the cross cast wasn't bettered
    return NULL;
}
```

---

```shell
vtable for B3:
        .quad   40
        .quad   0
        .quad   typeinfo for B3
        .quad   24
        .quad   -16
        .quad   typeinfo for B3
        .quad   B2::vB0Func()
        .quad   -24
        .quad   -40
        .quad   typeinfo for B3
        .quad   virtual thunk to B2::vB0Func()


00000000004008fd <main>:
  4008fd:    55                       push   %rbp
  4008fe:    48 89 e5                 mov    %rsp,%rbp
  400901:    53                       push   %rbx
  400902:    48 83 ec 18              sub    $0x18,%rsp
  400906:    bf 38 00 00 00           mov    $0x38,%edi
  40090b:    e8 f0 fe ff ff           callq  400800 <operator new(unsigned long)@plt>
  400910:    48 89 c3                 mov    %rax,%rbx
  400913:    48 89 df                 mov    %rbx,%rdi
  400916:    e8 dd 01 00 00           callq  400af8 <B3::B3()>
  40091b:    48 89 5d e8              mov    %rbx,-0x18(%rbp)
  40091f:    48 83 7d e8 00           cmpq   $0x0,-0x18(%rbp)


  400924:    74 1a                    je     400940 <main+0x43>
  400926:    48 8b 45 e8              mov    -0x18(%rbp),%rax
  40092a:    48 8b 00                 mov    (%rax),%rax
  40092d:    48 83 e8 18              sub    $0x18,%rax
  400931:    48 8b 00                 mov    (%rax),%rax
  400934:    48 89 c2                 mov    %rax,%rdx
  400937:    48 8b 45 e8              mov    -0x18(%rbp),%rax
  40093b:    48 01 d0                 add    %rdx,%rax
  40093e:    eb 05                    jmp    400945 <main+0x48>
  400940:    b8 00 00 00 00           mov    $0x0,%eax
  400945:    48 89 45 e0              mov    %rax,-0x20(%rbp)
  400949:    48 83 7d e0 00           cmpq   $0x0,-0x20(%rbp)
  40094e:    74 15                    je     400965 <main+0x68>
  400950:    48 8b 45 e0              mov    -0x20(%rbp),%rax
  400954:    48 8b 00                 mov    (%rax),%rax
  400957:    48 8b 00                 mov    (%rax),%rax
  40095a:    48 8b 55 e0              mov    -0x20(%rbp),%rdx
  40095e:    48 89 d7                 mov    %rdx,%rdi
  400961:    ff d0                    callq  *%rax
  400963:    eb 1c                    jmp    400981 <main+0x84>
  400965:    be 29 0c 40 00           mov    $0x400c29,%esi
  40096a:    bf e0 20 60 00           mov    $0x6020e0,%edi
  40096f:    e8 5c fe ff ff           callq  4007d0 <std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)@plt>
  400974:    be f0 07 40 00           mov    $0x4007f0,%esi
  400979:    48 89 c7                 mov    %rax,%rdi
  40097c:    e8 5f fe ff ff           callq  4007e0 <std::ostream::operator<<(std::ostream& (*)(std::ostream&))@plt>
  400981:    b8 00 00 00 00           mov    $0x0,%eax
  400986:    48 83 c4 18              add    $0x18,%rsp
  40098a:    5b                       pop    %rbx
  40098b:    5d                       pop    %rbp
  40098c:    c3                       retq
```

---

## 7. 引用

* [dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)
* [c++对象内存布局](https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247484652&idx=1&sn=087f34d20572614a3273c4f1028a4be2&chksm=c337622bf440eb3d0875a5e115c3545c169cbbd5fd5cae834f9387479c202d5eff1c350b3f2f&mpshare=1&scene=24&srcid=0214RAacGDpYpm1JFHL7I8iV&sharer_sharetime=1676387723635&sharer_shareid=0b4fc3750818fb2c58eb60e71e3d1c6f#rd)
* [C++ 对象的内存布局（上）](https://haoel.blog.csdn.net/article/details/3081328)
* [C++ 对象的内存布局（下）](https://blog.csdn.net/haoel/article/details/3081385)
* [如何在vscode中编写汇编语言并在终端进行调试(保姆级别）](https://blog.csdn.net/m0_46973282/article/details/109250859)
* [C++：从技术实现角度聊聊RTTI](https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247489382&idx=1&sn=203de64c6ff362eaea628523f1584330&chksm=c33771a1f440f8b77715d96dcbefd4b8e3a081ce94fa81907245d895ca29b54845b27db8aff9&mpshare=1&scene=24&srcid=0214fcH29d6PwaYZNonOZwAg&sharer_sharetime=1676387791668&sharer_shareid=0b4fc3750818fb2c58eb60e71e3d1c6f#rd)
* [C++ Virtual Table Tables(VTT)](https://nimrod.blog/posts/cpp-virtual-table-tables/)
* [虚继承的Vtable](https://qinglinmao8315.github.io/c++/2018/02/28/c++-vtable-in-virtual-inheritance.html)
* [godbolt.org](https://godbolt.org/)
* [深入理解C++对像模型--vtable 布局](https://zhuanlan.zhihu.com/p/496115833)
* [What is the VTT for a class?](https://blog.csdn.net/qq_30366449/article/details/85106115)