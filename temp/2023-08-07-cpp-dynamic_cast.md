---
layout: post
title:  "通过 dynamic_cast 去理解多态"
categories: c/c++
author: wenfh2020
---

本文将通过 dynamic_cast 运行时进行类型转换的运算符探索多态的实现机制。



* content
{:toc}



---

## 1. 概念

在C++11中，`dynamic_cast` 是一个用于在运行时进行类型转换的运算符。它可以用于将一个指向基类的指针或引用转换为指向派生类的指针或引用。它的语法如下：

```cpp
dynamic_cast<new_type>(expression)
```

其中，`new_type` 是要转换的目标类型，`expression` 是要转换的表达式。dynamic_cast 会在运行时检查类型信息，如果转换是合法的，则返回指向目标类型的指针或引用，否则返回 `nullptr`。

需要注意的是，dynamic_cast 只能用于具有多态性的类层次结构中，即其中至少有一个虚函数。否则，编译器会报错。此外，dynamic_cast 的性能相对较低，因为它需要在运行时进行类型检查。因此，在使用 dynamic_cast 时要谨慎考虑性能问题。

> 文字来源：ChatGPT 3.5，详细定义请参考：[dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)

---

## 2. 系统版本

```shell
# cat /etc/redhat-release
CentOS Linux release 7.9.2009 (Core)
# cat /proc/version
Linux version 3.10.0-1127.19.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) 
(gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) )
```

---

## 3. 测试实例

通过调试去观测 dynamic_cast 函数的内部源码相关数据信息。

* 源码。

```cpp
/* g++ -O0 -std=c++11 test.cpp -o test && ./test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() { std::cout << "Base::vBaseFunc2" << std::endl; }
    virtual void vBaseFunc2() { std::cout << "Base::vBaseFunc2" << std::endl; }
};

class Drived : public Base {
   public:
    virtual void vBaseFunc2() { std::cout << "Drived::vBaseFunc2" << std::endl; }
    virtual void vDrivedFunc() { std::cout << "Drived::vDrivedFunc" << std::endl; }
};

int main() {
    Base *b = new Drived;
    auto d = dynamic_cast<Drived *>(b);
    if (d) {
        d->vBaseFunc2();
    }
    return 0;
}
```

* 反汇编查看该函数的调用，以及变量参数数据。

<div align=center><img src="/images/2023/2023-08-09-13-51-26.png" data-action="zoom"></div>

```shell
# objdump -dS test > asm.log
  ; src2dst
  40098f:    b9 00 00 00 00           mov    $0x0,%ecx
  ; dst_type
  400994:    ba 70 0c 40 00           mov    $0x400c70,%edx
  ; src_ptr
  400999:    be 90 0c 40 00           mov    $0x400c90,%esi
  ; src_ptr
  40099e:    48 89 c7                 mov    %rax,%rdi
  ; 调用 dynamic_cast 函数
  4009a1:    e8 8a fe ff ff           callq  400830 <__dynamic_cast@plt>
```

* 通过调试，我们可以比较直观看到该函数的参数变量相关信息。

<div align=center><img src="/images/2023/2023-08-09-13-49-18.png" data-action="zoom"></div>

> 调试方式请参考：[《(ubuntu) vscode + gdb 调试 c++》](https://www.wenfh2020.com/2022/02/19/vscode-gdb-cpp/)

---

## 4. 多态重要数据结构

经过调试，我们已经对 dynamic_cast 的实现有了一些了解，上图的 __dynamic_cast 源码出现了两个十分重要的数据结构：`__class_type_info`，`type_info`。

---

### 4.1. type_info

`__class_type_info`：类的类型信息，它是 `type_info` 的一个派生类。

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/typeinfo */
// The type_info class describes type information generated by an implementation.
class type_info {
 protected:
    const char* __name;
};

/* /usr/include/c++/4.8.2/cxxabi.h */
// Type information for a class.
class __class_type_info : public std::type_info {
 public:
    ...
};
```

---

### 4.2. 虚表描述结构

`vtable_prefix`：虚表描述结构。一个对象可能有多个虚指针，对个虚表描述结构；`每个虚指针指向对应的 vtable_prefix.origin`。

1. whole_object：我认为定义为：top_offset，更贴切一点。对象内存中的离顶端偏移位置，因为对象有可能有多个虚表，通过偏移量可以找到对象内存布局上对应的虚指针。
2. whole_type: 类的类型信息。
3. origin：虚指针指向虚表的位置。

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/tinfo.h */
// Initial part of a vtable, this structure is used with offsetof, so we don't
// have to keep alignments consistent manually.
struct vtable_prefix {
    // Offset to most derived object.
    ptrdiff_t whole_object;

    // Pointer to most derived type_info.
    const __class_type_info *whole_type;
    
    // What a class's vptr points to.
    const void *origin;
};
```

---

## 5. 继承关系

封装，继承，多态是 C++ 的三大特性，其中多态与继承有密切关系。C++ 语言支持三种继承关系：单一继承，多重继承，虚拟继承：

<div align=center><img src="/images/2023/2023-02-25-11-37-39.png" data-action="zoom" width="80%"/></div>

> 图片来源：《多型与虚拟》

<div align=center><img src="/images/2023/2023-08-11-10-36-46.png" data-action="zoom"></div>

---

### 5.1. 单一继承

* 测试代码。

```cpp
/* g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() {}
    virtual void vBaseFunc2() {}
    virtual void vBaseFunc3() {}

    double m_base_data;
    double m_base_data2;
};

class Base2 : public Base {
   public:
    virtual void vBaseFunc() {}
    virtual void vBase2Func() {}
    virtual void vBase2Func2() {}

    double m_base2_data;
    double m_base2_data2;
};

class Drived : public Base2 {
   public:
    virtual void vBaseFunc2() {}
    virtual void vBase2Func() {}
    virtual void vDrivedFunc() {}
    virtual void vDrivedFunc2() {}

    double m_drived_data;
    double m_drived_data2;
};

int main() {
    return 0;
}
```

* 类布局层次。我们可以通过通过 gcc 的 `fdump-class-hierarchy` 编译项查看测试代码的类层次关系。`-fdump-class-hierarchy` 是一个编译器选项，用于在编译过程中生成类层次结构的信息。它会将类的继承关系以文本形式输出到一个文件中，以便开发人员可以查看和分析类之间的关系。——这个选项在调试和理解代码中的类继承关系时非常有用。

> 部分文字来源于：ChatGPT

```shell
# g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test
# test.cpp.002t.class

Vtable for Base
Base::_ZTV4Base: 5u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI4Base)
16    (int (*)(...))Base::vBaseFunc
24    (int (*)(...))Base::vBaseFunc2
32    (int (*)(...))Base::vBaseFunc3

Class Base
   size=24 align=8
   base size=24 base align=8
Base (0x0x7fe6a109f180) 0
    vptr=((& Base::_ZTV4Base) + 16u)

Vtable for Base2
Base2::_ZTV5Base2: 7u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI5Base2)
16    (int (*)(...))Base2::vBaseFunc
24    (int (*)(...))Base::vBaseFunc2
32    (int (*)(...))Base::vBaseFunc3
40    (int (*)(...))Base2::vBase2Func
48    (int (*)(...))Base2::vBase2Func2

Class Base2
   size=40 align=8
   base size=40 base align=8
Base2 (0x0x7fe6a1056f70) 0
    vptr=((& Base2::_ZTV5Base2) + 16u)
  Base (0x0x7fe6a109f1e0) 0
      primary-for Base2 (0x0x7fe6a1056f70)

# 虚表的结构。
Vtable for Drived
Drived::_ZTV6Drived: 9u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI6Drived)
16    (int (*)(...))Base2::vBaseFunc
24    (int (*)(...))Drived::vBaseFunc2
32    (int (*)(...))Base::vBaseFunc3
40    (int (*)(...))Drived::vBase2Func
48    (int (*)(...))Base2::vBase2Func2
56    (int (*)(...))Drived::vDrivedFunc
64    (int (*)(...))Drived::vDrivedFunc2

# 类的层次结构。
Class Drived
   size=56 align=8
   base size=56 base align=8
Drived (0x0x7fe6a1056478) 0
    vptr=((& Drived::_ZTV6Drived) + 16u)
  Base2 (0x0x7fe6a1056a28) 0
      primary-for Drived (0x0x7fe6a1056478)
    Base (0x0x7fe6a109f240) 0
        primary-for Base2 (0x0x7fe6a1056a28)
```

结合上面单一继承的测试代码和类的布局层次，我们可以了解到它的整体的相关对象布局：

  1. 派生类重写的虚函数是如何重写覆盖基类的虚函数的。
  2. 虚表的数据结构的大致框架。
  3. 对象的各个关键点是如何联系起来的。
  
  > 部分细节没有写测试，有兴趣的朋友可以自己动手试试。

* 虚表整合。

<div align=center><img src="/images/2023/2023-08-12-07-31-29.png" data-action="zoom"></div>

* 对象整体对局。

<div align=center><img src="/images/2023/2023-08-12-07-48-10.png" data-action="zoom"></div>

---

### 5.2. 多重继承

* 测试代码。

```cpp
/* g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() {}
    virtual void vBaseFunc2() {}

    double m_base_data;
    double m_base_data2;
};

class Base2 {
   public:
    virtual void vBase2Func() {}
    virtual void vBase2Func2() {}

    double m_base2_data;
    double m_base2_data2;
};

class Base3 {
   public:
    virtual void vBase3Func() {}
    virtual void vBase3Func2() {}

    double m_base3_data;
    double m_base3_data2;
};

class Drived : public Base, public Base2, public Base3 {
   public:
    virtual void vBaseFunc() {}
    virtual void vBase2Func2() {}
    virtual void vBase3Func2() {}
    virtual void vDrivedFunc() {}
    virtual void vDrivedFunc2() {}

    double m_drived_data;
    double m_drived_data2;
};

int main() {
    return 0;
}
```

* 类内存布局层次。

```shell
# g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test
# test.cpp.002t.class

Vtable for Base
Base::_ZTV4Base: 4u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI4Base)
16    (int (*)(...))Base::vBaseFunc
24    (int (*)(...))Base::vBaseFunc2

Class Base
   size=24 align=8
   base size=24 base align=8
Base (0x0x7f8e4bd3da80) 0
    vptr=((& Base::_ZTV4Base) + 16u)

Vtable for Base2
Base2::_ZTV5Base2: 4u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI5Base2)
16    (int (*)(...))Base2::vBase2Func
24    (int (*)(...))Base2::vBase2Func2

Class Base2
   size=24 align=8
   base size=24 base align=8
Base2 (0x0x7f8e4bd3dae0) 0
    vptr=((& Base2::_ZTV5Base2) + 16u)

Vtable for Base3
Base3::_ZTV5Base3: 4u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI5Base3)
16    (int (*)(...))Base3::vBase3Func
24    (int (*)(...))Base3::vBase3Func2

Class Base3
   size=24 align=8
   base size=24 base align=8
Base3 (0x0x7f8e4bd3db40) 0
    vptr=((& Base3::_ZTV5Base3) + 16u)

Vtable for Drived
Drived::_ZTV6Drived: 16u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI6Drived)
16    (int (*)(...))Drived::vBaseFunc
24    (int (*)(...))Base::vBaseFunc2
32    (int (*)(...))Drived::vBase2Func2
40    (int (*)(...))Drived::vBase3Func2
48    (int (*)(...))Drived::vDrivedFunc
56    (int (*)(...))Drived::vDrivedFunc2
64    (int (*)(...))-24
72    (int (*)(...))(& _ZTI6Drived)
80    (int (*)(...))Base2::vBase2Func
88    (int (*)(...))Drived::_ZThn24_N6Drived11vBase2Func2Ev
96    (int (*)(...))-48
104   (int (*)(...))(& _ZTI6Drived)
112   (int (*)(...))Base3::vBase3Func
120   (int (*)(...))Drived::_ZThn48_N6Drived11vBase3Func2Ev

Class Drived
   size=88 align=8
   base size=88 base align=8
Drived (0x0x7f8e4babcd98) 0
    vptr=((& Drived::_ZTV6Drived) + 16u)
  Base (0x0x7f8e4bd3dba0) 0
      primary-for Drived (0x0x7f8e4babcd98)
  Base2 (0x0x7f8e4bd3dc00) 24
      vptr=((& Drived::_ZTV6Drived) + 80u)
  Base3 (0x0x7f8e4bd3dc60) 48
      vptr=((& Drived::_ZTV6Drived) + 112u)
```

* 虚表整合。
  
  1. 首先派生类的虚表与第一个基类的虚表结合成一个虚表单元，并覆盖基类的虚函数。
  2. 其它的基类，作为一个独立虚表单元。当派生类虚函数有重写基类的虚函数时，基类对应虚函数，通过 [thunk 技术](https://zhuanlan.zhihu.com/p/496115833) ，跳转到第一个虚表单元的对应虚函数。

<div align=center><img src="/images/2023/2023-08-12-07-36-31.png" data-action="zoom"></div>

* 对象整体布局。由下图可见：

  1. 多重继承有多个虚指针，并指向对应的虚表。
  2. N 个多重继承基类，有 N 多虚指针和虚表。

<div align=center><img src="/images/2023/2023-08-12-08-10-42.png" data-action="zoom"></div>

---

### 5.3. 虚拟继承

虚拟继承的类层次关系结构有点复杂，有兴趣的朋友可以看看：[What is the VTT for a class?](https://blog.csdn.net/qq_30366449/article/details/85106115)。

* 测试源码。

```cpp
/* g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() {}
    virtual void vBaseFunc2() {}

    double m_base_data;
    double m_base_data2;
};

class Base2 : virtual public Base {
   public:
    virtual void vBase2Func() {}
    virtual void vBase2Func2() {}

    double m_base2_data;
    double m_base2_data2;
};

class Base3 : virtual public Base {
   public:
    virtual void vBase3Func() {}
    virtual void vBase3Func2() {}

    double m_base3_data;
    double m_base3_data2;
};

class Drived : public Base2, public Base3 {
   public:
    virtual void vBaseFunc() {}
    virtual void vBase2Func2() {}
    virtual void vBase3Func2() {}
    virtual void vDrivedFunc() {}
    virtual void vDrivedFunc2() {}

    double m_drived_data;
    double m_drived_data2;
};

int main() {
    return 0;
}
```

* 类层次关系。

```shell
Vtable for Base
Base::_ZTV4Base: 4u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI4Base)
16    (int (*)(...))Base::vBaseFunc
24    (int (*)(...))Base::vBaseFunc2

Class Base
   size=24 align=8
   base size=24 base align=8
Base (0x0x7fcf32273a80) 0
    vptr=((& Base::_ZTV4Base) + 16u)

Vtable for Base2
Base2::_ZTV5Base2: 11u entries
0     24u
8     (int (*)(...))0
16    (int (*)(...))(& _ZTI5Base2)
24    (int (*)(...))Base2::vBase2Func
32    (int (*)(...))Base2::vBase2Func2
40    0u
48    0u
56    (int (*)(...))-24
64    (int (*)(...))(& _ZTI5Base2)
72    (int (*)(...))Base::vBaseFunc
80    (int (*)(...))Base::vBaseFunc2

VTT for Base2
Base2::_ZTT5Base2: 2u entries
0     ((& Base2::_ZTV5Base2) + 24u)
8     ((& Base2::_ZTV5Base2) + 72u)

Class Base2
   size=48 align=8
   base size=24 base align=8
Base2 (0x0x7fcf3205f750) 0
    vptridx=0u vptr=((& Base2::_ZTV5Base2) + 24u)
  Base (0x0x7fcf32273ae0) 24 virtual
      vptridx=8u vbaseoffset=-24 vptr=((& Base2::_ZTV5Base2) + 72u)

Vtable for Base3
Base3::_ZTV5Base3: 11u entries
0     24u
8     (int (*)(...))0
16    (int (*)(...))(& _ZTI5Base3)
24    (int (*)(...))Base3::vBase3Func
32    (int (*)(...))Base3::vBase3Func2
40    0u
48    0u
56    (int (*)(...))-24
64    (int (*)(...))(& _ZTI5Base3)
72    (int (*)(...))Base::vBaseFunc
80    (int (*)(...))Base::vBaseFunc2

VTT for Base3
Base3::_ZTT5Base3: 2u entries
0     ((& Base3::_ZTV5Base3) + 24u)
8     ((& Base3::_ZTV5Base3) + 72u)

Class Base3
   size=48 align=8
   base size=24 base align=8
Base3 (0x0x7fcf3205f820) 0
    vptridx=0u vptr=((& Base3::_ZTV5Base3) + 24u)
  Base (0x0x7fcf32273b40) 24 virtual
      vptridx=8u vbaseoffset=-24 vptr=((& Base3::_ZTV5Base3) + 72u)

Vtable for Drived
Drived::_ZTV6Drived: 20u entries
0     64u
8     (int (*)(...))0
16    (int (*)(...))(& _ZTI6Drived)
24    (int (*)(...))Base2::vBase2Func
32    (int (*)(...))Drived::vBase2Func2
40    (int (*)(...))Drived::vBaseFunc
48    (int (*)(...))Drived::vBase3Func2
56    (int (*)(...))Drived::vDrivedFunc
64    (int (*)(...))Drived::vDrivedFunc2
72    40u
80    (int (*)(...))-24
88    (int (*)(...))(& _ZTI6Drived)
96    (int (*)(...))Base3::vBase3Func
104   (int (*)(...))Drived::_ZThn24_N6Drived11vBase3Func2Ev
112   0u
120   18446744073709551552u
128   (int (*)(...))-64
136   (int (*)(...))(& _ZTI6Drived)
144   (int (*)(...))Drived::_ZTv0_n24_N6Drived9vBaseFuncEv
152   (int (*)(...))Base::vBaseFunc2

Construction vtable for Base2 (0x0x7fc7076748f0 instance) in Drived
Drived::_ZTC6Drived0_5Base2: 11u entries
0     64u
8     (int (*)(...))0
16    (int (*)(...))(& _ZTI5Base2)
24    (int (*)(...))Base2::vBase2Func
32    (int (*)(...))Base2::vBase2Func2
40    0u
48    0u
56    (int (*)(...))-64
64    (int (*)(...))(& _ZTI5Base2)
72    (int (*)(...))Base::vBaseFunc
80    (int (*)(...))Base::vBaseFunc2

Construction vtable for Base3 (0x0x7fc707674958 instance) in Drived
Drived::_ZTC6Drived24_5Base3: 11u entries
0     40u
8     (int (*)(...))0
16    (int (*)(...))(& _ZTI5Base3)
24    (int (*)(...))Base3::vBase3Func
32    (int (*)(...))Base3::vBase3Func2
40    0u
48    0u
56    (int (*)(...))-40
64    (int (*)(...))(& _ZTI5Base3)
72    (int (*)(...))Base::vBaseFunc
80    (int (*)(...))Base::vBaseFunc2

VTT for Drived
Drived::_ZTT6Drived: 7u entries
0     ((& Drived::_ZTV6Drived) + 24u)
8     ((& Drived::_ZTC6Drived0_5Base2) + 24u)
16    ((& Drived::_ZTC6Drived0_5Base2) + 72u)
24    ((& Drived::_ZTC6Drived24_5Base3) + 24u)
32    ((& Drived::_ZTC6Drived24_5Base3) + 72u)
40    ((& Drived::_ZTV6Drived) + 144u)
48    ((& Drived::_ZTV6Drived) + 96u)

Class Drived
   size=88 align=8
   base size=64 base align=8
Drived (0x0x7fc7076a2460) 0
    vptridx=0u vptr=((& Drived::_ZTV6Drived) + 24u)
  Base2 (0x0x7fc7076748f0) 0
      primary-for Drived (0x0x7fc7076a2460)
      subvttidx=8u
    Base (0x0x7fc707888ba0) 64 virtual
        vptridx=40u vbaseoffset=-24 vptr=((& Drived::_ZTV6Drived) + 144u)
  Base3 (0x0x7fc707674958) 24
      subvttidx=24u vptridx=48u vptr=((& Drived::_ZTV6Drived) + 96u)
    Base (0x0x7fc707888ba0) alternative-path
```

---

## 6. 关键源码

```cpp
/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)

template <typename T>
inline const T *adjust_pointer(const void *base, ptrdiff_t offset) {
    return reinterpret_cast<const T *>(reinterpret_cast<const char *>(base) +
                                       offset);
}
```

---

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/dyncast.cc */

// this is the external interface to the dynamic cast machinery
/* sub: source address to be adjusted; nonnull, and since the
 *      source object is polymorphic, *(void**)sub is a virtual pointer.
 * src: static type of the source object.
 * dst: destination type (the "T" in "dynamic_cast<T>(v)").
 * src2dst_offset: a static hint about the location of the
 *    source subobject with respect to the complete object;
 *    special negative values are:
 *       -1: no hint
 *       -2: src is not a public base of dst
 *       -3: src is a multiple public base type but never a virtual base type
 *    otherwise, the src type is a unique public nonvirtual
 *    base type of dst at offset src2dst_offset from the origin of dst.  */
extern "C" void *__dynamic_cast(
    const void *src_ptr,                // object started from
    const __class_type_info *src_type,  // type of the starting object
    const __class_type_info *dst_type,  // desired target type
    ptrdiff_t src2dst)                  // how src and dst are related
{
    const void *vtable = *static_cast<const void *const *>(src_ptr);
    const vtable_prefix *prefix =
        adjust_pointer<vtable_prefix>(vtable, -offsetof(vtable_prefix, origin));
    const void *whole_ptr = adjust_pointer<void>(src_ptr, prefix->whole_object);
    const __class_type_info *whole_type = prefix->whole_type;
    __class_type_info::__dyncast_result result;

    // If the whole object vptr doesn't refer to the whole object type, we're
    // in the middle of constructing a primary base, and src is a separate
    // base.  This has undefined behavior and we can't find anything outside
    // of the base we're actually constructing, so fail now rather than
    // segfault later trying to use a vbase offset that doesn't exist.
    const void *whole_vtable = *static_cast<const void *const *>(whole_ptr);
    const vtable_prefix *whole_prefix = adjust_pointer<vtable_prefix>(
        whole_vtable, -offsetof(vtable_prefix, origin));
    if (whole_prefix->whole_type != whole_type) {
        return NULL;
    }

    whole_type->__do_dyncast(src2dst, __class_type_info::__contained_public,
                             dst_type, whole_ptr, src_type, src_ptr, result);
    if (!result.dst_ptr) {
        return NULL;
    }
    if (contained_public_p(result.dst2src)) {
        // Src is known to be a public base of dst.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_public_p(__class_type_info::__sub_kind(result.whole2src &
                                                         result.whole2dst))) {
        // Both src and dst are known to be public bases of whole. Found a valid
        // cross cast.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_nonvirtual_p(result.whole2src)) {
        // Src is known to be a non-public nonvirtual base of whole, and not a
        // base of dst. Found an invalid cross cast, which cannot also be a down
        // cast
        return NULL;
    }
    if (result.dst2src == __class_type_info::__unknown) {
        result.dst2src = dst_type->__find_public_src(src2dst, result.dst_ptr,
                                                     src_type, src_ptr);
    }
    if (contained_public_p(result.dst2src)) {
        // Found a valid down cast
        return const_cast<void *>(result.dst_ptr);
    }
    // Must be an invalid down cast, or the cross cast wasn't bettered
    return NULL;
}
```

---

* deep。

```cpp
/* g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test */

// find / -name 'tinfo.h'
#include </usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/tinfo.h>
#include <cxxabi.h>
#include <stddef.h>

#include <iostream>
#include <typeinfo>

class Base {
   public:
    virtual void vBaseFunc() {}
    virtual void vBaseFunc2() {}

    double m_base_data;
    double m_base_data2;
};

class Base2 {
   public:
    virtual void vBase2Func() {}
    virtual void vBase2Func2() {}

    double m_base2_data;
    double m_base2_data2;
};

class Base3 {
   public:
    virtual void vBase3Func() {}
    virtual void vBase3Func2() {}

    double m_base3_data;
    double m_base3_data2;
};

class Drived : public Base, public Base2, public Base3 {
   public:
    virtual void vBaseFunc() {}
    virtual void vBase2Func2() {}
    virtual void vBase3Func2() {}
    virtual void vDrivedFunc() {}
    virtual void vDrivedFunc2() {}

    double m_drived_data;
    double m_drived_data2;
};

using namespace __cxxabiv1;

void debugVtableInfo(const void *src_ptr) {
    const void *vtable = *static_cast<const void *const *>(src_ptr);
    const vtable_prefix *prefix =
        adjust_pointer<vtable_prefix>(vtable,
                                      -offsetof(vtable_prefix, origin));
    const void *whole_ptr =
        adjust_pointer<void>(src_ptr, prefix->whole_object);
    const __class_type_info *whole_type = prefix->whole_type;

    const void *whole_vtable = *static_cast<const void *const *>(whole_ptr);
    const vtable_prefix *whole_prefix =
        adjust_pointer<vtable_prefix>(whole_vtable,
                                      -offsetof(vtable_prefix, origin));
    std::cout << "debug: " << src_ptr << std::endl;
}

struct AA {
    virtual void vfn() {}
    int a = 0;
    int b = 0;
    int c = 0;
};

int main() {
    std::cout << sizeof(AA) << std::endl;
    Base *b = new Drived;
    delete b;
    // debugVtableInfo(b);

    // Base2 *b2 = new Drived;
    // debugVtableInfo(b2);

    // auto d = dynamic_cast<Drived *>(b2);
    // auto d2 = dynamic_cast<Drived *>(b2);

    // debugVtableInfo(d);
    // Base2 *b2 = new Drived;
    // debugVtableInfo(b2);
    return 0;
}
```

---

## 7. dynamic_cast

`dynamic_cast` 是 C++ 中的一个类型转换运算符，用于在运行时进行类型转换。它可以将一个指向基类的指针或引用转换为指向派生类的指针或引用。dynamic_cast 会检查转换是否安全，如果转换不安全，则返回一个空指针或引发一个std::bad_cast异常。它主要用于在多态的情况下进行安全的向下转型。它的语法如下：

```cpp
dynamic_cast<new_type>(expression)
```

其中，`new_type` 是要转换的目标类型，`expression` 是要转换的表达式。dynamic_cast 会在运行时检查类型信息，如果转换是合法的，则返回指向目标类型的指针或引用，否则返回 `nullptr`。

需要注意的是，dynamic_cast 只能用于具有多态性的类层次结构中，即其中至少有一个虚函数。否则，编译器会报错。此外，dynamic_cast 的性能相对较低，因为它需要在运行时进行类型检查。因此，在使用 dynamic_cast 时要谨慎考虑性能问题。

> 部分文字来源：ChatGPT 3.5，详细定义请参考：[dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)

---

### 7.1. 测试实例

通过调试去观测 dynamic_cast 函数的内部源码相关数据信息。

* 源码。

```cpp
/* g++ -O0 -std=c++11 test.cpp -o test && ./test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() { std::cout << "Base::vBaseFunc2" << std::endl; }
    virtual void vBaseFunc2() { std::cout << "Base::vBaseFunc2" << std::endl; }
};

class Drived : public Base {
   public:
    virtual void vBaseFunc2() { std::cout << "Drived::vBaseFunc2" << std::endl; }
    virtual void vDrivedFunc() { std::cout << "Drived::vDrivedFunc" << std::endl; }
};

int main() {
    Base *b = new Drived;
    auto d = dynamic_cast<Drived *>(b);
    if (d) {
        d->vBaseFunc2();
    }
    return 0;
}
```

* 反汇编查看该函数的调用，以及变量参数数据。

<div align=center><img src="/images/2023/2023-08-09-13-51-26.png" data-action="zoom"></div>

```shell
# objdump -dS test > asm.log
  ; src2dst
  40098f:    b9 00 00 00 00           mov    $0x0,%ecx
  ; dst_type
  400994:    ba 70 0c 40 00           mov    $0x400c70,%edx
  ; src_ptr
  400999:    be 90 0c 40 00           mov    $0x400c90,%esi
  ; src_ptr
  40099e:    48 89 c7                 mov    %rax,%rdi
  ; 调用 dynamic_cast 函数
  4009a1:    e8 8a fe ff ff           callq  400830 <__dynamic_cast@plt>
```

* 通过调试，我们可以比较直观看到该函数的参数变量相关信息。

<div align=center><img src="/images/2023/2023-08-09-13-49-18.png" data-action="zoom"></div>

> 调试方式请参考：[《(ubuntu) vscode + gdb 调试 c++》](https://www.wenfh2020.com/2022/02/19/vscode-gdb-cpp/)

---

### 7.2. 源码剖析

`待续...`

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/dyncast.cc */

// this is the external interface to the dynamic cast machinery
/* sub: source address to be adjusted; nonnull, and since the
 *      source object is polymorphic, *(void**)sub is a virtual pointer.
 * src: static type of the source object.
 * dst: destination type (the "T" in "dynamic_cast<T>(v)").
 * src2dst_offset: a static hint about the location of the
 *    source subobject with respect to the complete object;
 *    special negative values are:
 *       -1: no hint
 *       -2: src is not a public base of dst
 *       -3: src is a multiple public base type but never a virtual base type
 *    otherwise, the src type is a unique public nonvirtual
 *    base type of dst at offset src2dst_offset from the origin of dst.  */
extern "C" void *__dynamic_cast(
    const void *src_ptr,                // object started from
    const __class_type_info *src_type,  // type of the starting object
    const __class_type_info *dst_type,  // desired target type
    ptrdiff_t src2dst)                  // how src and dst are related
{
    const void *vtable = *static_cast<const void *const *>(src_ptr);
    const vtable_prefix *prefix =
        adjust_pointer<vtable_prefix>(vtable, -offsetof(vtable_prefix, origin));
    const void *whole_ptr = adjust_pointer<void>(src_ptr, prefix->whole_object);
    const __class_type_info *whole_type = prefix->whole_type;
    __class_type_info::__dyncast_result result;

    // If the whole object vptr doesn't refer to the whole object type, we're
    // in the middle of constructing a primary base, and src is a separate
    // base.  This has undefined behavior and we can't find anything outside
    // of the base we're actually constructing, so fail now rather than
    // segfault later trying to use a vbase offset that doesn't exist.
    const void *whole_vtable = *static_cast<const void *const *>(whole_ptr);
    const vtable_prefix *whole_prefix = adjust_pointer<vtable_prefix>(
        whole_vtable, -offsetof(vtable_prefix, origin));
    if (whole_prefix->whole_type != whole_type) {
        return NULL;
    }

    whole_type->__do_dyncast(src2dst, __class_type_info::__contained_public,
                             dst_type, whole_ptr, src_type, src_ptr, result);
    if (!result.dst_ptr) {
        return NULL;
    }
    if (contained_public_p(result.dst2src)) {
        // Src is known to be a public base of dst.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_public_p(__class_type_info::__sub_kind(result.whole2src &
                                                         result.whole2dst))) {
        // Both src and dst are known to be public bases of whole. Found a valid
        // cross cast.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_nonvirtual_p(result.whole2src)) {
        // Src is known to be a non-public nonvirtual base of whole, and not a
        // base of dst. Found an invalid cross cast, which cannot also be a down
        // cast
        return NULL;
    }
    if (result.dst2src == __class_type_info::__unknown) {
        result.dst2src = dst_type->__find_public_src(src2dst, result.dst_ptr,
                                                     src_type, src_ptr);
    }
    if (contained_public_p(result.dst2src)) {
        // Found a valid down cast
        return const_cast<void *>(result.dst_ptr);
    }
    // Must be an invalid down cast, or the cross cast wasn't bettered
    return NULL;
}
```

---

## 8. 引用

* [dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)
* [c++对象内存布局](https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247484652&idx=1&sn=087f34d20572614a3273c4f1028a4be2&chksm=c337622bf440eb3d0875a5e115c3545c169cbbd5fd5cae834f9387479c202d5eff1c350b3f2f&mpshare=1&scene=24&srcid=0214RAacGDpYpm1JFHL7I8iV&sharer_sharetime=1676387723635&sharer_shareid=0b4fc3750818fb2c58eb60e71e3d1c6f#rd)
* [C++ 对象的内存布局（上）](https://haoel.blog.csdn.net/article/details/3081328)
* [C++ 对象的内存布局（下）](https://blog.csdn.net/haoel/article/details/3081385)
* [如何在vscode中编写汇编语言并在终端进行调试(保姆级别）](https://blog.csdn.net/m0_46973282/article/details/109250859)
* [C++：从技术实现角度聊聊RTTI](https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247489382&idx=1&sn=203de64c6ff362eaea628523f1584330&chksm=c33771a1f440f8b77715d96dcbefd4b8e3a081ce94fa81907245d895ca29b54845b27db8aff9&mpshare=1&scene=24&srcid=0214fcH29d6PwaYZNonOZwAg&sharer_sharetime=1676387791668&sharer_shareid=0b4fc3750818fb2c58eb60e71e3d1c6f#rd)
* [C++ Virtual Table Tables(VTT)](https://nimrod.blog/posts/cpp-virtual-table-tables/)
* [虚继承的Vtable](https://qinglinmao8315.github.io/c++/2018/02/28/c++-vtable-in-virtual-inheritance.html)
* [godbolt.org](https://godbolt.org/)
* [深入理解C++对像模型--vtable 布局](https://zhuanlan.zhihu.com/p/496115833)
* [What is the VTT for a class?](https://blog.csdn.net/qq_30366449/article/details/85106115)