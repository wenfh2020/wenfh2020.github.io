<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> </title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 18 Feb 2020 09:54:14 +0800</pubDate>
    <lastBuildDate>Tue, 18 Feb 2020 09:54:14 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>进程内存分布</title>
        <description>程序进程是不能直接访问物理内存的，系统通过虚拟内存方式管理进程内存。

&lt;img src=&quot;https://raw.githubusercontent.com/wenfh2020/imgs_for_blog/master/md20200217155719.png&quot; alt=&quot;进程地址空间&quot; /&gt;

&lt;blockquote&gt;
  图片来源 《深入理解计算机系统》8.2.3 私有地址空间
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 17 Feb 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/02/17/mem-distribution/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/02/17/mem-distribution/</guid>
        
        <category>系统</category>
        
        <category>Linux</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>github + jekyll 建自己的博客</title>
        <description>自从用 &lt;code class=&quot;highlighter-rouge&quot;&gt;markdown&lt;/code&gt; 写文档之后，感觉就离不开它了。工作这么久，最后悔的事情是没有条理化地将知识实时落地，然后后面做了大量重复无用的工作。很幸运 &lt;code class=&quot;highlighter-rouge&quot;&gt;github&lt;/code&gt; 提供了一个很好的源码管理和博客平台。我&lt;a href=&quot;https://wenfh2020.github.io/&quot;&gt;自己的博客&lt;/a&gt;框架来自&lt;a href=&quot;https://github.com/Gaohaoyang/gaohaoyang.github.io&quot;&gt;Gaohaoyang&lt;/a&gt;
</description>
        <pubDate>Mon, 17 Feb 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/02/17/make-blog/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/02/17/make-blog/</guid>
        
        <category>随笔</category>
        
        
        <category>随笔</category>
        
      </item>
    
      <item>
        <title>比较宏和宏函数的工作效率</title>
        <description>通过 gdb 查看程序的汇编代码，比较宏和宏函数的工作效率。

&lt;img src=&quot;https://raw.githubusercontent.com/wenfh2020/imgs_for_blog/master/mdgdb-c-asm1.jpg&quot; alt=&quot;源码反汇编&quot; /&gt;
</description>
        <pubDate>Sat, 15 Feb 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/02/15/c-asm/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/02/15/c-asm/</guid>
        
        <category>c</category>
        
        
        <category>c/c++</category>
        
      </item>
    
      <item>
        <title>nginx 地址对齐(ngx_align_ptr)</title>
        <description>内存池，要在大块连续内存上，分配小块内存，指向小内存块的地址是否对齐，对系统性能有一定影响：因为 cpu 从主存上读取数据很慢的，合理的地址对齐可以减少访问次数，提高访问效率。
</description>
        <pubDate>Sat, 08 Feb 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/02/08/ngx_align_ptr/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/02/08/ngx_align_ptr/</guid>
        
        <category>nginx</category>
        
        <category>c</category>
        
        
        <category>nginx</category>
        
      </item>
    
      <item>
        <title>[redis 源码走读] 对象(redisObject)</title>
        <description>redis 对数据的处理用对象进行管理，目前有5种类型。每种对象类型并不是用单一的编码类型实现，根据应用场景，往往多种编码类型结合使用。
</description>
        <pubDate>Wed, 05 Feb 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/02/05/redis-obj/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/02/05/redis-obj/</guid>
        
        <category>redis</category>
        
        <category>c</category>
        
        
        <category>redis</category>
        
      </item>
    
      <item>
        <title>[redis 源码走读] 整数集合(inset)</title>
        <description>整数集合，是一个有序的数值数组对象，存储的数值不允许重复。源码在 &lt;code class=&quot;highlighter-rouge&quot;&gt;intset.c&lt;/code&gt;
</description>
        <pubDate>Tue, 04 Feb 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/02/04/redis-inset/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/02/04/redis-inset/</guid>
        
        <category>redis</category>
        
        <category>c</category>
        
        
        <category>redis</category>
        
      </item>
    
      <item>
        <title>[redis 源码走读] 跳跃表(skiplist)</title>
        <description>&lt;a href=&quot;http://zhangtielei.com/posts/blog-redis-skiplist.html&quot;&gt;张铁蕾&lt;/a&gt;的博客将 &lt;code class=&quot;highlighter-rouge&quot;&gt;skiplist&lt;/code&gt; 原理和算法复杂度描述得很清楚，具体可以参考。我分享一下自己对部分源码的阅读情况和思考。
</description>
        <pubDate>Mon, 03 Feb 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/02/03/redis-skiplist/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/02/03/redis-skiplist/</guid>
        
        <category>redis</category>
        
        <category>c</category>
        
        
        <category>redis</category>
        
      </item>
    
      <item>
        <title>[redis 源码走读] 压缩列表(ziplist)</title>
        <description>点赞作者：redis 源码，注释很多而且很详细。看压缩列表源码前，可以先看看 ziplist.c 文件顶部注释，基本可以了解该数据结构设计。

&lt;img src=&quot;https://raw.githubusercontent.com/wenfh2020/imgs_for_blog/master/md20200215163218.png&quot; alt=&quot;结构&quot; /&gt;
</description>
        <pubDate>Thu, 30 Jan 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/01/30/redis-ziplist/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/01/30/redis-ziplist/</guid>
        
        <category>redis</category>
        
        <category>c</category>
        
        
        <category>redis</category>
        
      </item>
    
      <item>
        <title>[redis 源码走读] 链表</title>
        <description>redis 的链表实现不是很复杂，从 &lt;code class=&quot;highlighter-rouge&quot;&gt;listNode&lt;/code&gt; 可以知道，&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; 是一个双向链表，支持从链表首尾两边开始遍历结点。同时提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;listIter&lt;/code&gt; 迭代器，方便前后方向迭代遍历。其它应该就是链表增删改查的一些常规操作了。
</description>
        <pubDate>Tue, 21 Jan 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/01/21/redis-list/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/01/21/redis-list/</guid>
        
        <category>redis</category>
        
        <category>list</category>
        
        
        <category>redis</category>
        
      </item>
    
      <item>
        <title>[nginx 源码走读] 内存池</title>
        <description>nginx 内存池(&lt;a href=&quot;https://github.com/nginx/nginx/blob/master/src/core/ngx_palloc.c&quot;&gt;源码&lt;/a&gt;)通过大小内存块的链式管理逻辑大致如下图(部分&lt;strong&gt;内存对齐&lt;/strong&gt;的细节没有添加进去)：

&lt;img src=&quot;https://raw.githubusercontent.com/wenfh2020/imgs_for_blog/master/md20200215163135.png&quot; alt=&quot;内存池&quot; /&gt;
</description>
        <pubDate>Tue, 21 Jan 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/01/21/nginx-pool/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/01/21/nginx-pool/</guid>
        
        <category>nginx</category>
        
        <category>c</category>
        
        
        <category>nginx</category>
        
      </item>
    
  </channel>
</rss>
