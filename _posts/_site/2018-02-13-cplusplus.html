<p>c++ 基础知识回顾。</p>

<ul id="markdown-toc">
  <li><a href="#1-基础知识" id="markdown-toc-1-基础知识">1. 基础知识</a>    <ul>
      <li><a href="#11-const-常量" id="markdown-toc-11-const-常量">1.1. const 常量</a></li>
      <li><a href="#12-inline" id="markdown-toc-12-inline">1.2. inline</a></li>
      <li><a href="#13-c-三大特性" id="markdown-toc-13-c-三大特性">1.3. C++ 三大特性</a>        <ul>
          <li><a href="#131-封装" id="markdown-toc-131-封装">1.3.1. 封装</a></li>
          <li><a href="#132-继承" id="markdown-toc-132-继承">1.3.2. 继承</a></li>
          <li><a href="#133-多态" id="markdown-toc-133-多态">1.3.3. 多态</a></li>
        </ul>
      </li>
      <li><a href="#14-数组长度指针长度" id="markdown-toc-14-数组长度指针长度">1.4. 数组长度，指针长度</a></li>
    </ul>
  </li>
  <li><a href="#2-其它" id="markdown-toc-2-其它">2. 其它</a>    <ul>
      <li><a href="#21-malloc-和-new-区别" id="markdown-toc-21-malloc-和-new-区别">2.1. malloc 和 new 区别</a></li>
      <li><a href="#22-空类" id="markdown-toc-22-空类">2.2. 空类</a></li>
    </ul>
  </li>
  <li><a href="#3-参考" id="markdown-toc-3-参考">3. 参考</a></li>
</ul>

<h2 id="1-基础知识">1. 基础知识</h2>

<h3 id="11-const-常量">1.1. const 常量</h3>

<p>const 可以修饰常量，引用，函数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 常量指针，指针指向的是常量，(*p)内容不能变。</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"123"</span><span class="p">;</span>

<span class="c1">// 指针常量，(p)指针不能变。</span>
<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"123"</span><span class="p">;</span>

<span class="c1">// 不允许修改类数据成员的值。</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">get_count</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// 不允许修改返回指针的内容。</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">get_data</span><span class="p">();</span>
</code></pre></div></div>

<hr />
<h3 id="12-inline">1.2. inline</h3>
<p>inline 是 C++ 关键字，在函数声明或定义中。在函数返回类型前加上关键字 inline，即可把函数指定为内联函数，这样可以解决一些频繁调用的函数，大量消耗栈空间。</p>
<blockquote>
  <p>可以对比宏函数</p>
</blockquote>

<ol>
  <li>优点：
作为函数定义的关键字，说明该函数是内联函数。内联函数会将代码块嵌入到每个调用该函数的地方，内联函数减少了函数的调用，使代码执行的效率提高。</li>
  <li>缺点：
内联是以代码膨胀复制为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码, 将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联:
1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。（递归）</li>
</ol>

<hr />
<h3 id="13-c-三大特性">1.3. C++ 三大特性</h3>
<p>封装，继承，多态</p>

<hr />
<h4 id="131-封装">1.3.1. 封装</h4>
<p>将处理的数据抽象成类，操作执行抽象成方法。例如 file.</p>

<hr />
<h4 id="132-继承">1.3.2. 继承</h4>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"base construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"base destruct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"base func2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Child</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Child</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child destruct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child func2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Child2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Child</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Child2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child2 construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Child2</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child2 destruct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child2 func2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Child2</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">func2</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里考察的是析构函数，多态功能。在析构函数中调用虚函数</p>

<p>结果</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base construct
child construct
Child2 construct
Child2 func2
Child2 destruct
child destruct
base destruct
</code></pre></div></div>

<hr />
<h4 id="133-多态">1.3.3. 多态</h4>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"base construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"base destruct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"base func2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Child</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Child</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child destruct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child func2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Child2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Child</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Child2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child2 construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Child2</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child2 destruct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child2 func2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Child2</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">func2</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>结果</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base construct
child construct
Child2 construct
Child2 func2
base destruct
</code></pre></div></div>

<hr />
<ul>
  <li>delete 强制转换指针对象和不强制转换效果不一样。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Child2</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">func2</span><span class="p">();</span>
    <span class="k">delete</span> <span class="p">(</span><span class="n">Child2</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base construct
child construct
Child2 construct
Child2 func2
Child2 destruct
child destruct
base destruct
</code></pre></div></div>

<hr />
<ul>
  <li>虚析构函数，会调用父类的析构函数，避免内存泄漏</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream.h&gt;
#include &lt;string&gt;
</span>
<span class="n">class</span> <span class="n">Base</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"base construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"base destruct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"base func2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">Child</span> <span class="o">:</span> <span class="n">public</span> <span class="n">Base</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Child</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Child</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child destruct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child func2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">Child2</span> <span class="o">:</span> <span class="n">public</span> <span class="n">Child</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Child2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child2 construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Child2</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child2 destruct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child2 func2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Child2</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">func2</span><span class="p">();</span>
    <span class="n">delete</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>结果</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base construct
child construct
Child2 construct
Child2 func2
Child2 destruct
child destruct
base destruct
</code></pre></div></div>

<hr />
<h3 id="14-数组长度指针长度">1.4. 数组长度，指针长度</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="n">class</span> <span class="n">C</span> <span class="p">{</span>
    <span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">func3</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"class size: "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">szArray</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"1234567890"</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pArray</span> <span class="o">=</span> <span class="s">"1234567890"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ptr size:"</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pArray</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">", ptr len: "</span> <span class="o">&lt;&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">pArray</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"array size: "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">szArray</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">", array len: "</span> <span class="o">&lt;&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">szArray</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>结果：</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class size: 8
ptr size:8, ptr len: 10
array size: 11, array len: 10
</code></pre></div></div>
<blockquote>
  <p>class 有虚函数，所以有虚函数指针，普通函数内存被分配到代码区，static 函数被分配到全局数据区，所以 sizeof 大小只有 virtual 的虚函数指针，64位机器，指针长度 8 个字节。数组除了字符串，还有结束符‘\0’</p>
</blockquote>

<hr />
<h2 id="2-其它">2. 其它</h2>
<h3 id="21-malloc-和-new-区别">2.1. malloc 和 new 区别</h3>
<ol>
  <li>属性：new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</li>
  <li>参数：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</li>
  <li>返回类型：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回 void<em>，需要通过强制类型转换将void</em> 指针转换成我们需要的类型。</li>
  <li>分配失败：new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</li>
  <li>自定义类型：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li>
  <li>重载：C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</li>
  <li>内存区域：new操作符从<strong>自由存储区（free store）上为对象动态分配内存空间</strong>，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</li>
</ol>

<hr />
<h3 id="22-空类">2.2. 空类</h3>
<p>空类大小为 1</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"class size: "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>结果：</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class size: 1
</code></pre></div></div>
<p>这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。</p>

<hr />
<h2 id="3-参考">3. 参考</h2>
<p><a href="http://www.cplusplus.com/reference/">c++ 官网</a></p>
