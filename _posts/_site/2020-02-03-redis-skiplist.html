<p><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html">张铁蕾</a>的博客将 <code class="highlighter-rouge">skiplist</code> 原理和算法复杂度描述得很清楚，具体可以参考。我分享一下自己对部分源码的阅读情况和思考。</p>

<ul id="markdown-toc">
  <li><a href="#1-数据结构" id="markdown-toc-1-数据结构">1. 数据结构</a></li>
  <li><a href="#2-思路" id="markdown-toc-2-思路">2. 思路</a></li>
  <li><a href="#3-接口" id="markdown-toc-3-接口">3. 接口</a>    <ul>
      <li><a href="#31-插入结点" id="markdown-toc-31-插入结点">3.1. 插入结点</a></li>
      <li><a href="#32-流程描述" id="markdown-toc-32-流程描述">3.2. 流程描述</a></li>
    </ul>
  </li>
  <li><a href="#4-调试" id="markdown-toc-4-调试">4. 调试</a></li>
  <li><a href="#5-参考" id="markdown-toc-5-参考">5. 参考</a></li>
</ul>

<hr />

<h2 id="1-数据结构">1. 数据结构</h2>

<p>跳跃表是一个有序的双向链表。理解 <code class="highlighter-rouge">zskiplistNode</code> 的 <code class="highlighter-rouge">zskiplistLevel</code> 是理解<code class="highlighter-rouge">zskiplist</code>工作流程的关键。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ZSETs use a specialized version of Skiplists */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">ele</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">backward</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">;</span> <span class="c1">// 当前结点与 forward 指向的结点距离（跨越多少个结点），排名中应用。</span>
    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span> <span class="c1">// 层，可以理解结点的垂直纬度。</span>
<span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<h2 id="2-思路">2. 思路</h2>

<p>跳跃表是链表，链表查找<code class="highlighter-rouge">时间复杂度</code>是 $O(n)$，一般情况下，顺序查找比较慢。那比较取巧的，因为数据是顺序的，我们可以跳着找。例如下面 1 - 13 的数字，我们要找 9 这个数字。跳着找的流程是这样的:</p>

<p><img src="/images/2020-02-20-16-41-54.png" alt="跳跃查找" data-action="zoom" /></p>

<p>在第三步发现 11 比 9 大，就尝试跳更小的间距寻找合适的数据。同样的以此类推直到找到我们需要的数据。这样比我们顺序找要快很多。
我们可以拆分一下上图的查找流程。每次查找不到时，就重新定向查找。每次重新定向查找被看作一个层。</p>

<p><img src="/images/2020-02-20-16-42-09.png" alt="拆分层次" data-action="zoom" /></p>

<p>链表的层次，类似一个二维空间。每个结点有若干层，每一层将结点连接在一起建立关系，查找时 level 从最高层自上而下，结点从左到右。</p>

<p><img src="/images/2020-02-20-16-42-25.png" alt="层次" data-action="zoom" /></p>

<p>随机层 level，层数越高，概率越小。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ZSKIPLIST_MAXLEVEL 64 </span><span class="cm">/* Should be enough for 2^64 elements */</span><span class="cp">
#define ZSKIPLIST_P 0.25      </span><span class="cm">/* Skiplist P = 1/4 */</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">zslRandomLevel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 每增加一层概率是 ZSKIPLIST_P，所以层数越高，概率越小。</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">random</span><span class="p">()</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ZSKIPLIST_P</span> <span class="o">*</span> <span class="mh">0xFFFF</span><span class="p">))</span>
        <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 最高层数 ZSKIPLIST_MAXLEVEL</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">level</span><span class="o">&lt;</span><span class="n">ZSKIPLIST_MAXLEVEL</span><span class="p">)</span> <span class="o">?</span> <span class="n">level</span> <span class="o">:</span> <span class="n">ZSKIPLIST_MAXLEVEL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-接口">3. 接口</h2>

<h3 id="31-插入结点">3.1. 插入结点</h3>

<p>sorted set 功能实现，跳跃表结合 dict 使用。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 跳跃表并不是单独使用的，在 sorted set 中，结合 dict 使用。</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zset</span> <span class="p">{</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span> <span class="c1">// 保存 ele 数据作为 key</span>
    <span class="n">zskiplist</span> <span class="o">*</span><span class="n">zsl</span><span class="p">;</span> <span class="c1">// 跳跃表存储 ele</span>
<span class="p">}</span> <span class="n">zset</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">zsetAdd</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">zobj</span><span class="p">,</span> <span class="kt">double</span> <span class="n">score</span><span class="p">,</span> <span class="n">sds</span> <span class="n">ele</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">newscore</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">znode</span> <span class="o">=</span> <span class="n">zslInsert</span><span class="p">(</span><span class="n">zs</span><span class="o">-&gt;</span><span class="n">zsl</span><span class="p">,</span><span class="n">score</span><span class="p">,</span><span class="n">ele</span><span class="p">);</span>
    <span class="n">serverAssert</span><span class="p">(</span><span class="n">dictAdd</span><span class="p">(</span><span class="n">zs</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span><span class="n">ele</span><span class="p">,</span><span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">score</span><span class="p">)</span> <span class="o">==</span> <span class="n">DICT_OK</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>跳跃表插入结点。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Insert a new node in the skiplist. Assumes the element does not already
 * exist (up to the caller to enforce that). The skiplist takes ownership
 * of the passed SDS string 'ele'. */</span>
<span class="n">zskiplistNode</span> <span class="o">*</span><span class="nf">zslInsert</span><span class="p">(</span><span class="n">zskiplist</span> <span class="o">*</span><span class="n">zsl</span><span class="p">,</span> <span class="kt">double</span> <span class="n">score</span><span class="p">,</span> <span class="n">sds</span> <span class="n">ele</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// update 保存每层遍历到满足条件的最后一个结点。</span>
    <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">update</span><span class="p">[</span><span class="n">ZSKIPLIST_MAXLEVEL</span><span class="p">],</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>

    <span class="c1">// rank 排名保存 span 结点间距。</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rank</span><span class="p">[</span><span class="n">ZSKIPLIST_MAXLEVEL</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">level</span><span class="p">;</span>

    <span class="c1">// 二维空间，level自上而下遍历，结点从头到尾遍历，找到合适的插入结点位置。</span>
    <span class="n">serverAssert</span><span class="p">(</span><span class="o">!</span><span class="n">isnan</span><span class="p">(</span><span class="n">score</span><span class="p">));</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 下层保存上层的步距。</span>
        <span class="cm">/* store rank that is crossed to reach the insert position */</span>
        <span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">zsl</span><span class="o">-&gt;</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forward</span> <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forward</span><span class="o">-&gt;</span><span class="n">score</span> <span class="o">&lt;</span> <span class="n">score</span> <span class="o">||</span>
                    <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forward</span><span class="o">-&gt;</span><span class="n">score</span> <span class="o">==</span> <span class="n">score</span> <span class="o">&amp;&amp;</span>
                    <span class="n">sdscmp</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forward</span><span class="o">-&gt;</span><span class="n">ele</span><span class="p">,</span><span class="n">ele</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="c1">// 结点距离数目。</span>
            <span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">span</span><span class="p">;</span>
            <span class="c1">// 遍历下一个结点。</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forward</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 保存 i 层满足条件的最后一个结点。</span>
        <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* we assume the element is not already inside, since we allow duplicated
     * scores, reinserting the same element should never happen since the
     * caller of zslInsert() should test in the hash table if the element is
     * already inside or not. */</span>
    <span class="c1">// 随机层数</span>
    <span class="n">level</span> <span class="o">=</span> <span class="n">zslRandomLevel</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 初始化新增加的层，指向头结点，步距是列表的长度（结点个数）。</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
            <span class="c1">// 新增的 level 上是有指向结点指针的。</span>
            <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">span</span> <span class="o">=</span> <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 创建新的结点保存数据。</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">zslCreateNode</span><span class="p">(</span><span class="n">level</span><span class="p">,</span><span class="n">score</span><span class="p">,</span><span class="n">ele</span><span class="p">);</span>

    <span class="c1">// 插入结点到列表</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// level 自下而上与同层的插入位置前后结点建立联系。</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forward</span> <span class="o">=</span> <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forward</span><span class="p">;</span>
        <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forward</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

        <span class="cm">/* update span covered by update[i] as x is inserted here */</span>
        <span class="c1">// span：在同一个层级，当前结点到下一个结点的距离。</span>
        <span class="c1">// rank[0] - rank[i] 是插入位置，到 i 层所在结点的，结点距离。</span>
        <span class="c1">// update[i]-&gt;level[i].span 是插入位置到下一个结点到距离。</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">span</span> <span class="o">=</span> <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">span</span> <span class="o">-</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="c1">// 在 update[i] 后面添加了一个结点，span + 1</span>
        <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">span</span> <span class="o">=</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* increment span for untouched levels */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">span</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 处理双向结点的前后结点连接关系。</span>
    <span class="n">x</span><span class="o">-&gt;</span><span class="n">backward</span> <span class="o">=</span> <span class="p">(</span><span class="n">update</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">update</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">forward</span><span class="p">)</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">forward</span><span class="o">-&gt;</span><span class="n">backward</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">zsl</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="32-流程描述">3.2. 流程描述</h3>

<p>当 level 为 2 的链表，插入 level 为 3 的结点 5。（这里忽略了 ele 和 score 的处理）</p>
<blockquote>
  <p>插入数据的流程其实比不复杂，对于源码的理解，最好结合图表，这样大脑思考比较便捷。</p>
</blockquote>

<ul>
  <li>插入前</li>
</ul>

<p><img src="/images/2020-02-20-16-42-47.png" alt="插入前" data-action="zoom" /></p>

<ul>
  <li>插入后</li>
</ul>

<p><img src="/images/2020-02-20-16-43-11.png" alt="插入后" data-action="zoom" /></p>

<hr />

<h2 id="4-调试">4. 调试</h2>

<p>可以修改 redis 源码，跟踪一下工作流程。</p>

<blockquote>
  <p>调试方法可以参考我的帖子： <a href="https://wenfh2020.com/2020/01/05/redis-gdb/">用 gdb 调试 redis</a></p>
</blockquote>

<p><img src="/images/2020-02-20-16-43-29.png" alt="调试" data-action="zoom" /></p>

<p>server.c</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="n">zsetTest</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>t_zset.c</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">zsetTest</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">ele</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
    <span class="n">zskiplist</span> <span class="o">*</span><span class="n">zsl</span><span class="p">;</span>
    <span class="n">zskiplistNode</span> <span class="o">*</span> <span class="n">node</span><span class="p">;</span>

    <span class="n">score</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">ele</span> <span class="o">=</span> <span class="n">sdsfromlonglong</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>

    <span class="n">zsl</span> <span class="o">=</span> <span class="n">zslCreate</span><span class="p">();</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">zslInsert</span><span class="p">(</span><span class="n">zsl</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">ele</span><span class="p">);</span>

    <span class="n">score</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">ele</span> <span class="o">=</span> <span class="n">sdsfromlonglong</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">zslInsert</span><span class="p">(</span><span class="n">zsl</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">ele</span><span class="p">);</span>
    <span class="n">zslFree</span><span class="p">(</span><span class="n">zsl</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="5-参考">5. 参考</h2>

<ul>
  <li>《redis 设计与实现》</li>
  <li><a href="https://redis.io/commands/zadd">redis commands</a></li>
  <li><a href="https://mp.weixin.qq.com/s/rXIVIW7RM56xwMaQtKnmqA">Redis为什么用跳表而不用平衡树？</a></li>
</ul>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/">wenfh2020.com</a></p>
</blockquote>
