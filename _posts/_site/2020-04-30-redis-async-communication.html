<table>
  <thead>
    <tr>
      <th style="text-align: left">重点</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">服务异步通信核心</td>
      <td style="text-align: left">非阻塞 + 异步事件驱动。</td>
    </tr>
    <tr>
      <td style="text-align: left">事件驱动核心源码</td>
      <td style="text-align: left">ae.c</td>
    </tr>
    <tr>
      <td style="text-align: left">网络通信核心源码</td>
      <td style="text-align: left">connection.h / connection.c，networking.h / connection.c</td>
    </tr>
    <tr>
      <td style="text-align: left">读/写数据核心函数</td>
      <td style="text-align: left">readQueryFromClient / writeToClient</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>本文主要讲述 Linux 平台下的 redis 客户端与服务端异步通信（单线程），不包括 redis 集群间的通信。</p>
</blockquote>

<ul id="markdown-toc">
  <li><a href="#1-异步服务工作流程" id="markdown-toc-1-异步服务工作流程">1. 异步服务工作流程</a></li>
  <li><a href="#2-非阻塞" id="markdown-toc-2-非阻塞">2. 非阻塞</a>    <ul>
      <li><a href="#21-socket-非塞设置" id="markdown-toc-21-socket-非塞设置">2.1. socket 非塞设置</a></li>
      <li><a href="#22-网络通信函数" id="markdown-toc-22-网络通信函数">2.2. 网络通信函数</a></li>
    </ul>
  </li>
  <li><a href="#3-事件驱动" id="markdown-toc-3-事件驱动">3. 事件驱动</a>    <ul>
      <li><a href="#31-epoll-接口" id="markdown-toc-31-epoll-接口">3.1. epoll 接口</a></li>
      <li><a href="#32-epoll-使用逻辑" id="markdown-toc-32-epoll-使用逻辑">3.2. epoll 使用逻辑</a></li>
      <li><a href="#33-异步回调" id="markdown-toc-33-异步回调">3.3. 异步回调</a>        <ul>
          <li><a href="#331-跨平台" id="markdown-toc-331-跨平台">3.3.1. 跨平台</a></li>
          <li><a href="#332-事件回调异步逻辑" id="markdown-toc-332-事件回调异步逻辑">3.3.2. 事件回调异步逻辑</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#4-服务数据结构" id="markdown-toc-4-服务数据结构">4. 服务数据结构</a>    <ul>
      <li><a href="#41-服务端结构" id="markdown-toc-41-服务端结构">4.1. 服务端结构</a></li>
      <li><a href="#42-客户端结构" id="markdown-toc-42-客户端结构">4.2. 客户端结构</a></li>
    </ul>
  </li>
  <li><a href="#5-参考" id="markdown-toc-5-参考">5. 参考</a></li>
</ul>

<hr />

<h2 id="1-异步服务工作流程">1. 异步服务工作流程</h2>

<p>redis 客户端与服务端异步通信流程，整体逻辑有点复杂，先看看流程图，后面再抓抓重点。</p>

<blockquote>
  <p>看不清楚图片，可以将其下载到电脑本地打开查看。</p>
</blockquote>

<p><img src="/images/2020-05-04-01-19-51.png" alt="异步服务工作流程" data-action="zoom" /></p>

<hr />

<h2 id="2-非阻塞">2. 非阻塞</h2>

<h3 id="21-socket-非塞设置">2.1. socket 非塞设置</h3>

<p>redis 客户端与服务端通过 TCP 协议进行通信。服务监听端口创建的 socket，客户端接入服务的 socket，都需要设置非阻塞。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">anetNonBlock</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">anetSetBlock</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">anetSetBlock</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">non_block</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">anetSetError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"fcntl(F_GETFL): %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">ANET_ERR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">non_block</span><span class="p">)</span>
        <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">O_NONBLOCK</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">anetSetError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"fcntl(F_SETFL,O_NONBLOCK): %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">ANET_ERR</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ANET_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="22-网络通信函数">2.2. 网络通信函数</h3>

<p>socket 非阻塞设置后，部分默认阻塞的函数，变成非阻塞，数据一次没有处理完的情况下，函数返回结果 <code class="highlighter-rouge">-1</code>，错误 <code class="highlighter-rouge">errno</code> 是 <code class="highlighter-rouge">EAGAIN</code> 或 <code class="highlighter-rouge">EWOULDBLOCK</code>。</p>

<ul>
  <li>accept</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">acceptTcpHandler</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span><span class="p">(</span><span class="n">max</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cfd</span> <span class="o">=</span> <span class="n">anetTcpAccept</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">cip</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cip</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cport</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cfd</span> <span class="o">==</span> <span class="n">ANET_ERR</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EWOULDBLOCK</span><span class="p">)</span>
                <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span>
                    <span class="s">"Accepting client connection: %s"</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">anetGenericAccept</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">sa</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">anetSetError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"accept: %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
                <span class="k">return</span> <span class="n">ANET_ERR</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>read</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">connSocketRead</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">conn</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CONN_STATE_CLOSED</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_errno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
        <span class="n">conn</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CONN_STATE_ERROR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>write</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">connSocketWrite</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">data_len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_len</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_errno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
        <span class="n">conn</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CONN_STATE_ERROR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-事件驱动">3. 事件驱动</h2>

<p>redis 服务通过事件驱动监控 fd 读写事件。redis 在 Linux 系统事件驱动默认选择 <code class="highlighter-rouge">epoll</code>。</p>

<h3 id="31-epoll-接口">3.1. epoll 接口</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">接口</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">epoll_create</td>
      <td style="text-align: left">创建 epoll 事件驱动。</td>
    </tr>
    <tr>
      <td style="text-align: left">epoll_ctl</td>
      <td style="text-align: left">事件驱动对 fd 对应事件进行增删改管理。</td>
    </tr>
    <tr>
      <td style="text-align: left">epoll_wait</td>
      <td style="text-align: left">阻塞从内核获取就绪事件。接口有时间参数，可以设置阻塞等待时间。</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="32-epoll-使用逻辑">3.2. epoll 使用逻辑</h3>

<p>socket 设置非阻塞后，write / read，有可能不是一次性将数据读写完成再返回（参考 2.2 章节）。redis 采用 <code class="highlighter-rouge">epoll</code> 默认模式是 <code class="highlighter-rouge">LT</code>，当数据没处理完，内核重复通知事件给服务处理。</p>

<ul>
  <li>read 数据，只要没有读取完成 fd 对应的所有接收数据，内核会不停通知 <code class="highlighter-rouge">EPOLLIN</code> 读事件。即 <code class="highlighter-rouge">epoll_wait</code> 不停取出读事件要求读数据，直到 read 所有接收到的数据，才会停止 <code class="highlighter-rouge">EPOLLIN</code> 读事件通知。</li>
  <li>write 数据，服务一次发送不完，那么需要服务主动调用 <code class="highlighter-rouge">epoll_ctl</code> 监控写事件，下次 <code class="highlighter-rouge">epoll_wait</code> 会通知 <code class="highlighter-rouge">EPOLLOUT</code> 事件，服务继续处理写事件，直到将数据发送完毕为止。数据发送完毕后，再通过 <code class="highlighter-rouge">epoll_ctl</code> 取消监控 <code class="highlighter-rouge">EPOLLOUT</code> 写事件。（参考 <code class="highlighter-rouge">sendReplyToClient</code>源码实现逻辑）</li>
</ul>

<hr />

<h3 id="33-异步回调">3.3. 异步回调</h3>

<p>redis 对事件驱动封装了一层，核心代码在 <code class="highlighter-rouge">ae.c</code>，目的有两个：跨平台，异步回调。</p>

<h4 id="331-跨平台">3.3.1. 跨平台</h4>

<p>跨平台，不同平台可以根据预编译宏，选择对应平台的事件驱动。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef HAVE_EVPORT
#include "ae_evport.c"
#else
</span>    <span class="cp">#ifdef HAVE_EPOLL
</span>    <span class="cp">#include "ae_epoll.c"
</span>    <span class="cp">#else
</span>        <span class="cp">#ifdef HAVE_KQUEUE
</span>        <span class="cp">#include "ae_kqueue.c"
</span>        <span class="cp">#else
</span>        <span class="cp">#include "ae_select.c"
</span>        <span class="cp">#endif
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<hr />

<h4 id="332-事件回调异步逻辑">3.3.2. 事件回调异步逻辑</h4>

<p>事件驱动异步回调的核心逻辑是 fd + 事件 + 事件对应处理函数。参考源码：</p>

<ol>
  <li>数据结构：<code class="highlighter-rouge">aeFileEvent</code>，<code class="highlighter-rouge">client</code>， <code class="highlighter-rouge">connection</code>。</li>
  <li>回调函数：<code class="highlighter-rouge">acceptTcpHandler</code>，<code class="highlighter-rouge">readQueryFromClient</code>， <code class="highlighter-rouge">sendReplyToClient</code>。</li>
</ol>

<ul>
  <li>服务端回调流程</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aeEventLoop -&gt; epoll_wait<span class="o">(</span>fd + events<span class="o">)</span> -&gt; aeFileEvent.rfileProc -&gt; acceptTcpHandler
</code></pre></div></div>

<ul>
  <li>客户端回调流程</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aeEventLoop -&gt; epoll_wait<span class="o">(</span>fd + events<span class="o">)</span> -&gt; aeFileEvent.rfileProc/wfileProc -&gt; client.connection.ae_handler
</code></pre></div></div>

<ul>
  <li>事件结构</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// events 是一个以 fd 为下标的事件数组。</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span> <span class="c1">// 事件数组。</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">aeEventLoop</span><span class="p">;</span>

<span class="cm">/* File event structure */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeFileEvent</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span> <span class="cm">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span>
    <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">rfileProc</span><span class="p">;</span> <span class="c1">// 读回调函数。</span>
    <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">wfileProc</span><span class="p">;</span> <span class="c1">// 写回调函数。</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">;</span> <span class="c1">// client 的 connection 指针。</span>
<span class="p">}</span> <span class="n">aeFileEvent</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>fd 文件描述符在内核里也相当于一个下标，递增的，它对应的是文件。Linux 一切皆文件，所以 socket 本质上也是一个文件。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// file.c</span>
<span class="kt">void</span> <span class="nf">fd_install</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__fd_install</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-服务数据结构">4. 服务数据结构</h2>

<p>redis 的异步逻辑挺多细节的，结合上图，重点理解一下下列数据结构的一些成员。</p>

<h3 id="41-服务端结构">4.1. 服务端结构</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients</span><span class="p">;</span>              <span class="cm">/* List of active clients */</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients_to_close</span><span class="p">;</span>     <span class="cm">/* Clients to close asynchronously */</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients_pending_write</span><span class="p">;</span> <span class="cm">/* There is to write or install handler. */</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients_pending_read</span><span class="p">;</span>  <span class="cm">/* Client has pending read socket buffers. */</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: left">成员</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">clients</td>
      <td style="text-align: left">客户端链表，客户端新连接会存储在链表里。</td>
    </tr>
    <tr>
      <td style="text-align: left">clients_to_close</td>
      <td style="text-align: left">客户端关闭链表， 放在 <code class="highlighter-rouge">beforeSleep</code> 里进行异步关闭。</td>
    </tr>
    <tr>
      <td style="text-align: left">clients_pending_write</td>
      <td style="text-align: left">延迟写数据客户端链表，异步操作，数据并不是读出来进行处理后就马上发送的，服务处理完逻辑后会将回复数据写入 client 的写入缓冲区（buf/reply），并记录下当前客户端，在 <code class="highlighter-rouge">beforeSleep</code> 里进行统一发送。（参考 <code class="highlighter-rouge">clientInstallWriteHandler</code> 源码）</td>
    </tr>
    <tr>
      <td style="text-align: left">clients_pending_read</td>
      <td style="text-align: left">延迟读数据客户端链表，异步读数据，服务开启多线程处理读数据处理方式才会用到。（参考 <code class="highlighter-rouge">postponeClientRead</code> 源码）</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="42-客户端结构">4.2. 客户端结构</h3>

<p>当客户端连接 redis 服务，redis 服务用 <code class="highlighter-rouge">client</code> 结构保存了客户端通信的相关信息。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// server.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">client</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">id</span><span class="p">;</span>            <span class="cm">/* Client incremental unique ID. */</span>
    <span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">sds</span> <span class="n">querybuf</span><span class="p">;</span>           <span class="cm">/* Buffer we use to accumulate client queries. */</span>
    <span class="kt">size_t</span> <span class="n">qb_pos</span><span class="p">;</span>          <span class="cm">/* The position we have read in querybuf. */</span>
    <span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>               <span class="cm">/* Num of arguments of current command. */</span>
    <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">;</span>            <span class="cm">/* Arguments of current command. */</span>
    <span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">lastcmd</span><span class="p">;</span>  <span class="cm">/* Last command executed. */</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>            <span class="cm">/* List of reply objects to send to the client. */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">reply_bytes</span><span class="p">;</span> <span class="cm">/* Tot bytes of objects in reply list. */</span>
    <span class="p">...</span>
    <span class="cm">/* Response buffer */</span>
    <span class="kt">int</span> <span class="n">bufpos</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">PROTO_REPLY_CHUNK_BYTES</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: left">成员</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">id</td>
      <td style="text-align: left">redis 服务分配的递增 id。（参考 <code class="highlighter-rouge">createClient</code> 源码）</td>
    </tr>
    <tr>
      <td style="text-align: left">conn</td>
      <td style="text-align: left">客户端链接对象，封装了网络相关操作：读写数据，事件驱动接口调用，网络事件回调逻辑等。</td>
    </tr>
    <tr>
      <td style="text-align: left">querybuf</td>
      <td style="text-align: left">读缓存，服务读取客户端发送的数据然后写入 client.querybuf 缓存。</td>
    </tr>
    <tr>
      <td style="text-align: left">qb_pos</td>
      <td style="text-align: left">读缓存处理位置，客户端发送给服务的可能是命令，redis 服务读取数据后，需要进行逻辑处理，因为是非阻塞操作，并不是每次 read 都能把客户端发送的数据全部读取出来，也有可能因为 tcp 通信，遇到粘包问题，很可能客户端连续发了 2 个命令，服务端只 read 出了 1 个半命令，另外一部分下次再 read。这时候服务端可以先处理完一个命令，标记 querybuf 处理的位置 qb_pos，然后对 querybuf 数据所在 qb_pos 位置进行截断，剩下那半个命令，下次读出完整的命令后再进行逻辑处理。 （参考 <code class="highlighter-rouge">processInputBuffer</code> 源码）</td>
    </tr>
    <tr>
      <td style="text-align: left">argc</td>
      <td style="text-align: left">当前命令参数个数。 redis 有自己的通信协议 RESP，服务读取数据后，需要将 RESP 协议参数解析出来。argc 存放了命令由多少个字符串组成的。</td>
    </tr>
    <tr>
      <td style="text-align: left">argv</td>
      <td style="text-align: left">当前命令参数数组。参考 argc 解析。例如命令 <code class="highlighter-rouge">set key123 value123</code>，argc 命令参数个数是 3，argv 字符串数组分别为 [“set”,”key123”,”123”]。</td>
    </tr>
    <tr>
      <td style="text-align: left">cmd</td>
      <td style="text-align: left">当前命令对象指针。redis 解析 RESP 协议数据后，解析出对应的命令参数，那么需要进行 redis 对应命令的逻辑处理，例如 <code class="highlighter-rouge">set</code> 命令对应 <code class="highlighter-rouge">setCommnad</code> 命令处理函数。（参考 <code class="highlighter-rouge">struct redisCommand</code> 源码）</td>
    </tr>
    <tr>
      <td style="text-align: left">reply</td>
      <td style="text-align: left">回复数据链表，这是一个动态内存结构，一般回复数据比较短( &lt; 16k )的情况下，不会用到它，用 buf 处理就够了，但是数据很多的情况下，那么就要分配动态内存去管理这些数据。每次申请一个连续内存的数据块，进行存储，用完了，再申请一个新的数据块，然后这些数据块通过链表顺序串联起来管理。（参考 <code class="highlighter-rouge">_addReplyProtoToList</code> 源码）</td>
    </tr>
    <tr>
      <td style="text-align: left">reply_bytes</td>
      <td style="text-align: left">reply 链表上的回复数据占用内存总和。</td>
    </tr>
    <tr>
      <td style="text-align: left">bufpos</td>
      <td style="text-align: left">buf 回复缓存数据位置，记录 buf 的数据长度。（ 参考 <code class="highlighter-rouge">_addReplyToBuffer</code> 源码）</td>
    </tr>
    <tr>
      <td style="text-align: left">buf</td>
      <td style="text-align: left">回复数据缓存，一般回复数据长度小于 16k 会保存在 buf。（<code class="highlighter-rouge">#define PROTO_REPLY_CHUNK_BYTES (16*1024)</code>），回复数据 16k 以内的使用频率比较高。buf 和 reply 分开处理，比较高效。</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="5-参考">5. 参考</h2>

<ul>
  <li>redis 6.0 源码</li>
  <li><a href="https://wenfh2020.com/2020/04/09/redis-ae-file/">[redis 源码走读] 事件 - 文件事件</a></li>
  <li><a href="https://wenfh2020.com/2020/04/14/epoll-workflow/">epoll 多路复用 I/O工作流程</a></li>
  <li><a href="https://wenfh2020.com/2020/04/06/ae-timer/">[redis 源码走读] 事件 - 定时器</a></li>
</ul>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/2020/04/30/redis-async-communication/">wenfh2020.com</a></p>
</blockquote>
