<p>redis 主从模式主要作用：读写分离，提高系统的负载能力；集群模式下，保证服务高可用。</p>

<p>本章走读 redis 6.0 源码 <a href="https://github.com/antirez/redis">github</a>，理解 redis 主从数据复制流程。</p>

<blockquote>
  <p>承接上一章 <a href="https://wenfh2020.com/2020/05/17/redis-replication/">[redis 源码走读] 主从数据复制（上）</a>。</p>
</blockquote>

<ul id="markdown-toc">
  <li><a href="#1-psync" id="markdown-toc-1-psync">1. PSYNC</a>    <ul>
      <li><a href="#11-slave" id="markdown-toc-11-slave">1.1. slave</a></li>
      <li><a href="#12-master" id="markdown-toc-12-master">1.2. master</a></li>
    </ul>
  </li>
  <li><a href="#2-服务副本-id" id="markdown-toc-2-服务副本-id">2. 服务副本 ID</a></li>
  <li><a href="#3-复制偏移量" id="markdown-toc-3-复制偏移量">3. 复制偏移量</a>    <ul>
      <li><a href="#31-master" id="markdown-toc-31-master">3.1. master</a></li>
      <li><a href="#32-slave" id="markdown-toc-32-slave">3.2. slave</a></li>
      <li><a href="#33-rdb" id="markdown-toc-33-rdb">3.3. rdb</a></li>
    </ul>
  </li>
  <li><a href="#4-复制积压缓冲区" id="markdown-toc-4-复制积压缓冲区">4. 复制积压缓冲区</a></li>
  <li><a href="#5-数据结构" id="markdown-toc-5-数据结构">5. 数据结构</a>    <ul>
      <li><a href="#51-redisserver" id="markdown-toc-51-redisserver">5.1. redisServer</a></li>
      <li><a href="#52-client" id="markdown-toc-52-client">5.2. client</a></li>
    </ul>
  </li>
  <li><a href="#6-总结" id="markdown-toc-6-总结">6. 总结</a></li>
  <li><a href="#7-参考" id="markdown-toc-7-参考">7. 参考</a></li>
</ul>

<hr />

<h2 id="1-psync">1. PSYNC</h2>

<p><img src="/images/2020-06-04-16-53-39.png" alt="psync 工作流程" data-action="zoom" /></p>

<h3 id="11-slave">1.1. slave</h3>

<ul>
  <li>发送 PSYNC 命令，处理 master 回复。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">syncWithMaster</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REPL_STATE_SEND_PSYNC</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// slave 发送 PSYNC 命令给 master。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slaveTryPartialResynchronization</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">PSYNC_WRITE_ERROR</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">sdsnew</span><span class="p">(</span><span class="s">"Write error sending the PSYNC command."</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">write_error</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REPL_STATE_RECEIVE_PSYNC</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="c1">// slave 处理 PSYNC 命令的回复数据包。</span>
    <span class="n">psync_result</span> <span class="o">=</span> <span class="n">slaveTryPartialResynchronization</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="cm">/* 增量同步。
     * slave 通过 readQueryFromClient 异步接收 master 增量数据。
     * 复制双方链接成功，slave 通过 replicationResurrectCachedMaster
     * 绑定 readQueryFromClient 异步接收复制数据。*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">psync_result</span> <span class="o">==</span> <span class="n">PSYNC_CONTINUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 全量复制。
     * slave 通过 readSyncBulkPayload() 异步接收 master 发送的 rdb 文件数据。*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connSetReadHandler</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">readSyncBulkPayload</span><span class="p">)</span> <span class="o">==</span> <span class="n">C_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>增量 / 全量复制。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">slaveTryPartialResynchronization</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read_reply</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_reply</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="cm">/* 复制双方有可能是断线重连，断线后，原来的链接 server.master 失效，被回收，
         * 为了重复利用原有数据，slave 会缓存 server.master 链接到 server.cached_master。*/</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">psync_replid</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">replid</span><span class="p">;</span>
            <span class="c1">// slave 发送当前的数据偏移量。</span>
            <span class="n">snprintf</span><span class="p">(</span><span class="n">psync_offset</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">psync_offset</span><span class="p">),</span><span class="s">"%lld"</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">reploff</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// slave 第一次链接 master，还没有 master 对应数据，所以用特殊符号标识。</span>
            <span class="n">psync_replid</span> <span class="o">=</span> <span class="s">"?"</span><span class="p">;</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">psync_offset</span><span class="p">,</span><span class="s">"-1"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// slave 发送 PSYNC 命令到 master。</span>
        <span class="n">reply</span> <span class="o">=</span> <span class="n">sendSynchronousCommand</span><span class="p">(</span><span class="n">SYNC_CMD_WRITE</span><span class="p">,</span><span class="n">conn</span><span class="p">,</span><span class="s">"PSYNC"</span><span class="p">,</span><span class="n">psync_replid</span><span class="p">,</span><span class="n">psync_offset</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="cm">/* 全量复制。
     * slave 接收到 master 的回复：+FULLRESYNC &lt;replid&gt; &lt;offset&gt;
     * slave 先更新对应数据，后续 readSyncBulkPayload() 异步接收 master 发送的 rdb 文件数据，
     * 当 rdb 文件数据接收完毕，slave 重新加载对应的 rdb 文件，这样实现全量复制。*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span><span class="s">"+FULLRESYNC"</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">replid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/* FULL RESYNC, parse the reply in order to extract the run id
         * and the replication offset. */</span>
        <span class="n">replid</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span><span class="sc">' '</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">replid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">replid</span><span class="o">++</span><span class="p">;</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">replid</span><span class="p">,</span><span class="sc">' '</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="n">offset</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">replid</span> <span class="o">||</span> <span class="o">!</span><span class="n">offset</span> <span class="o">||</span> <span class="p">(</span><span class="n">offset</span><span class="o">-</span><span class="n">replid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CONFIG_RUN_ID_SIZE</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 全量复制出现错误。</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master_replid</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// slave 更新 master 对应的 replid 和 offset。</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master_replid</span><span class="p">,</span> <span class="n">replid</span><span class="p">,</span> <span class="n">offset</span><span class="o">-</span><span class="n">replid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">server</span><span class="p">.</span><span class="n">master_replid</span><span class="p">[</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
            <span class="n">server</span><span class="p">.</span><span class="n">master_initial_offset</span> <span class="o">=</span> <span class="n">strtoll</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 链接成功，清除旧的缓存链接数据，建立新的通信链接。</span>
        <span class="n">replicationDiscardCachedMaster</span><span class="p">();</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">PSYNC_FULLRESYNC</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 增量复制
     * slave 接收到 master 的回复： +CONTINUE &lt;new repl ID&gt; */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span><span class="s">"+CONTINUE"</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 检查 master 是否有新的 &lt;new repl ID&gt;，有可能 redis 集群故障转移后，集群产生新的 master。</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">reply</span><span class="o">+</span><span class="mi">10</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">reply</span><span class="o">+</span><span class="mi">9</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\r'</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\n'</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="n">end</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span> <span class="o">==</span> <span class="n">CONFIG_RUN_ID_SIZE</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">new</span><span class="p">[</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">new</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="p">);</span>
            <span class="n">new</span><span class="p">[</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">replid</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/* 缓存旧的 replid2 和 second_replid_offset。
                 * 因为当前 slave 可能有子服务 sub-slave，需要方便它们进行数据复制。*/</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">replid2</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">replid</span><span class="p">,</span>
                    <span class="k">sizeof</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">replid2</span><span class="p">));</span>
                <span class="n">server</span><span class="p">.</span><span class="n">second_replid_offset</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

                <span class="cm">/* 更新 slave 当前的 replid。一般只有 master 才有自己独立的 replid。
                 * 所以 slave 的 replid 保存 master 的 replid。*/</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">replid</span><span class="p">,</span><span class="n">new</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">replid</span><span class="p">));</span>
                <span class="cm">/* 更新 master client 对应的 replid。
                 * 因为增量同步是之前曾经链接成功的，后来断开链接了，需要缓存断开的链接
                 * 方便后续重连操作。所以会将原来 server.master，缓存到 server.cached_master。
                 * 当重连成功后 server.cached_master 会被清空。详看 replicationResurrectCachedMaster()。*/</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">replid</span><span class="p">,</span><span class="n">new</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">replid</span><span class="p">));</span>

                <span class="c1">// 如果当前 slave 有子服务 sub-slave，断开子服务链接，让它们重新走 PSYNC 同步流程。</span>
                <span class="n">disconnectSlaves</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">sdsfree</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
        <span class="c1">// 链接成功，清除旧的缓存链接数据，建立新的通信链接。</span>
        <span class="n">replicationResurrectCachedMaster</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>

        <span class="c1">// 如果积压缓冲区被清空，那么重新创建，如果有 sub-slave 方便数据复制。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">createReplicationBacklog</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">PSYNC_CONTINUE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="12-master">1.2. master</h3>

<ul>
  <li>处理 PSYNC 命令。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">syncCommand</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">"psync"</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 检查复制方式。
         * 增量复制，master 从缓冲区给 slave 发送增量数据。
         * 全量复制，master 创建 rdb 快照，异步发送 slave */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">masterTryPartialResynchronization</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">C_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">server</span><span class="p">.</span><span class="n">stat_sync_partial_ok</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="c1">// 全量复制。</span>
    <span class="n">server</span><span class="p">.</span><span class="n">stat_sync_full</span><span class="o">++</span><span class="p">;</span>

    <span class="c1">// 更新链接同步状态，建立 slave 数据复制链接。</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">=</span> <span class="n">SLAVE_STATE_WAIT_BGSAVE_START</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_disable_tcp_nodelay</span><span class="p">)</span>
        <span class="n">connDisableTcpNoDelay</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">);</span> <span class="cm">/* Non critical if it fails. */</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">repldbfd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CLIENT_SLAVE</span><span class="p">;</span>
    <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>

    <span class="c1">// 创建复制的积压缓冲区对应数据。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* When we create the backlog from scratch, we always use a new
         * replication ID and clear the ID2, since there is no valid
         * past history. */</span>
        <span class="n">changeReplicationId</span><span class="p">();</span>
        <span class="n">clearReplicationId2</span><span class="p">();</span>
        <span class="n">createReplicationBacklog</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="cm">/* 如果当前没有子进程正在建立 rdb 文件快照。开始创建 rdb 文件快照 流程。
     * 否则放在时钟里进行定期检查处理，延时该流程。*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hasActiveChildProcess</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">startBgsaveForReplication</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">slave_capa</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>检查处理复制方式。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">masterTryPartialResynchronization</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// 检查 replid 是否一致，检查 slave 的数据偏移量是否超出缓存数据偏移量的范围。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">master_replid</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">replid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">master_replid</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">replid2</span><span class="p">)</span> <span class="o">||</span>
         <span class="n">psync_offset</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">second_replid_offset</span><span class="p">))</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="c1">// 全量复制</span>
        <span class="k">goto</span> <span class="n">need_full_resync</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 检查 slave 的数据偏移量，是否在主服务的数据缓冲区范围内。</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">||</span>
        <span class="n">psync_offset</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span> <span class="o">||</span>
        <span class="n">psync_offset</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span> <span class="o">+</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span><span class="p">))</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="c1">// 全量复制</span>
        <span class="k">goto</span> <span class="n">need_full_resync</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>

    <span class="c1">// 增量复制</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">slave_capa</span> <span class="o">&amp;</span> <span class="n">SLAVE_CAPA_PSYNC2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buflen</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="s">"+CONTINUE %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">replid</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">buflen</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="s">"+CONTINUE</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 发送 +CONTINUE 增量同步回包。注意这里是同步发送的，避免异步导致新的数据到来破坏当前同步场景。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connWrite</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">buflen</span><span class="p">)</span> <span class="o">!=</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 发送增量数据。</span>
    <span class="n">psync_len</span> <span class="o">=</span> <span class="n">addReplyReplicationBacklog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">psync_offset</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span> <span class="cm">/* The caller can return, no full resync needed. */</span>

<span class="nl">need_full_resync:</span>
    <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="2-服务副本-id">2. 服务副本 ID</h2>

<p>每个 <strong>master</strong> 拥有自己的副本 ID &lt;replid&gt;。</p>

<p>slave 向 master 复制数据，需要记录下 master 的 &lt;replid&gt;，这样每次主从断线重连后，slave 都可以发送自己缓存的 &lt;replid&gt; 给 master，这样来确认是否需要全量复制或增量复制数据。因为主从断开网络后，有很多种可能性，可能因为网络抖动，也可能因为集群故障转移等原因。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// master 接收 slave 的 PSYNC 命令，检查 replid 是否一致。</span>
<span class="kt">int</span> <span class="nf">masterTryPartialResynchronization</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// 检查 replid 是否一致。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">master_replid</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">replid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">master_replid</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">replid2</span><span class="p">)</span> <span class="o">||</span>
         <span class="n">psync_offset</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">second_replid_offset</span><span class="p">))</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">goto</span> <span class="n">need_full_resync</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="c1">// 增量同步</span>
    <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span> <span class="cm">/* The caller can return, no full resync needed. */</span>

<span class="c1">// 全量复制</span>
<span class="nl">need_full_resync:</span>
    <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-复制偏移量">3. 复制偏移量</h2>

<p>主从服务双方会维护一个复制偏移量（一个数据统计值）。</p>

<p>master 把需要同步给 slave 的数据填充到积压缓冲区，并且更新复制偏移量的值。这样，双方的偏移量可以通过对比，可以知道双方数据相差多少。</p>

<h3 id="31-master">3.1. master</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">master_repl_offset</span><span class="p">;</span>   <span class="cm">/* My current replication offset */</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// master 需要同步给 slave 的数据都会调用 feedReplicationBacklog，写入缓冲区并更新复制偏移量。</span>
<span class="kt">void</span> <span class="nf">feedReplicationBacklog</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// master 复制偏移量</span>
    <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="32-slave">3.2. slave</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">client</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">reploff</span><span class="p">;</span>      <span class="cm">/* Applied replication offset if this is a master. */</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* 增量同步和正常链接下的数据复制。
 * slave 接收到 master 发送的数据，处理命令后，偏移量增加已处理数据数量
 * （因为 TCP 有可能因为粘包问题，接收数据不是完整的，所以不能全部处理完）。*/</span>
<span class="kt">int</span> <span class="nf">processCommandAndResetClient</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">deadclient</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">current_client</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">processCommand</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">C_OK</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MULTI</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// 接收数据后，追加已处理的数据总量到复制偏移量。</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">reploff</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">read_reploff</span> <span class="o">-</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// 断线重连，slave 向 master 发送 PSYNC 命令，确认是增量同步，还是全量复制。</span>
<span class="kt">int</span> <span class="nf">slaveTryPartialResynchronization</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read_reply</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_reply</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">psync_replid</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">replid</span><span class="p">;</span>
            <span class="c1">// 断线重连 slave 发送保存的数据偏移量。</span>
            <span class="n">snprintf</span><span class="p">(</span><span class="n">psync_offset</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">psync_offset</span><span class="p">),</span><span class="s">"%lld"</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">reploff</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// slave 第一次链接 master，还没有偏移量，所以用 -1 填充。</span>
            <span class="n">psync_replid</span> <span class="o">=</span> <span class="s">"?"</span><span class="p">;</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">psync_offset</span><span class="p">,</span><span class="s">"-1"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// slave 发送 PSYNC 命令到 master。</span>
        <span class="n">reply</span> <span class="o">=</span> <span class="n">sendSynchronousCommand</span><span class="p">(</span><span class="n">SYNC_CMD_WRITE</span><span class="p">,</span><span class="n">conn</span><span class="p">,</span><span class="s">"PSYNC"</span><span class="p">,</span><span class="n">psync_replid</span><span class="p">,</span><span class="n">psync_offset</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="c1">// slave 接收到 master 的回复，进行全量复制。</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span><span class="s">"+FULLRESYNC"</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master_replid</span><span class="p">,</span> <span class="n">replid</span><span class="p">,</span> <span class="n">offset</span><span class="o">-</span><span class="n">replid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">server</span><span class="p">.</span><span class="n">master_replid</span><span class="p">[</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="c1">// 更新最新的数据偏移量。</span>
        <span class="n">server</span><span class="p">.</span><span class="n">master_initial_offset</span> <span class="o">=</span> <span class="n">strtoll</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
        <span class="p">...</span>
        <span class="k">return</span> <span class="n">PSYNC_FULLRESYNC</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// 全量复制，slave 接收 master 发送的 rdb 文件数据，加载数据并初始化数据偏移量。</span>
<span class="kt">void</span> <span class="nf">readSyncBulkPayload</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">replicationCreateMasterClient</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_s</span><span class="p">,</span><span class="n">rsi</span><span class="p">.</span><span class="n">repl_stream_db</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">// slave 更新这个值，因为 slave 有可能要复制数据到 sub-slave。</span>
    <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">reploff</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">replicationCreateMasterClient</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dbid</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// slave 更新数据偏移量到 reploff。</span>
    <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">reploff</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master_initial_offset</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="33-rdb">3.3. rdb</h3>

<p>双方全量复制，通过 rdb 文件传输。rdb 会保存 replid 和 server.master_repl_offset 信息。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">rdbSaveInfoAuxFields</span><span class="p">(</span><span class="n">rio</span> <span class="o">*</span><span class="n">rdb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rdbflags</span><span class="p">,</span> <span class="n">rdbSaveInfo</span> <span class="o">*</span><span class="n">rsi</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="cm">/* Handle saving options that generate aux fields. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rsi</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 当前 master 正在操作的 db。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rdbSaveAuxFieldStrInt</span><span class="p">(</span><span class="n">rdb</span><span class="p">,</span><span class="s">"repl-stream-db"</span><span class="p">,</span><span class="n">rsi</span><span class="o">-&gt;</span><span class="n">repl_stream_db</span><span class="p">)</span>
            <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="c1">// master 的 replid。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rdbSaveAuxFieldStrStr</span><span class="p">(</span><span class="n">rdb</span><span class="p">,</span><span class="s">"repl-id"</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">replid</span><span class="p">)</span>
            <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="c1">// master 的数据偏移量。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rdbSaveAuxFieldStrInt</span><span class="p">(</span><span class="n">rdb</span><span class="p">,</span><span class="s">"repl-offset"</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span><span class="p">)</span>
            <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-复制积压缓冲区">4. 复制积压缓冲区</h2>

<p>复制积压缓冲区，是一个连续内存空间，被设计成<strong>环形数据结构</strong>。</p>

<p>master 把需要同步到 slave 的数据，填充到积压缓冲区里。当复制双方增量同步时，master 从缓冲区中取增量数据，同步发送给 slave。</p>

<blockquote>
  <p>master 淘汰过期数据，也需要同步给 slave。查看函数的实现：replicationFeedSlaves()</p>
</blockquote>

<p><img src="/images/2020-06-03-18-14-30.png" alt="数据积压缓冲区" data-action="zoom" /></p>

<ul>
  <li>master 填充积压缓冲区。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">feedReplicationBacklog</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="c1">// 客户端写数据，主服务，当前数据偏移量，实时增加对应的数据量。</span>
    <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

    <span class="c1">// 这是一个环形数据空间，repl_backlog_idx 是当前写数据位置。</span>
    <span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 往缓冲区填充数据，不能超过缓冲区范围。当填满缓冲区后，再缓冲区起始位置开始填充数据。</span>
        <span class="kt">size_t</span> <span class="n">thislen</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span> <span class="o">-</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">thislen</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span> <span class="n">thislen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span><span class="o">+</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">thislen</span><span class="p">);</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">)</span>
            <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="n">thislen</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>
        <span class="c1">// 缓冲区实际填充数据长度。</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 缓冲区实际填充数据长度，不能超过缓冲区大小。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">)</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">;</span>

    <span class="c1">// 数据缓冲区起始位置内存数据，在 redis 整个内存的数据偏移量。</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span> <span class="o">-</span>
                              <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>master 从积压缓冲区发送增量数据给 slave。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 根据 slave 的数据偏移量，master 回复数据增量。</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">addReplyReplicationBacklog</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

    <span class="c1">// 如果数据缓冲区还没有数据，不需要回复。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_DEBUG</span><span class="p">,</span> <span class="s">"[PSYNC] Backlog history len is zero"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 计算 slave 的偏移量在缓冲区的哪个位置上。</span>
    <span class="n">skip</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span><span class="p">;</span>

    <span class="c1">// j 是缓冲区 buffer 数据起始偏移位置，因为是环装结构，所以需要取模 repl_backlog_size。</span>
    <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">+</span>
        <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="o">-</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span><span class="p">))</span> <span class="o">%</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">;</span>

    <span class="c1">// 数据增量在缓冲区起始偏移位置。</span>
    <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">skip</span><span class="p">)</span> <span class="o">%</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">;</span>

    <span class="c1">// 增量数据长度。</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">-</span> <span class="n">skip</span><span class="p">;</span>

    <span class="c1">// 发送缓冲区增量数据。</span>
    <span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">thislen</span> <span class="o">=</span>
            <span class="p">((</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span>
            <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>

        <span class="n">addReplySds</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">sdsnewlen</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">thislen</span><span class="p">));</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="n">thislen</span><span class="p">;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">-</span> <span class="n">skip</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="5-数据结构">5. 数据结构</h2>

<h3 id="51-redisserver">5.1. redisServer</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define CONFIG_RUN_ID_SIZE 40
</span>
<span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">slaves</span><span class="p">,</span> <span class="o">*</span><span class="n">monitors</span><span class="p">;</span>    <span class="cm">/* List of slaves and MONITORs */</span>
    <span class="p">...</span>
    <span class="cm">/* Replication (master) */</span>
    <span class="kt">char</span> <span class="n">replid</span><span class="p">[</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  <span class="cm">/* My current replication ID. */</span>
    <span class="kt">char</span> <span class="n">replid2</span><span class="p">[</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* replid inherited from master*/</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">master_repl_offset</span><span class="p">;</span>   <span class="cm">/* My current replication offset */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">master_repl_meaningful_offset</span><span class="p">;</span> <span class="cm">/* Offset minus latest PINGs. */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">second_replid_offset</span><span class="p">;</span> <span class="cm">/* Accept offsets up to this for replid2. */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">repl_backlog</span><span class="p">;</span>             <span class="cm">/* Replication backlog for partial syncs */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_backlog_size</span><span class="p">;</span>    <span class="cm">/* Backlog circular buffer size */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_backlog_histlen</span><span class="p">;</span> <span class="cm">/* Backlog actual data length */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_backlog_idx</span><span class="p">;</span>     <span class="cm">/* Backlog circular buffer current offset,
                                       that is the next byte will'll write to.*/</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_backlog_off</span><span class="p">;</span>     <span class="cm">/* Replication "master offset" of first
    ...
    /* Replication (slave) */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">masterhost</span><span class="p">;</span>               <span class="cm">/* Hostname of master */</span>
    <span class="kt">int</span> <span class="n">masterport</span><span class="p">;</span>                 <span class="cm">/* Port of master */</span>
    <span class="n">client</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>     <span class="cm">/* Client that is master for this slave */</span>
    <span class="n">client</span> <span class="o">*</span><span class="n">cached_master</span><span class="p">;</span> <span class="cm">/* Cached master to be reused for PSYNC. */</span>
    <span class="kt">int</span> <span class="n">repl_state</span><span class="p">;</span>          <span class="cm">/* Replication status if the instance is a slave */</span>
    <span class="p">...</span>
    <span class="kt">char</span> <span class="n">master_replid</span><span class="p">[</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  <span class="cm">/* Master PSYNC runid. */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">master_initial_offset</span><span class="p">;</span>           <span class="cm">/* Master PSYNC offset. */</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>master</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">结构成员</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">slaves</td>
      <td style="text-align: left">slaves 副本链接列表。</td>
    </tr>
    <tr>
      <td style="text-align: left">replid</td>
      <td style="text-align: left">副本 id，只有 master 有自己独立的 replid，如果服务是 slave，那么它需要同步 master 的 replid，进行填充。</td>
    </tr>
    <tr>
      <td style="text-align: left">replid2</td>
      <td style="text-align: left">master 历史 replid。复制双方断开链接或者故障转移过程中，服务节点角色发生改变，需要缓存旧的 master replid 到 replid2。因为所有 slave 数据到来自 master。复制双方重新建立链接后，通过 <code class="highlighter-rouge">PSYNC &lt;replid&gt; &lt;offset&gt;</code> 命令进行数据复制。</td>
    </tr>
    <tr>
      <td style="text-align: left">master_repl_offset</td>
      <td style="text-align: left">master 数据偏移量。复制双方是异步进行的，所以数据并不是严格的数据一致。</td>
    </tr>
    <tr>
      <td style="text-align: left">second_replid_offset</td>
      <td style="text-align: left">历史数据偏移量。与 replid2 搭配使用。</td>
    </tr>
    <tr>
      <td style="text-align: left">repl_backlog</td>
      <td style="text-align: left">积压缓冲区。被设计成环形数据结构。</td>
    </tr>
    <tr>
      <td style="text-align: left">repl_backlog_size</td>
      <td style="text-align: left">积压缓冲区容量。可以通过配置文件进行配置。</td>
    </tr>
    <tr>
      <td style="text-align: left">repl_backlog_histlen</td>
      <td style="text-align: left">积压缓冲区实际填充了多少数据。</td>
    </tr>
    <tr>
      <td style="text-align: left">repl_backlog_idx</td>
      <td style="text-align: left">积压缓冲区，当前填充数据的位置。</td>
    </tr>
    <tr>
      <td style="text-align: left">repl_backlog_off</td>
      <td style="text-align: left">积压缓冲区数据起始位置。 <br />server.repl_backlog_off = server.master_repl_offset+1</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>slave</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">结构成员</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">masterhost</td>
      <td style="text-align: left">Hostname of master (replicaofCommand | replicationSetMaster)</td>
    </tr>
    <tr>
      <td style="text-align: left">masterport</td>
      <td style="text-align: left">Port of master (replicaofCommand | replicationSetMaster)</td>
    </tr>
    <tr>
      <td style="text-align: left">repl_state</td>
      <td style="text-align: left">副本状态，复制双方建立数据复制要经过很多步骤，而这些步骤被进行到哪个环节被记录在 repl_state。</td>
    </tr>
    <tr>
      <td style="text-align: left">master</td>
      <td style="text-align: left">slave 链接 master 的客户端链接。</td>
    </tr>
    <tr>
      <td style="text-align: left">cached_master</td>
      <td style="text-align: left">slave 与 master 断开链接后，原链接被释放回收。为方便断线重连后数据重复被利用，需要缓存 master 链接数据到 cached_master。</td>
    </tr>
    <tr>
      <td style="text-align: left">master_replid</td>
      <td style="text-align: left">master 的 replid。</td>
    </tr>
    <tr>
      <td style="text-align: left">master_initial_offset</td>
      <td style="text-align: left">slave 通过命令 PSYNC 向 master 全量同步的 数据偏移量。</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="52-client">5.2. client</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">client</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">read_reploff</span><span class="p">;</span> <span class="cm">/* Read replication offset if this is a master. */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">reploff</span><span class="p">;</span>      <span class="cm">/* Applied replication offset if this is a master. */</span>
    <span class="kt">char</span> <span class="n">replid</span><span class="p">[</span><span class="n">CONFIG_RUN_ID_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* Master replication ID (if master). */</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: left">结构成员</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">replid</td>
      <td style="text-align: left">master 副本 id。</td>
    </tr>
    <tr>
      <td style="text-align: left">read_reploff</td>
      <td style="text-align: left">slave 当前向 master 读取的数据偏移量。</td>
    </tr>
    <tr>
      <td style="text-align: left">masterport</td>
      <td style="text-align: left">slave 当前实际处理的数据偏移量。因为异步复制，有些读数据，读出来没有完全处理完，还在缓冲区里。例如 tcp 粘包问题，数据没有接收完整，等原因。</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="6-总结">6. 总结</h2>

<ul>
  <li>数据复制关键理解 PSYNC 命令复制双方的实现逻辑。</li>
  <li>复制双方是异步复制，所以 slave 与 master 数据并非严格一致，slave 有一定延时。</li>
  <li>全量数据复制，涉及到 rdb 文件传输，数据量大时，耗时较长。redis 支持一主多从，并不是 slave 越多越好，如果多个 slave 同时掉线，需要全量复制，如果 redis 数据量很大，肯定会导致系统集群卡顿一段时间。这时候可以考虑 sub-slave。</li>
  <li>redis 采用异步架构，所以需要比较熟悉异步回调处理。与同步比较，逻辑不够直观，复杂的回调逻辑经常会把人绕晕。</li>
</ul>

<hr />

<h2 id="7-参考">7. 参考</h2>

<ul>
  <li><a href="https://redis.io/topics/replication">Replication</a></li>
  <li>《redis 设计与实现》—— 第十五章 - 复制。</li>
  <li><a href="https://www.cnblogs.com/pingyeaa/p/11294773.html">Codis 与 RedisCluster 的原理详解</a></li>
  <li><a href="https://www.cnblogs.com/wdliu/p/9407179.html">redis系列–主从复制以及redis复制演进</a></li>
  <li><a href="https://521-wf.com/archives/414.html">Redis Replication 实现原理</a></li>
</ul>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/2020/05/17/redis-replication/">wenfh2020.com</a></p>
</blockquote>
