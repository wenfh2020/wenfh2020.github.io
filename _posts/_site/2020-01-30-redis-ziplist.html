<p>点赞作者：redis 源码，注释很多而且很详细。看压缩列表源码前，可以先看看 ziplist.c 文件顶部注释，基本可以了解该数据结构设计。压缩列表有点像数据序列化，根据一定的逻辑，去掉数据冗余内存，对数据进行存储，以便节省系统内存使用空间。</p>

<ul id="markdown-toc">
  <li><a href="#1-原理" id="markdown-toc-1-原理">1. 原理</a></li>
  <li><a href="#2-结构" id="markdown-toc-2-结构">2. 结构</a>    <ul>
      <li><a href="#21-列表结构" id="markdown-toc-21-列表结构">2.1. 列表结构</a></li>
      <li><a href="#22-entry" id="markdown-toc-22-entry">2.2. entry</a></li>
      <li><a href="#23-prevlen" id="markdown-toc-23-prevlen">2.3. prevlen</a></li>
      <li><a href="#24-encoding" id="markdown-toc-24-encoding">2.4. encoding</a>        <ul>
          <li><a href="#241-字符串" id="markdown-toc-241-字符串">2.4.1. 字符串</a></li>
          <li><a href="#242-数值" id="markdown-toc-242-数值">2.4.2. 数值</a></li>
          <li><a href="#243-编解码实现" id="markdown-toc-243-编解码实现">2.4.3. 编解码实现</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#3-调试" id="markdown-toc-3-调试">3. 调试</a>    <ul>
      <li><a href="#31-调试中间插入结点" id="markdown-toc-31-调试中间插入结点">3.1. 调试中间插入结点</a></li>
    </ul>
  </li>
  <li><a href="#4-接口" id="markdown-toc-4-接口">4. 接口</a>    <ul>
      <li><a href="#41-插入结点" id="markdown-toc-41-插入结点">4.1. 插入结点</a></li>
    </ul>
  </li>
  <li><a href="#5-问题" id="markdown-toc-5-问题">5. 问题</a></li>
  <li><a href="#6-参考" id="markdown-toc-6-参考">6. 参考</a></li>
</ul>

<hr />
<p>压缩列表<code class="highlighter-rouge">ziplist</code>是一个双向链表，设计主要是为了节省内存。保存字符串，数值两种类型（ It stores both strings and integer values），列表内部实现主要是对一块连续内存进行管理，列表支持列表头尾的插入或弹出结点操作。因为写操作涉及到内存重新分配，所以复杂度需要根据当前使用内存的使用情况而定，一般情况下，不建议存储大量数据。<code class="highlighter-rouge">sorted set</code> 根据数据长度，就分别用 <code class="highlighter-rouge">ziplist</code> 和 <code class="highlighter-rouge">skiplist</code> 两种数据结构进行保存。</p>

<blockquote>
  <p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.</p>
</blockquote>

<hr />

<h2 id="1-原理">1. 原理</h2>

<p>压缩原理：举个例子，<code class="highlighter-rouge">int a = 0</code> a 是一个整型变量，占 4 个字节。但是 a = 0，0 这个数字只需要一个 bit 保存就足够了，如果用 4 个字节（32 bit）内存去保存就有点浪费了。按照这个思路，大致可以理解压缩策略是怎么样的，详细信息看文档和源码吧。</p>
<blockquote>
  <p>压缩数据管理有点像数据序列化，序列化数据平常数据的传输经常用到，可以了解下 <code class="highlighter-rouge">protobuf</code> 源码，看看数据是怎么打包的。压缩列表除了数据序列化外，还需要对数据进行插入删除等操作，需要增加一些额外的结构进行内存管理。</p>
</blockquote>

<hr />

<h2 id="2-结构">2. 结构</h2>

<h3 id="21-列表结构">2.1. 列表结构</h3>

<p><strong>头 + 结点 + 尾</strong>
<code class="highlighter-rouge">&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</code></p>

<p><img src="/images/2020-02-20-16-44-19.png" alt="结构" data-action="zoom" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Size of the "end of ziplist" entry. Just one byte. */</span>
<span class="cp">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
</span>
<span class="cm">/* Size of the "end of ziplist" entry. Just one byte. */</span>
<span class="cp">#define ZIPLIST_END_SIZE        (sizeof(uint8_t))
</span>
<span class="cm">/* Return total bytes a ziplist is composed of. */</span>
<span class="cp">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
</span>
<span class="cm">/* Return the offset of the last item inside the ziplist. */</span>
<span class="cp">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
</span>
<span class="cm">/* Return the length of a ziplist, or UINT16_MAX if the length cannot be
 * determined without scanning the whole ziplist. */</span>
<span class="cp">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
</span>
<span class="cm">/* Special "end of ziplist" entry. */</span>
<span class="cp">#define ZIP_END 255
</span></code></pre></div></div>

<h3 id="22-entry">2.2. entry</h3>

<p>结点结构：<code class="highlighter-rouge">&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code>，但有时候数值很小，用 <code class="highlighter-rouge">&lt;encoding&gt;</code> 也能保存数据，不需要 <code class="highlighter-rouge">&lt;entry-data&gt;</code>， 即 <code class="highlighter-rouge">&lt;prevlen&gt; &lt;encoding&gt;</code>。</p>

<hr />
<p>压缩链表的结点有点特别，这里的链表不是传统的链表，传统的链表每个结点都有 prev 或者 next 的指针，连接起来。压缩链表结点通过 prevlen 在内存上进行定位前一个结点，因为 <a href="#encoding"><code class="highlighter-rouge">&lt;encoding&gt;</code></a> 存储了当前结点数据类型和数据长度，从而可以向后定位下一个结点。</p>

<h3 id="23-prevlen">2.3. prevlen</h3>

<table>
  <thead>
    <tr>
      <th>条件</th>
      <th>长度</th>
      <th>格式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&lt; 254 字节</td>
      <td>1 字节</td>
      <td><code class="highlighter-rouge">&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry-dagta&gt;</code></td>
    </tr>
    <tr>
      <td>&gt;= 254 字节</td>
      <td>5 字节</td>
      <td><code class="highlighter-rouge">0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></td>
    </tr>
  </tbody>
</table>

<p>前一个结点长度，存储在本结点首部，有两种存储长度，1 字节或者 5 字节空间进行存储，具体产看前面的具体描述。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return the number of bytes used to encode the length of the previous
 * entry. The length is returned by setting the var 'prevlensize'. */</span>
<span class="cp">#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
    if ((ptr)[0] &lt; ZIP_BIG_PREVLEN) {                                          \
        (prevlensize) = 1;                                                     \
    } else {                                                                   \
        (prevlensize) = 5;                                                     \
    }                                                                          \
} while(0);
</span></code></pre></div></div>

<p>prevlen: 前一个结点结点长度。
prevlensize: 保存 prevlen 占用了多少内存（1/5）</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return the length of the previous element, and the number of bytes that
 * are used in order to encode the previous element length.
 * 'ptr' must point to the prevlen prefix of an entry (that encodes the
 * length of the previous entry in order to navigate the elements backward).
 * The length of the previous entry is stored in 'prevlen', the number of
 * bytes needed to encode the previous entry length are stored in
 * 'prevlensize'. */</span>
<span class="cp">#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
    if ((prevlensize) == 1) {                                                  \
        (prevlen) = (ptr)[0];                                                  \
    } else if ((prevlensize) == 5) {                                           \
        assert(sizeof((prevlen)) == 4);                                    \
        memcpy(&amp;(prevlen), ((char*)(ptr)) + 1, 4);                             \
        memrev32ifbe(&amp;prevlen);                                                \
    }                                                                          \
} while(0);
</span></code></pre></div></div>

<h3 id="24-encoding">2.4. encoding</h3>

<p>编码有两种类型：字符串/整数</p>
<blockquote>
  <p>The encoding field of the entry depends on the content of the entry. When the entry is a string, the first 2 bits of the encoding first byte will hold the type of encoding used to store the length of the string, followed by the actual length of the string. When the entry is an integer the first 2 bits are both set to 1. The following 2 bits are used to specify what kind of integer will be stored after this header. An overview of the different types and encodings is as follows. The first byte is always enough to determine the kind of entry.</p>

</blockquote>

<h4 id="241-字符串">2.4.1. 字符串</h4>

<p>如果当结点内容是字符串，那么 <code class="highlighter-rouge">&lt;encoding&gt;</code> 前两个 bit 主要用来存储编码类型，剩下的保存当前字符串的字符串长度。从 <code class="highlighter-rouge">&lt;encoding&gt;</code> 可以获得 3 个信息：</p>

<ol>
  <li>编码类型。</li>
  <li>结点数据内容长度。</li>
  <li>整个 <code class="highlighter-rouge">&lt;encoding&gt;</code> 长度。</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: left">标识</th>
      <th style="text-align: left">encoding 长度</th>
      <th>字符串长度</th>
      <th style="text-align: left">描述</th>
      <th style="text-align: left">注意</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">|00pppppp|</td>
      <td style="text-align: left">1 byte</td>
      <td>&lt;= 63 字节(6 bits)</td>
      <td style="text-align: left">encoding 用一个字节保存，前 2 个 bit是 0，后面 6 个 bit 保存字符串长度</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">|01pppppp|qqqqqqqq|</td>
      <td style="text-align: left">2 bytes</td>
      <td>&lt;= 16383 字节(14 bits)</td>
      <td style="text-align: left">encoding 前 2 个 bit是 0，紧接着后面 6 个 bit 保存字符串长度。</td>
      <td style="text-align: left">14 bit 数值用大端方式保存</td>
    </tr>
    <tr>
      <td style="text-align: left">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td>
      <td style="text-align: left">5 bytes</td>
      <td>&gt;= 16384 字节</td>
      <td style="text-align: left">encoding 前面一个字节是标识，后面 4 个字节保存字符串长度。</td>
      <td style="text-align: left">长度数值用大端模式保存</td>
    </tr>
  </tbody>
</table>

<p>判断字节前面两个 bit 是否为 1，如果不是就是字符串。ZIP_STR_MASK = “1100 0000”</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Extract the encoding from the byte pointed by 'ptr' and set it into
 * 'encoding' field of the zlentry structure. */</span>
<span class="cp">#define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
    (encoding) = (ptr[0]); \
    if ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \
} while(0)
</span></code></pre></div></div>

<h4 id="242-数值">2.4.2. 数值</h4>

<p>当结点内容是数值，<code class="highlighter-rouge">&lt;encoding&gt;</code> 前两个 bit 设置成 <code class="highlighter-rouge">1</code>，接下来两个 bit 用来保存数值类型。从 <code class="highlighter-rouge">&lt;encoding&gt;</code> 可以获得 3 个信息：</p>

<ol>
  <li>编码类型。</li>
  <li>数值类型。</li>
  <li>数值。</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: left">首字节标识</th>
      <th style="text-align: left">encoding 长度</th>
      <th style="text-align: left">数值长度</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">|11000000|</td>
      <td style="text-align: left">3 bytes</td>
      <td style="text-align: left">2 bytes</td>
      <td style="text-align: left">int16_t</td>
    </tr>
    <tr>
      <td style="text-align: left">|11010000|</td>
      <td style="text-align: left">5 bytes</td>
      <td style="text-align: left">4 bytes</td>
      <td style="text-align: left">int32_t</td>
    </tr>
    <tr>
      <td style="text-align: left">|11100000|</td>
      <td style="text-align: left">9 bytes</td>
      <td style="text-align: left">8 bytes</td>
      <td style="text-align: left">int64_t</td>
    </tr>
    <tr>
      <td style="text-align: left">|11110000|</td>
      <td style="text-align: left">4 bytes</td>
      <td style="text-align: left">3 bytes</td>
      <td style="text-align: left">Integer encoded as 24 bit signed (3 bytes).</td>
    </tr>
    <tr>
      <td style="text-align: left">|11111110|</td>
      <td style="text-align: left">2 bytes</td>
      <td style="text-align: left">1 byte</td>
      <td style="text-align: left">Integer encoded as 8 bit signed (1 byte).</td>
    </tr>
    <tr>
      <td style="text-align: left">|1111xxxx|</td>
      <td style="text-align: left">1 byte</td>
      <td style="text-align: left">4 bits</td>
      <td style="text-align: left">4 bit integer, 可以存储 0 - 12， 因为 0000，1110，1111 不能使用，只能存储 1 - 13，所以保存进来的数字进行 + 1 操作，解析后需要 -1</td>
    </tr>
    <tr>
      <td style="text-align: left">|11111111|</td>
      <td style="text-align: left">1 byte</td>
      <td style="text-align: left">0 bit</td>
      <td style="text-align: left">列表结束符</td>
    </tr>
  </tbody>
</table>

<h4 id="243-编解码实现">2.4.3. 编解码实现</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#define ZIP_STR_MASK 0xc0
#define ZIP_INT_MASK 0x30
#define ZIP_STR_06B (0 &lt;&lt; 6)
#define ZIP_STR_14B (1 &lt;&lt; 6)
#define ZIP_STR_32B (2 &lt;&lt; 6)
#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4)
#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4)
#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4)
#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4)
#define ZIP_INT_8B 0xfe
</span>
<span class="cm">/* Macro to determine if the entry is a string. String entries never start
 * with "11" as most significant bits of the first byte. */</span>
<span class="cp">#define ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)
</span>
<span class="cm">/* Write the encoidng header of the entry in 'p'. If p is NULL it just returns
 * the amount of bytes required to encode such a length. Arguments:
 *
 * 'encoding' is the encoding we are using for the entry. It could be
 * ZIP_INT_* or ZIP_STR_* or between ZIP_INT_IMM_MIN and ZIP_INT_IMM_MAX
 * for single-byte small immediate integers.
 *
 * 'rawlen' is only used for ZIP_STR_* encodings and is the length of the
 * srting that this entry represents.
 *
 * The function returns the number of bytes used by the encoding/length
 * header stored in 'p'. */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">zipStoreEntryEncoding</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rawlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ZIP_IS_STR</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* Although encoding is given it may not be set for strings,
         * so we determine it here using the raw length. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&lt;=</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZIP_STR_06B</span> <span class="o">|</span> <span class="n">rawlen</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&lt;=</span> <span class="mh">0x3fff</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZIP_STR_14B</span> <span class="o">|</span> <span class="p">((</span><span class="n">rawlen</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">);</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rawlen</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZIP_STR_32B</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">rawlen</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Implies integer encoding, so length is always 1. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Store this length at p. */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 'encoding' field of the zlentry structure. */</span>
<span class="cp">#define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
    (encoding) = (ptr[0]); \
    // 如果是字符串类型，取前面两个 bit，其它 bit 是 0 \
    if ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \
} while(0)
</span>
<span class="cp">#define ZIP_INT_IMM_MIN 0xf1    </span><span class="cm">/* 11110001 */</span><span class="cp">
#define ZIP_INT_IMM_MAX 0xfd    </span><span class="cm">/* 11111101 */</span><span class="cp">
</span>
<span class="cm">/* Return bytes needed to store integer encoded by 'encoding'. */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">zipIntSize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ZIP_INT_8B</span><span class="p">:</span>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ZIP_INT_16B</span><span class="p">:</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ZIP_INT_24B</span><span class="p">:</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ZIP_INT_32B</span><span class="p">:</span> <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ZIP_INT_64B</span><span class="p">:</span> <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">&gt;=</span> <span class="n">ZIP_INT_IMM_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">encoding</span> <span class="o">&lt;=</span> <span class="n">ZIP_INT_IMM_MAX</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* 4 bit immediate */</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"Invalid integer encoding 0x%02X"</span><span class="p">,</span> <span class="n">encoding</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Store integer 'value' at 'p', encoded as 'encoding' */</span>
<span class="kt">void</span> <span class="nf">zipSaveInteger</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int16_t</span> <span class="n">i16</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">i32</span><span class="p">;</span>
    <span class="kt">int64_t</span> <span class="n">i64</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_8B</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">((</span><span class="kt">int8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_16B</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i16</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i16</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i16</span><span class="p">));</span>
        <span class="n">memrev16ifbe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_24B</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i32</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">memrev32ifbe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i32</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_32B</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i32</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i32</span><span class="p">));</span>
        <span class="n">memrev32ifbe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_64B</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i64</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i64</span><span class="p">));</span>
        <span class="n">memrev64ifbe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">&gt;=</span> <span class="n">ZIP_INT_IMM_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">encoding</span> <span class="o">&lt;=</span> <span class="n">ZIP_INT_IMM_MAX</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Nothing to do, the value is stored in the encoding itself. */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Decode the entry encoding type and data length (string length for strings,
 * number of bytes used for the integer for integer entries) encoded in 'ptr'.
 * The 'encoding' variable will hold the entry encoding, the 'lensize'
 * variable will hold the number of bytes required to encode the entry
 * length, and the 'len' variable will hold the entry length. */</span>
<span class="cp">#define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
    if ((encoding) &lt; ZIP_STR_MASK) {                                           \
        if ((encoding) == ZIP_STR_06B) {                                       \
            (lensize) = 1;                                                     \
            (len) = (ptr)[0] &amp; 0x3f;                                           \
        } else if ((encoding) == ZIP_STR_14B) {                                \
            (lensize) = 2;                                                     \
            (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \
        } else if ((encoding) == ZIP_STR_32B) {                                \
            (lensize) = 5;                                                     \
            (len) = ((ptr)[1] &lt;&lt; 24) |                                         \
                    ((ptr)[2] &lt;&lt; 16) |                                         \
                    ((ptr)[3] &lt;&lt;  8) |                                         \
                    ((ptr)[4]);                                                \
        } else {                                                               \
            panic("Invalid string encoding 0x%02X", (encoding));               \
        }                                                                      \
    } else {                                                                   \
        (lensize) = 1;                                                         \
        (len) = zipIntSize(encoding);                                          \
    }                                                                          \
} while(0);
</span></code></pre></div></div>

<hr />

<h2 id="3-调试">3. 调试</h2>

<p>我们可以先通过调试去走一次程序逻辑，观察该数据结构的内存管理，了解下 <code class="highlighter-rouge">ziplistNew</code>， <code class="highlighter-rouge">ziplistPush</code> 等接口的工作流程。</p>
<blockquote>
  <p>调试为了编译通过，适当增减部分代码。</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-g</span> ziplist.c sds.c zmalloc.c util.c sha1.c <span class="nt">-o</span> ziplist  <span class="nt">-I</span>../deps/lua/src
<span class="nb">sudo </span>gdb ziplist
</code></pre></div></div>

<p><img src="/images/2020-02-20-16-45-03.png" alt="调试" data-action="zoom" /></p>

<hr />

<h3 id="31-调试中间插入结点">3.1. 调试中间插入结点</h3>

<p>详细可以查看 ziplistInsert 接口源码</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">createTestlist</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistNew</span><span class="p">();</span>
    <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistPush</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="s">"2"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ZIPLIST_TAIL</span><span class="p">);</span>
    <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistPush</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="s">"5"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ZIPLIST_TAIL</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">test</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="p">));</span>

    <span class="c1">// 插入中间</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ziplistIndex</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">ziplistNext</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistInsert</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">zl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span> <span class="o">=</span> <span class="n">createTestlist</span><span class="p">();</span>
    <span class="n">ziplistRepr</span><span class="p">(</span><span class="n">zl</span><span class="p">);</span>
    <span class="n">zfree</span><span class="p">(</span><span class="n">zl</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>结果</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>total bytes 1046<span class="o">}</span> <span class="o">{</span>num entries 3<span class="o">}</span>
<span class="o">{</span><span class="nb">tail </span>offset 1039<span class="o">}</span>
<span class="o">{</span>
        addr 0x7fb31680060a,
        index  0,
        offset    10,
        hdr+entry len:     2,
        hdr len 2,
        prevrawlen:     0,
        prevrawlensize:  1,
        payload     0
        bytes: 00|f3|
        <span class="o">[</span>int]2
<span class="o">}</span>
<span class="o">{</span>
        addr 0x7fb31680060c,
        index  1,
        offset    12,
        hdr+entry len:  1027,
        hdr len 3,
        prevrawlen:     2,
        prevrawlensize:  1,
        payload  1024
        bytes: 02|44|00|61|61|...|61|
        <span class="o">[</span>str]aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
<span class="o">}</span>
<span class="o">{</span>
        addr 0x7fb316800a0f,
        index  2,
        offset  1039,
        hdr+entry len:     6,
        hdr len 6,
        prevrawlen:  1027,
        prevrawlensize:  5,
        payload     0
        bytes: fe|03|04|00|00|f6|
        <span class="o">[</span>int]5
<span class="o">}</span>
<span class="o">{</span>end<span class="o">}</span>
</code></pre></div></div>

<p>主要画了部分令人费解的地方。</p>

<p><img src="/images/2020-02-20-16-45-26.png" alt="插入流程" data-action="zoom" /></p>

<hr />

<h2 id="4-接口">4. 接口</h2>

<p>可以通过 <code class="highlighter-rouge">sorted set</code> （t_zset.c）源码理解 <code class="highlighter-rouge">ziplist</code> 的使用。</p>

<h3 id="41-插入结点">4.1. 插入结点</h3>

<p>根据 p 指定的位置，插入数据。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Insert item at "p". */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__ziplistInsert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slen</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 获取当前整个内存长度</span>
    <span class="kt">size_t</span> <span class="n">curlen</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_BYTES</span><span class="p">(</span><span class="n">zl</span><span class="p">)),</span> <span class="n">reqlen</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prevlensize</span><span class="p">,</span> <span class="n">prevlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nextdiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">123456789</span><span class="p">;</span> <span class="cm">/* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. */</span>
    <span class="n">zlentry</span> <span class="n">tail</span><span class="p">;</span>

    <span class="c1">// 如果不是结束结点，那么就从当前结点获取前一个结点的长度。如果是结束结点，就取末结点长度（末结点不是结束结点）。</span>
    <span class="cm">/* Find out prevlen for the entry that is inserted. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ZIP_DECODE_PREVLEN</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prevlensize</span><span class="p">,</span> <span class="n">prevlen</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 末结点</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptail</span> <span class="o">=</span> <span class="n">ZIPLIST_ENTRY_TAIL</span><span class="p">(</span><span class="n">zl</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">prevlen</span> <span class="o">=</span> <span class="n">zipRawEntryLength</span><span class="p">(</span><span class="n">ptail</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 获取内容长度，字符串会先尝试转化为整型。</span>
    <span class="cm">/* See if the entry can be encoded */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">zipTryEncoding</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">slen</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="o">&amp;</span><span class="n">encoding</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 'encoding' is set to the appropriate integer encoding */</span>
        <span class="n">reqlen</span> <span class="o">=</span> <span class="n">zipIntSize</span><span class="p">(</span><span class="n">encoding</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 'encoding' is untouched, however zipStoreEntryEncoding will use the
         * string length to figure out how to encode it. */</span>
        <span class="n">reqlen</span> <span class="o">=</span> <span class="n">slen</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* We need space for both the length of the previous entry and
     * the length of the payload. */</span>
    <span class="n">reqlen</span> <span class="o">+=</span> <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">prevlen</span><span class="p">);</span>
    <span class="n">reqlen</span> <span class="o">+=</span> <span class="n">zipStoreEntryEncoding</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">encoding</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>

    <span class="c1">// 插入位置的后一个结点的&lt;prevlen&gt;发生改变， nextdiff 计算 &lt;prevlen&gt; 的 lensize 相差多少。</span>
    <span class="cm">/* When the insert position is not equal to the tail, we need to
     * make sure that the next entry can hold this entry's length in
     * its prevlen field. */</span>
    <span class="kt">int</span> <span class="n">forcelarge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">nextdiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="o">?</span> <span class="n">zipPrevLenByteDiff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">reqlen</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 减少插入位置后续结点的 &lt;prevlen&gt; lensize 连锁反应频繁调用 ziplistResize 损耗性能。强制 forcelarge 写入。</span>
    <span class="c1">// 该问题，详见：https://segmentfault.com/a/1190000018878466?utm_source=tag-newest</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextdiff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">reqlen</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nextdiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">forcelarge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Store offset because a realloc may change the address of zl. */</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">;</span>
    <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistResize</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="n">curlen</span><span class="o">+</span><span class="n">reqlen</span><span class="o">+</span><span class="n">nextdiff</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">zl</span><span class="o">+</span><span class="n">offset</span><span class="p">;</span>

    <span class="cm">/* Apply memory move when necessary and update tail offset. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Subtract one because of the ZIP_END bytes */</span>
        <span class="n">memmove</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span><span class="n">p</span><span class="o">-</span><span class="n">nextdiff</span><span class="p">,</span><span class="n">curlen</span><span class="o">-</span><span class="n">offset</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">nextdiff</span><span class="p">);</span>

        <span class="cm">/* Encode this entry's raw length in the next entry. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">forcelarge</span><span class="p">)</span>
            <span class="n">zipStorePrevEntryLengthLarge</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span><span class="n">reqlen</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span><span class="n">reqlen</span><span class="p">);</span>

        <span class="cm">/* Update offset for tail */</span>
        <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span>
            <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">))</span><span class="o">+</span><span class="n">reqlen</span><span class="p">);</span>

        <span class="cm">/* When the tail contains more than one entry, we need to take
         * "nextdiff" in account as well. Otherwise, a change in the
         * size of prevlen doesn't have an effect on the *tail* offset. */</span>
        <span class="n">zipEntry</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">reqlen</span><span class="o">+</span><span class="n">tail</span><span class="p">.</span><span class="n">headersize</span><span class="o">+</span><span class="n">tail</span><span class="p">.</span><span class="n">len</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span>
                <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">))</span><span class="o">+</span><span class="n">nextdiff</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* This element will be the new tail. */</span>
        <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// &lt;entr&gt; 保存了 &lt;prevlen&gt;，前结点改变了，导致长度也改变了，后面的结点连锁反映，也需要修改 &lt;prevlen&gt;</span>
    <span class="cm">/* When nextdiff != 0, the raw length of the next entry has changed, so
     * we need to cascade the update throughout the ziplist */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextdiff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">;</span>
        <span class="n">zl</span> <span class="o">=</span> <span class="n">__ziplistCascadeUpdate</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">zl</span><span class="o">+</span><span class="n">offset</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Write the entry */</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">prevlen</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="n">zipStoreEntryEncoding</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">encoding</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ZIP_IS_STR</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">zipSaveInteger</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">encoding</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ZIPLIST_INCR_LENGTH</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">zl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="5-问题">5. 问题</h2>

<ul>
  <li>
    <p>分配内存
<code class="highlighter-rouge">ziplist</code> 插入删除数据需要重新分配内存。</p>
  </li>
  <li>
    <p>耦合问题
<code class="highlighter-rouge">ziplist</code> 为了在连续内存上进行数据管理，对数据进行压缩，节省内存开销，也减少内存碎片。但是 prevlen 作为数据结点对组成部分，跟其它结点严重耦合，只要在链表中间插入或者删除结点，有可能需要遍历更新插入或删除位置后续的所有结点 <code class="highlighter-rouge">&lt;prevlen&gt;</code>。</p>
  </li>
  <li>
    <p>效率问题
列表重点是压缩，是一个列表，插入删除数据，效率不高，需要重新分配内存。因为是列表，查找结点复杂度$O(n)$。在 <code class="highlighter-rouge">sorted set</code> 的实现中，对 <code class="highlighter-rouge">skiplist</code> 的使用是有限制的。</p>
  </li>
</ul>

<p>redis.conf</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zset-max-ziplist-entries 128
zset-max-ziplist-value 64
</code></pre></div></div>

<p>t_zset.c</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">zaddGenericCommand</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">zobj</span> <span class="o">=</span> <span class="n">lookupKeyWrite</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">zobj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="k">goto</span> <span class="n">reply_to_client</span><span class="p">;</span> <span class="cm">/* No key + XX option: nothing to do. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">zset_max_ziplist_entries</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
            <span class="n">server</span><span class="p">.</span><span class="n">zset_max_ziplist_value</span> <span class="o">&lt;</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">scoreidx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">zobj</span> <span class="o">=</span> <span class="n">createZsetObject</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">zobj</span> <span class="o">=</span> <span class="n">createZsetZiplistObject</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">dbAdd</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">zobj</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">zobj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">OBJ_ZSET</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">wrongtypeerr</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zsetAdd</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">zobj</span><span class="p">,</span> <span class="kt">double</span> <span class="n">score</span><span class="p">,</span> <span class="n">sds</span> <span class="n">ele</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">newscore</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">zobj</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">zzlInsert</span><span class="p">(</span><span class="n">zobj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">ele</span><span class="p">,</span><span class="n">score</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">zzlLength</span><span class="p">(</span><span class="n">zobj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">zset_max_ziplist_entries</span> <span class="o">||</span>
        <span class="n">sdslen</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">zset_max_ziplist_value</span><span class="p">)</span>
        <span class="n">zsetConvert</span><span class="p">(</span><span class="n">zobj</span><span class="p">,</span><span class="n">OBJ_ENCODING_SKIPLIST</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>复杂度
指针的偏移考验的是技术功底。<code class="highlighter-rouge">ziplist</code> 实现算是比较复杂了（对我而言）。如果用传统的双向链表实现要简单不少的，压缩目的还是能达到的，结点间的耦合比较小。</li>
</ul>

<hr />

<h2 id="6-参考">6. 参考</h2>

<ul>
  <li>
    <p><a href="https://blog.csdn.net/yasi_xi/article/details/9263955">gdb中看内存(x命令)</a></p>
  </li>
  <li>
    <p><a href="https://segmentfault.com/a/1190000018878466?utm_source=tag-newest">Redis的一个历史bug及其后续改进</a></p>
  </li>
  <li>
    <p><a href="https://github.com/wenfh2020/redis/commit/c495d095ae495ea5253443ee4562aaa30681a854?diff=unified">Ziplist: insertion bug under particular conditions fixed.</a></p>
  </li>
</ul>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/">wenfh2020.com</a></p>
</blockquote>
