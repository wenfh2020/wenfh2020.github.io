<p>本章重点走读 redis 网络 I/O 的<strong>多线程</strong>部分源码。</p>

<p>哈希表 + 内存数据库 + 非阻塞系统调用 + 多路复用 I/O 事件驱动，使得 redis 单线程处理主逻辑足够高效。当并发上来后，数据的逻辑处理肯定要占用大量时间，那样，客户端与服务端通信处理就会变得迟钝。所以在合适的时候（根据任务量自适应）采用多线程处理，充分地利用多核优势，分担主线程压力，使得客户端和服务端通信更加敏捷。</p>

<hr />

<p>redis 6.0 新增多线程处理网络 I/O，默认是关闭的，需要修改配置开启。对于这个新特性，redis 作者建议：如果项目确实遇到性能问题，再开启多线程处理网络读写事件。否则开启没什么意义，还会浪费 CPU 资源。线程数量不要超过 cpu 核心数量 - 1，预留一个核心。</p>

<ul id="markdown-toc">
  <li><a href="#1-配置" id="markdown-toc-1-配置">1. 配置</a></li>
  <li><a href="#2-主线程工作流程" id="markdown-toc-2-主线程工作流程">2. 主线程工作流程</a></li>
  <li><a href="#3-多线程协作" id="markdown-toc-3-多线程协作">3. 多线程协作</a>    <ul>
      <li><a href="#31-特点" id="markdown-toc-31-特点">3.1. 特点</a></li>
      <li><a href="#32-忙等" id="markdown-toc-32-忙等">3.2. 忙等</a>        <ul>
          <li><a href="#321-源码实现" id="markdown-toc-321-源码实现">3.2.1. 源码实现</a></li>
          <li><a href="#322-优缺点" id="markdown-toc-322-优缺点">3.2.2. 优缺点</a></li>
        </ul>
      </li>
      <li><a href="#33-源码分析" id="markdown-toc-33-源码分析">3.3. 源码分析</a>        <ul>
          <li><a href="#331-概述" id="markdown-toc-331-概述">3.3.1. 概述</a></li>
          <li><a href="#332-源码" id="markdown-toc-332-源码">3.3.2. 源码</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#4-数据结构" id="markdown-toc-4-数据结构">4. 数据结构</a></li>
  <li><a href="#5-测试" id="markdown-toc-5-测试">5. 测试</a></li>
  <li><a href="#6-总结" id="markdown-toc-6-总结">6. 总结</a></li>
  <li><a href="#7-参考" id="markdown-toc-7-参考">7. 参考</a></li>
</ul>

<hr />

<h2 id="1-配置">1. 配置</h2>

<p>多线程这两个设置项，默认是关闭的。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis.conf</span>

<span class="c"># 配置多线程处理线程个数，数量最好少于 cpu 核心，默认 4。</span>
<span class="c"># io-threads 4</span>
<span class="c">#</span>
<span class="c"># 多线程是否处理读事件，默认关闭。</span>
<span class="c"># io-threads-do-reads no</span>
</code></pre></div></div>

<p>redis 作者建议：</p>

<ul>
  <li>配置线程数量，最好少于 cpu 核心。起码预留一个空闲核心处理系统其它业务，线程数量超过 cpu 核心对 redis 性能有一定影响，因为 redis 主线程处理主逻辑，如果被系统频繁切换，效率会降低。</li>
  <li>提供了多线程处理网络读事件开关。多线程处理网络读事件，对 redis 性能影响不大。redis 作为缓存，查询操作的频率比较大，系统的网络瓶颈一般在查询返回数据，根据系统实际应用场景进行配置吧。</li>
</ul>

<hr />

<h2 id="2-主线程工作流程">2. 主线程工作流程</h2>

<p><img src="/images/2020-05-03-12-47-36.png" alt="redis 多线程I/O通信流程" data-action="zoom" /></p>

<ol>
  <li>主线程通过事件驱动从内核获取就绪事件，记录下需要延时操作的客户端连接。</li>
  <li>多线程并行处理延时读事件。</li>
  <li>多线程处理延时写事件。</li>
  <li>重新执行第一步，循环执行。</li>
</ol>

<hr />

<ul>
  <li>加载循环事件管理。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">server</span><span class="p">.</span><span class="n">el</span> <span class="o">=</span> <span class="n">aeCreateEventLoop</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxclients</span><span class="o">+</span><span class="n">CONFIG_FDSET_INCR</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="n">aeSetBeforeSleepProc</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">beforeSleep</span><span class="p">);</span>
    <span class="n">aeSetAfterSleepProc</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">afterSleep</span><span class="p">);</span>
    <span class="n">aeMain</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">);</span>
    <span class="n">aeDeleteEventLoop</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>事件循环管理。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">aeMain</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
        <span class="c1">// 向内核获取就绪的可读可写事件事件进行处理，处理时钟事件。</span>
        <span class="n">aeProcessEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">AE_ALL_EVENTS</span><span class="o">|</span><span class="n">AE_CALL_AFTER_SLEEP</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>获取就绪事件处理和处理时钟事件。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">aeProcessEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// 从内核中取出就绪的可读可写事件。</span>
    <span class="n">numevents</span> <span class="o">=</span> <span class="n">aeApiPoll</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">tvp</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">aftersleep</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_CALL_AFTER_SLEEP</span><span class="p">)</span>
        <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">aftersleep</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 处理读写事件。</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="c1">// 处理时钟事件。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span>
        <span class="n">processed</span> <span class="o">+=</span> <span class="n">processTimeEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>读写逻辑处理。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">beforeSleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// write</span>
    <span class="n">handleClientsWithPendingWritesUsingThreads</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">afterSleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// read</span>
    <span class="n">handleClientsWithPendingReadsUsingThreads</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-多线程协作">3. 多线程协作</h2>

<p><img src="/images/2020-05-03-12-47-36.png" alt="redis 多线程I/O通信流程" data-action="zoom" /></p>

<h3 id="31-特点">3.1. 特点</h3>

<p>主线程实现主逻辑，子线程辅助实现任务。</p>

<ul>
  <li>redis 主线程实现主逻辑。</li>
  <li>主线程与子线程共同处理延时客户端网络读写事件。</li>
  <li>主线程根据写事件用户量大小，开启/关闭多线程模式。</li>
  <li>虽然多线程是并行处理逻辑，但是 redis 整体工作流程是串行的。</li>
  <li>当主线程处理延时读写事件时，把一次大任务进行取模切割成小任务，平均分配给（主+子）线程处理。这样每个客户端连接被独立的一个线程处理，不会出现多个线程同时处理一个客户端连接逻辑。</li>
  <li>主线程限制多线程子线程同一个时间段只能并行处理一种类型操作：读/写。</li>
  <li>主线程先等待子线程处理完任务了，再进行下一步，处理分配给自己的等待事件。</li>
  <li>主线程在等待子线程处理任务过程中，它不是通过 <code class="highlighter-rouge">sleep</code> 挂起线程让出使用权，而是通过 <code class="highlighter-rouge">for</code> 循环进行忙等，不断检测所有子线程处理的任务是否已经完成，如果完成再进行下一步，处理自己的任务。相当于主线程在等待过程中，并没有做其它任务，只是让帮手去干活，帮手都把活干完了，它再干自己的，然后做一些善后工作。主线程在这里的角色有点像代理商或者包工头。</li>
  <li>子线程在完成分配的任务后，也会通过 <code class="highlighter-rouge">for</code> 循环忙等，检测主线程的工作调度，如果任务很少了，等待主线程通过锁，把自己挂起。</li>
</ul>

<hr />

<h3 id="32-忙等">3.2. 忙等</h3>

<p>多线程模式，存在忙等现象，这个处理有点超出了常规思维。</p>

<hr />

<h4 id="321-源码实现">3.2.1. 源码实现</h4>

<ul>
  <li>主线程分配完任务后，等待所有子线程完成任务后，再进行下一步操作。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// write</span>
<span class="kt">int</span> <span class="nf">handleClientsWithPendingWritesUsingThreads</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">pending</span> <span class="o">+=</span> <span class="n">io_threads_pending</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// read</span>
<span class="kt">int</span> <span class="nf">handleClientsWithPendingReadsUsingThreads</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">pending</span> <span class="o">+=</span> <span class="n">io_threads_pending</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>子线程完成任务后，保持繁忙状态，等待主线程上锁挂起自己。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">IOThreadMain</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">myid</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_pending</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_pending</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_threads_mutex</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_threads_mutex</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h4 id="322-优缺点">3.2.2. 优缺点</h4>

<ul>
  <li>
    <p>优点：</p>

    <ol>
      <li>实现简单，主线程可以通过锁开启/暂停多线程工作模式，不需要复杂的通信。</li>
      <li>redis 读写事件处理基本都是内存级别操作，而且非阻塞，多线程处理任务非常快。</li>
      <li>反应快，有任务能实时处理。</li>
      <li>宏观上看，主线程是串行处理逻辑，逻辑清晰：读写逻辑顺序处理。主线程把一次大任务进行取模切割成小任务，分配给子线程处理。主线程等子线程完成所有任务后，再完成自己的任务，再进行下一步。</li>
      <li>因为多线程处理的是客户端链接的延时读写逻辑，redis 服务应用场景作为缓存，接入对象一般是服务端级别，而不是面向普通用户的客户端，所以链接不会太多。而等待的读写链接通过取模分散到不同的线程去处理，那每个线程处理的链接就会相对较少。每个线程处理任务也很快。</li>
    </ol>
  </li>
  <li>
    <p>缺点：</p>

    <p>忙等最大的问题是以浪费一定 cpu 性能为代价，如果 redis 链接并发量不是很高，redis 作者不建议开启多线程模式，所以主逻辑会根据写事件链接数量大小来开启/暂停多线程工作模式。</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">stopThreadedIOIfNeeded</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pending</span> <span class="o">=</span> <span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_write</span><span class="p">);</span>

    <span class="c1">// 如果单线程模式就直接返回。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_active</span><span class="p">)</span> <span class="n">stopThreadedIO</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="33-源码分析">3.3. 源码分析</h3>

<h4 id="331-概述">3.3.1. 概述</h4>

<ul>
  <li>
    <p>网络读写核心接口：</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">接口</th>
          <th style="text-align: left">描述</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">readQueryFromClient</td>
          <td style="text-align: left">服务读客户端数据。</td>
        </tr>
        <tr>
          <td style="text-align: left">writeToClient</td>
          <td style="text-align: left">服务向客户端写数据。</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>多线程工作模式核心接口(<code class="highlighter-rouge">networking.c</code>)，其它延时处理逻辑也有一部分源码。</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">接口</th>
          <th style="text-align: left">描述</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">IOThreadMain</td>
          <td style="text-align: left">子线程处理逻辑。</td>
        </tr>
        <tr>
          <td style="text-align: left">initThreadedIO</td>
          <td style="text-align: left">主线程创建挂起子线程。</td>
        </tr>
        <tr>
          <td style="text-align: left">startThreadedIO</td>
          <td style="text-align: left">主线程开启多线程工作模式。</td>
        </tr>
        <tr>
          <td style="text-align: left">stopThreadedIO</td>
          <td style="text-align: left">主线程暂停多线程工作模式。</td>
        </tr>
        <tr>
          <td style="text-align: left">stopThreadedIOIfNeeded</td>
          <td style="text-align: left">主线程根据写并发量是否关闭多线程工作模式。</td>
        </tr>
        <tr>
          <td style="text-align: left">handleClientsWithPendingWritesUsingThreads</td>
          <td style="text-align: left">主线程多线程处理延时写事件。</td>
        </tr>
        <tr>
          <td style="text-align: left">handleClientsWithPendingReadsUsingThreads</td>
          <td style="text-align: left">主线程多线程处理延时读事件。</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>其它延时处理逻辑，看看下面这些变量和宏在代码中的逻辑，这里不会详细展开。</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">变量/宏</th>
          <th style="text-align: left">描述</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">server.clients_pending_read</td>
          <td style="text-align: left">延时处理读事件的客户端连接链表。</td>
        </tr>
        <tr>
          <td style="text-align: left">server.clients_pending_write</td>
          <td style="text-align: left">延时处理写事件的客户端连接链表。</td>
        </tr>
        <tr>
          <td style="text-align: left">CLIENT_PENDING_READ</td>
          <td style="text-align: left">延时处理读事件标识。</td>
        </tr>
        <tr>
          <td style="text-align: left">CLIENT_PENDING_WRITE</td>
          <td style="text-align: left">延时处理写事件标识。</td>
        </tr>
        <tr>
          <td style="text-align: left">CLIENT_PENDING_COMMAND</td>
          <td style="text-align: left">延时处理命令逻辑标识。</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<hr />

<h4 id="332-源码">3.3.2. 源码</h4>

<ul>
  <li>
    <p>变量/宏</p>

    <p><code class="highlighter-rouge">io_threads_mutex</code> 互斥变量数组，为了方便主线程唤醒/挂起控制子线程。
<code class="highlighter-rouge">io_threads_pending</code> 原子变量，方便主线程统计子线程是否已经处理完所有任务。</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 最大线程个数。</span>
<span class="cp">#define IO_THREADS_MAX_NUM 128
</span>
<span class="c1">// 线程读操作。</span>
<span class="cp">#define IO_THREADS_OP_READ 0
</span>
<span class="c1">// 线程写操作。</span>
<span class="cp">#define IO_THREADS_OP_WRITE 1
</span>
<span class="c1">// 线程数组。</span>
<span class="n">pthread_t</span> <span class="n">io_threads</span><span class="p">[</span><span class="n">IO_THREADS_MAX_NUM</span><span class="p">];</span>

<span class="c1">// 互斥变量数组，提供主线程上锁和解锁子线程工作。</span>
<span class="n">pthread_mutex_t</span> <span class="n">io_threads_mutex</span><span class="p">[</span><span class="n">IO_THREADS_MAX_NUM</span><span class="p">];</span>

<span class="c1">// 原子变量数组，分别存储每个线程要处理的延时处理链接数量。主线程用来统计线程是否处理完等待事件，从而进行下一步操作。</span>
<span class="k">_Atomic</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_threads_pending</span><span class="p">[</span><span class="n">IO_THREADS_MAX_NUM</span><span class="p">];</span>

<span class="c1">// 是否启动了多线程处理模式。</span>
<span class="kt">int</span> <span class="n">io_threads_active</span><span class="p">;</span>

<span class="c1">// 线程操作类型。多线程每次只能处理一种类型的操作：读/写。</span>
<span class="kt">int</span> <span class="n">io_threads_op</span><span class="p">;</span>

<span class="c1">// 子线程列表，子线程个数为 IO_THREADS_MAX_NUM - 1，因为主线程也会处理延时任务。</span>
<span class="n">list</span> <span class="o">*</span><span class="n">io_threads_list</span><span class="p">[</span><span class="n">IO_THREADS_MAX_NUM</span><span class="p">];</span>
</code></pre></div></div>

<hr />

<ul>
  <li>主线程创建子线程</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">initThreadedIO</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">io_threads_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* We start with threads not active. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// 检查配置的线程数量是否超出限制。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span> <span class="o">&gt;</span> <span class="n">IO_THREADS_MAX_NUM</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span><span class="s">"Fatal: too many I/O threads configured. "</span>
                             <span class="s">"The maximum number is %d."</span><span class="p">,</span> <span class="n">IO_THREADS_MAX_NUM</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 创建 server.io_threads_num - 1 个子线程。</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">io_threads_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">listCreate</span><span class="p">();</span>

        <span class="c1">// 0 号线程不创建，0 号就是主线程，主线程也会处理任务逻辑。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// 创建子线程，主线程先对子线程上锁，挂起子线程，不让子线程进入工作模式。</span>
        <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
        <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_threads_mutex</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">io_threads_pending</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_threads_mutex</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">IOThreadMain</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span><span class="s">"Fatal: Can't initialize IO thread."</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">io_threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>开启多线程模式</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">startThreadedIO</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">serverAssert</span><span class="p">(</span><span class="n">io_threads_active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="c1">// 子线程因为上锁等待主线程解锁，当主线程解锁子线程，子线程重新进入工作状态。</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_threads_mutex</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="n">io_threads_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>子线程逻辑处理</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">IOThreadMain</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">myid</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 每个线程在创建的时候会产生一个业务 id。</span>
    <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">myid</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 替代 sleep，用忙等，这样能实时处理业务。但是也付出了耗费 cpu 的代价。</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_pending</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 留机会给主线程上锁，挂起当前子线程。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_pending</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_threads_mutex</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_threads_mutex</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">serverAssert</span><span class="p">(</span><span class="n">io_threads_pending</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1">// 根据操作类型，处理对应的读/写逻辑。</span>
        <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
        <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
        <span class="n">listRewind</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="n">id</span><span class="p">],</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
        <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">client</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_op</span> <span class="o">==</span> <span class="n">IO_THREADS_OP_WRITE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">writeToClient</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_op</span> <span class="o">==</span> <span class="n">IO_THREADS_OP_READ</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">readQueryFromClient</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">serverPanic</span><span class="p">(</span><span class="s">"io_threads_op value is unknown"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">listEmpty</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
        <span class="n">io_threads_pending</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>是否需要停止多线程模式</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">stopThreadedIOIfNeeded</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pending</span> <span class="o">=</span> <span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_write</span><span class="p">);</span>

    <span class="c1">// 如果单线程模式就直接返回。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_active</span><span class="p">)</span> <span class="n">stopThreadedIO</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>暂停多线程处理模式</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">stopThreadedIO</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 在停止线程前，仍然有等待处理的延时读数据处理，需要先处理再停止线程。</span>
    <span class="n">handleClientsWithPendingReadsUsingThreads</span><span class="p">();</span>

    <span class="n">serverAssert</span><span class="p">(</span><span class="n">io_threads_active</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// 主给子线程上锁，挂起子线程。</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_threads_mutex</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="n">io_threads_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>处理延时的读事件</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">handleClientsWithPendingReadsUsingThreads</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_threads_active</span> <span class="o">||</span> <span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">io_threads_do_reads</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_read</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">processed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 将等待处理的链接，通过取模放进不同的队列中去。</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_read</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">item_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">client</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">target_id</span> <span class="o">=</span> <span class="n">item_id</span> <span class="o">%</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span>
        <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="n">target_id</span><span class="p">],</span><span class="n">c</span><span class="p">);</span>
        <span class="n">item_id</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 分别统计每个队列要处理链接的个数。</span>
    <span class="n">io_threads_op</span> <span class="o">=</span> <span class="n">IO_THREADS_OP_READ</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">listLength</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">io_threads_pending</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 主线程处理第一个队列。</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">client</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>
        <span class="c1">// 读客户端发送的数据到缓存。</span>
        <span class="n">readQueryFromClient</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">listEmpty</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="c1">// 主线程处理完任务后，忙等其它线程，全部线程处理完任务后，再处理命令实现逻辑。</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">pending</span> <span class="o">+=</span> <span class="n">io_threads_pending</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 主线程处理命令逻辑，因为链接都标识了等待状态，读完数据后命令对应的业务逻辑还没有被处理。
     * 这里去掉等待标识，处理命令业务逻辑。*/</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_read</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">client</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLIENT_PENDING_READ</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_PENDING_COMMAND</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="n">CLIENT_PENDING_COMMAND</span><span class="p">;</span>
            <span class="c1">// 读取数据，解析协议取出命令参数，执行命令，填充回复缓冲区。</span>
            <span class="n">processCommandAndResetClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 继续解析协议，取出命令参数，执行命令，填充回复缓冲区。</span>
        <span class="n">processInputBufferAndReplicate</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">listEmpty</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_read</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>处理延时的写事件</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">handleClientsWithPendingWritesUsingThreads</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_write</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">processed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 如果延时写事件对应的 client 链接很少，关闭多线程模式，用主线程处理异步逻辑。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stopThreadedIOIfNeeded</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 处理延时写事件。</span>
        <span class="k">return</span> <span class="n">handleClientsWithPendingWrites</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_threads_active</span><span class="p">)</span> <span class="n">startThreadedIO</span><span class="p">();</span>

    <span class="c1">// 将等待处理的链接，通过取模放进不同的队列中去，去掉延迟写标识。</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_write</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">item_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">client</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLIENT_PENDING_WRITE</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">target_id</span> <span class="o">=</span> <span class="n">item_id</span> <span class="o">%</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span>
        <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="n">target_id</span><span class="p">],</span><span class="n">c</span><span class="p">);</span>
        <span class="n">item_id</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 线程处理写事件。</span>
    <span class="n">io_threads_op</span> <span class="o">=</span> <span class="n">IO_THREADS_OP_WRITE</span><span class="p">;</span>

    <span class="c1">// 分别统计每个队列要处理链接的个数。</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">listLength</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">io_threads_pending</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 主线程处理第一个队列。</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">client</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>
        <span class="c1">// 写数据，发送给回复给客户端。</span>
        <span class="n">writeToClient</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">listEmpty</span><span class="p">(</span><span class="n">io_threads_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="c1">// 主线程处理完任务后，忙等其它线程，全部线程处理完任务后，再处理命令实现逻辑。</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">io_threads_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">pending</span> <span class="o">+=</span> <span class="n">io_threads_pending</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_write</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">client</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>

        <span class="c1">// 如果缓存中还有没有发送完的数据，继续发送或者下次继续发，否则从事件驱动删除 fd 注册的可写事件。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clientHasPendingReplies</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="o">&amp;&amp;</span> <span class="n">connSetWriteHandler</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">,</span> <span class="n">sendReplyToClient</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">listEmpty</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients_pending_write</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-数据结构">4. 数据结构</h2>

<p><code class="highlighter-rouge">redisServer</code> 和 <code class="highlighter-rouge">client</code> 分别 redis 是服务端和客户端的数据结构，理解结构的成员作用是走读源码逻辑的关键。有兴趣的朋友下个断点跑下逻辑，细节就不详细展开了。</p>

<blockquote>
  <p><a href="https://wenfh2020.com/2020/01/05/redis-gdb/">用 gdb 调试 redis</a></p>
</blockquote>

<ul>
  <li>客户端结构</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// server.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">client</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">id</span><span class="p">;</span>            <span class="cm">/* Client incremental unique ID. */</span>
    <span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">sds</span> <span class="n">querybuf</span><span class="p">;</span>           <span class="cm">/* Buffer we use to accumulate client queries. */</span>
    <span class="kt">size_t</span> <span class="n">qb_pos</span><span class="p">;</span>          <span class="cm">/* The position we have read in querybuf. */</span>
    <span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>               <span class="cm">/* Num of arguments of current command. */</span>
    <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">;</span>            <span class="cm">/* Arguments of current command. */</span>
    <span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">lastcmd</span><span class="p">;</span>  <span class="cm">/* Last command executed. */</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>            <span class="cm">/* List of reply objects to send to the client. */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">reply_bytes</span><span class="p">;</span> <span class="cm">/* Tot bytes of objects in reply list. */</span>
    <span class="p">...</span>
    <span class="cm">/* Response buffer */</span>
    <span class="kt">int</span> <span class="n">bufpos</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">PROTO_REPLY_CHUNK_BYTES</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>服务端结构</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients</span><span class="p">;</span>              <span class="cm">/* List of active clients */</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients_to_close</span><span class="p">;</span>     <span class="cm">/* Clients to close asynchronously */</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients_pending_write</span><span class="p">;</span> <span class="cm">/* There is to write or install handler. */</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients_pending_read</span><span class="p">;</span>  <span class="cm">/* Client has pending read socket buffers. */</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="5-测试">5. 测试</h2>

<p>8 核心，16G 内存， mac book 本地测试。</p>

<p>redis 服务默认开 4 线程，压测工具开 2 线程。有剩余核心处理机器的其它业务，这样不影响 redis 工作。</p>

<blockquote>
  <p>Linux 系统，如果安装不了 redis 最新版本，请升级系统 <code class="highlighter-rouge">gcc</code> 版本。</p>
</blockquote>

<ul>
  <li>配置，多线程模式测试，开启读写两个选项；单线程模式测试则会关闭。</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis.conf</span>

io-threads 4
io-threads-do-reads <span class="nb">yes</span>
</code></pre></div></div>

<ul>
  <li>压测命令，会针对客户端链接数/测试包体大小进行测试。</li>
</ul>

<blockquote>
  <p>命令逻辑已整理成脚本，放到 <a href="https://github.com/wenfh2020/shell/blob/master/redis/benchmark.sh">github</a>，顺手录制了测试视频：<a href="https://www.bilibili.com/video/BV1r5411t7QF/">压力测试 redis 多线程处理网络 I/O</a>。</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 压测工具会模拟多个终端，防止超出限制，被停止。</span>
<span class="nb">ulimit</span> <span class="nt">-n</span> 16384

<span class="c"># 可以设置对应的链接数/包体大小进行测试。</span>
./redis-benchmark <span class="nt">-c</span> xxxx <span class="nt">-r</span> 1000000 <span class="nt">-n</span> 100000 <span class="nt">-t</span> <span class="nb">set</span>,get <span class="nt">-q</span> <span class="nt">--threads</span> 2  <span class="nt">-d</span> yyyy
</code></pre></div></div>

<ul>
  <li>压测结果</li>
</ul>

<p>在 mac book 上测试，从测试结果看，<strong>多线程没有单线程好</strong>。看到网上很多同学用压测工具测试，性能有很大的提升，有时间用其它机器跑下。可能是机器配置不一样，但是至少一点，这个多线程功能目前还有很大的优化空间，所以新特性，还需要放到真实环境中测试过，才能投产。</p>

<p><img src="/images/2020-04-21-14-19-22.png" alt="redis 压测过程" data-action="zoom" /></p>

<hr />

<h2 id="6-总结">6. 总结</h2>

<ul>
  <li>多线程模式使得网络读写快速处理。</li>
  <li>多线程模式会浪费一定 cpu，并发量不高不建议开启多线程模式。</li>
  <li>主线程实现主逻辑，子线程辅助完成任务。</li>
  <li>redis 即便开启多线程模式处理网络读写事件，宏观逻辑还是串行的。</li>
  <li>实践是检验真理的试金石，压测过程中，单线程比多线程优秀，没有体现出多线程应有的性能提升，其它尚待验证。</li>
</ul>

<hr />

<h2 id="7-参考">7. 参考</h2>

<ul>
  <li><a href="https://wenfh2020.com/2020/01/05/redis-gdb/">用 gdb 调试 redis</a></li>
  <li><a href="https://wenfh2020.com/2020/04/14/epoll-workflow/">epoll 多路复用 I/O工作流程</a></li>
  <li><a href="https://wenfh2020.com/2020/04/09/redis-ae-file/">[redis 源码走读] 事件 - 文件事件</a></li>
  <li><a href="https://wenfh2020.com/2020/04/06/ae-timer/">[redis 源码走读] 事件 - 定时器</a></li>
  <li><a href="https://redis.io/topics/benchmarks">How fast is Redis?</a></li>
  <li><a href="https://github.com/wenfh2020/shell/blob/master/redis/benchmark.sh">redis 压力测试多线程读写脚本</a></li>
  <li><a href="https://www.bilibili.com/video/BV1r5411t7QF/">压力测试 redis 多线程处理网络 I/O</a></li>
  <li><a href="https://blog.csdn.net/wfx15502104112/article/details/96508940">yum 更新 gcc 到版本 8</a></li>
</ul>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/">wenfh2020.com</a></p>
</blockquote>
