<p>redis 是 key-value 的 NoSQL 数据库，dict 是基本数据结构，dict 总体来说是一个<code class="highlighter-rouge">哈希表</code>，哈希表 $O(1)$ 的时间复杂度，能高效进行数据读取。dict 还有动态扩容/缩容的功能，能灵活有效地使用机器内存。因为 redis 是单进程服务，所以当数据量很大的时候，扩容/缩容这些内存操作，涉及到新内存重新分配，数据拷贝。当数据量大的时候，会导致系统卡顿，必然会影响服务质量，redis 作者采用了渐进式的方式，将一次性操作，分散到 dict 对应的各个增删改查操作中。每个操作触发有限制数量的数据进行迁移。所以 dict 会有两个哈希表（<code class="highlighter-rouge">dictht ht[2];</code>），相应的 <code class="highlighter-rouge">rehashidx</code> 迁移位置，方便数据迁移操作。</p>

<ul id="markdown-toc">
  <li><a href="#1-数据结构" id="markdown-toc-1-数据结构">1. 数据结构</a></li>
  <li><a href="#2-时间复杂度读数据" id="markdown-toc-2-时间复杂度读数据">2. 时间复杂度（读数据）</a></li>
  <li><a href="#3-工作流程" id="markdown-toc-3-工作流程">3. 工作流程</a></li>
  <li><a href="#4-写数据" id="markdown-toc-4-写数据">4. 写数据</a>    <ul>
      <li><a href="#41-保存数据" id="markdown-toc-41-保存数据">4.1. 保存数据</a></li>
      <li><a href="#42-添加数据" id="markdown-toc-42-添加数据">4.2. 添加数据</a></li>
      <li><a href="#43-增加数据结点" id="markdown-toc-43-增加数据结点">4.3. 增加数据结点</a></li>
      <li><a href="#44-哈希索引" id="markdown-toc-44-哈希索引">4.4. 哈希索引</a></li>
    </ul>
  </li>
  <li><a href="#5-数据迁移" id="markdown-toc-5-数据迁移">5. 数据迁移</a>    <ul>
      <li><a href="#51-哈希表数据迁移" id="markdown-toc-51-哈希表数据迁移">5.1. 哈希表数据迁移</a></li>
      <li><a href="#52-定时执行任务" id="markdown-toc-52-定时执行任务">5.2. 定时执行任务</a></li>
    </ul>
  </li>
  <li><a href="#6-扩容缩容" id="markdown-toc-6-扩容缩容">6. 扩容缩容</a>    <ul>
      <li><a href="#61-是否需要扩容" id="markdown-toc-61-是否需要扩容">6.1. 是否需要扩容</a></li>
      <li><a href="#62-扩容容量大小" id="markdown-toc-62-扩容容量大小">6.2. 扩容容量大小</a></li>
      <li><a href="#63-扩容" id="markdown-toc-63-扩容">6.3. 扩容</a></li>
      <li><a href="#64-缩容" id="markdown-toc-64-缩容">6.4. 缩容</a></li>
    </ul>
  </li>
  <li><a href="#7-随机键" id="markdown-toc-7-随机键">7. 随机键</a>    <ul>
      <li><a href="#71-随机取多个" id="markdown-toc-71-随机取多个">7.1. 随机取多个</a></li>
      <li><a href="#72-随机取一个" id="markdown-toc-72-随机取一个">7.2. 随机取一个</a></li>
    </ul>
  </li>
  <li><a href="#8-参考" id="markdown-toc-8-参考">8. 参考</a></li>
</ul>

<hr />

<h2 id="1-数据结构">1. 数据结构</h2>

<p><img src="/images/2020-02-20-16-49-43.png" alt="数据结构" data-action="zoom" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//字典</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span>
    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span>
    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">long</span> <span class="n">rehashidx</span><span class="p">;</span><span class="cm">/* rehashing not in progress if rehashidx == -1 */</span>
    <span class="kt">int</span> <span class="n">iterators</span><span class="p">;</span> <span class="cm">/* number of iterators currently running */</span>
<span class="p">}</span> <span class="n">dict</span><span class="p">;</span>

<span class="c1">// 哈希表</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>

<span class="c1">// 链表数据结点</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictEntry</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
        <span class="kt">int64_t</span> <span class="n">s64</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span>

<span class="c1">// 数据类型，不同应用实现是不同的，所以用指针函数抽象出通用的接口，方便调用。</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictType</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hashFunction</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">keyDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">valDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">keyCompare</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">keyDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">valDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span> <span class="n">dictType</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="2-时间复杂度读数据">2. 时间复杂度（读数据）</h2>

<p>查找数据，哈希表 $O(1)$ 时间复杂度，但是哈希表也会存在碰撞问题，所以哈希索引指向的列表长度也会影响效率。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)
</span>
<span class="n">dictEntry</span> <span class="o">*</span><span class="nf">dictFind</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">he</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">h</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">table</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">+</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* dict is empty */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="n">_dictRehashStep</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">table</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
        <span class="n">he</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="n">he</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果 key 已经存在则返回错误。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">==</span><span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">||</span> <span class="n">dictCompareKeys</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">he</span><span class="p">;</span>
            <span class="n">he</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 如果数据正在迁移，从第二张表上查找。</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-工作流程">3. 工作流程</h2>

<ul>
  <li>堆栈调用流程，下面会通过这个堆栈函数调用时序，看以下写操作的源码流程：</li>
</ul>

<blockquote>
  <p>调试方法，可以参考视频：</p>

  <ul>
    <li>bilibili: <a href="https://www.bilibili.com/video/av83070640">Debug Redis in VsCode with Gdb</a></li>
    <li>youtube: <a href="https://youtu.be/QltK3vV5Slw">Debug Redis in VsCode with Gdb</a></li>
  </ul>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#0  dictAdd (d=0x100529310, key=0x1018000b1, val=0x101800090) at dict.c:324</span>
<span class="c">#1  0x000000010002bb9c in dbAdd (db=0x101005800, key=0x101800070, val=0x101800090) at db.c:159</span>
<span class="c">#2  0x000000010002bd5c in setKey (db=0x101005800, key=0x101800070, val=0x101800090) at db.c:186</span>
<span class="c">#3  0x000000010003abad in setGenericCommand (c=0x101015400, flags=0, key=0x101800070, val=0x101800090, expire=0x0, unit=0, ok_reply=0x0, abort_reply=0x0) at t_string.c:86</span>
<span class="c">#4  0x000000010003afdd in setCommand (c=0x101015400) at t_string.c:139</span>
<span class="c">#5  0x000000010001052d in call (c=0x101015400, flags=15) at server.c:2252</span>
<span class="c">#6  0x00000001000112ac in processCommand (c=0x101015400) at server.c:2531</span>
<span class="c">#7  0x0000000100025619 in processInputBuffer (c=0x101015400) at networking.c:1299</span>
<span class="c">#8  0x0000000100021cb8 in readQueryFromClient (el=0x100528ba0, fd=5, privdata=0x101015400, mask=1) at networking.c:1363</span>
<span class="c">#9  0x000000010000583c in aeProcessEvents (eventLoop=0x100528ba0, flags=3) at ae.c:412</span>
<span class="c">#10 0x0000000100005ede in aeMain (eventLoop=0x100528ba0) at ae.c:455</span>
<span class="c">#11 0x00000001000159d7 in main (argc=2, argv=0x7ffeefbff8c8) at server.c:4114</span>
</code></pre></div></div>

<h2 id="4-写数据">4. 写数据</h2>

<h3 id="41-保存数据">4.1. 保存数据</h3>

<p>数据库保存数据时，先检查这个键是否已经存在，从而分开添加，删除逻辑。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* High level Set operation. This function can be used in order to set
 * a key, whatever it was existing or not, to a new object.
 *
 * 1) The ref count of the value object is incremented.
 * 2) clients WATCHing for the destination key notified.
 * 3) The expire time of the key is reset (the key is made persistent). */</span>
<span class="kt">void</span> <span class="nf">setKey</span><span class="p">(</span><span class="n">redisDb</span> <span class="o">*</span><span class="n">db</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lookupKeyWrite</span><span class="p">(</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dbAdd</span><span class="p">(</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">dbOverwrite</span><span class="p">(</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">incrRefCount</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">removeExpire</span><span class="p">(</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>
    <span class="n">signalModifiedKey</span><span class="p">(</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="42-添加数据">4.2. 添加数据</h3>

<p>要添加一个元素，首先需要申请一个空间，申请空间涉及到是否需要扩容，key 是否已经存在了。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Add an element to the target hash table */</span>
<span class="kt">int</span> <span class="nf">dictAdd</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">dictAddRaw</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="k">return</span> <span class="n">DICT_ERR</span><span class="p">;</span>
    <span class="n">dictSetVal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="43-增加数据结点">4.3. 增加数据结点</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Low level add. This function adds the entry but instead of setting
 * a value returns the dictEntry structure to the user, that will make
 * sure to fill the value field as he wishes.
 *
 * This function is also directly exposed to the user API to be called
 * mainly in order to store non-pointers inside the hash value, example:
 *
 * entry = dictAddRaw(dict,mykey);
 * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);
 *
 * Return values:
 *
 * If key already exists NULL is returned.
 * If key was added, the hash entry is returned to be manipulated by the caller.
 */</span>
<span class="n">dictEntry</span> <span class="o">*</span><span class="nf">dictAddRaw</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
    <span class="n">dictht</span> <span class="o">*</span><span class="n">ht</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="n">_dictRehashStep</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>

    <span class="cm">/* Get the index of the new element, or -1 if
     * the element already exists. */</span>
    <span class="c1">// 检查 key 是否存在，避免重复添加。</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">=</span> <span class="n">_dictKeyIndex</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Allocate the memory and store the new entry.
     * Insert the element in top, with the assumption that in a database
     * system it is more likely that recently added entries are accessed
     * more frequently. */</span>
    <span class="c1">// 如果哈希表正在迁移数据，操作哈希表2.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">));</span>
    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>

    <span class="cm">/* Set the hash entry fields. */</span>
    <span class="n">dictSetKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="44-哈希索引">4.4. 哈希索引</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Returns the index of a free slot that can be populated with
 * a hash entry for the given 'key'.
 * If the key already exists, -1 is returned.
 *
 * Note that if we are in the process of rehashing the hash table, the
 * index is always returned in the context of the second (new) hash table. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_dictKeyIndex</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">table</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">he</span><span class="p">;</span>

    <span class="cm">/* Expand the hash table if needed */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_dictExpandIfNeeded</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="n">DICT_ERR</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="cm">/* Compute the key hash value */</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">table</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
        <span class="cm">/* Search if this slot does not already contain the given key */</span>
        <span class="n">he</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="n">he</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果 key 已经存在则返回错误。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">==</span><span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">||</span> <span class="n">dictCompareKeys</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">he</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 如果哈希表处在数据迁移状态，从第二张表上查找。</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="5-数据迁移">5. 数据迁移</h2>

<h3 id="51-哈希表数据迁移">5.1. 哈希表数据迁移</h3>

<p>避免数据量大，一次性迁移需要耗费大量资源。每次只迁移部分数据。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* This function performs just a step of rehashing, and only if there are
 * no safe iterators bound to our hash table. When we have iterators in the
 * middle of a rehashing we can't mess with the two hash tables otherwise
 * some element can be missed or duplicated.
 *
 * This function is called by common lookup or update operations in the
 * dictionary so that the hash table automatically migrates from H1 to H2
 * while it is actively used. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_dictRehashStep</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">iterators</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">dictRehash</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */</span>
<span class="kt">int</span> <span class="nf">dictRehash</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// empty_visits 记录哈希表最大遍历空桶个数。</span>
    <span class="kt">int</span> <span class="n">empty_visits</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span> <span class="cm">/* Max number of empty buckets to visit. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 从 ht[0] rehashidx 位置开始遍历 n 个桶进行数据迁移。</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">--</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span> <span class="o">*</span><span class="n">nextde</span><span class="p">;</span>

        <span class="cm">/* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="o">++</span><span class="p">;</span>
            <span class="c1">// 当遍历限制的空桶数量后，返回。</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">empty_visits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 获取桶上的数据链表</span>
        <span class="n">de</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">];</span>
        <span class="cm">/* Move all the keys in this bucket from the old to the new hash HT */</span>
        <span class="k">while</span><span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>

            <span class="n">nextde</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="cm">/* Get the index in the new hash table */</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
            <span class="c1">// 旧的数据链表插入新的数据链表前面。</span>
            <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">de</span><span class="p">;</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span><span class="o">--</span><span class="p">;</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">nextde</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 数据迁移完毕，重置哈希表两个 table。</span>
    <span class="cm">/* Check if we already rehashed the whole table... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">_dictReset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* More to rehash... */</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="52-定时执行任务">5.2. 定时执行任务</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</span>
<span class="kt">int</span> <span class="nf">dictRehashMilliseconds</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ms</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">timeInMilliseconds</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">rehashes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="n">dictRehash</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">rehashes</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timeInMilliseconds</span><span class="p">()</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">ms</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">rehashes</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="6-扩容缩容">6. 扩容缩容</h2>

<p><code class="highlighter-rouge">dict</code> 是 redis 基础数据之一，该数据结构有动态扩容和缩容功能。</p>

<h3 id="61-是否需要扩容">6.1. 是否需要扩容</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Expand the hash table if needed */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_dictExpandIfNeeded</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Incremental rehashing already in progress. Return. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>

    <span class="cm">/* If the hash table is empty expand it to the initial size. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">DICT_HT_INITIAL_SIZE</span><span class="p">);</span>

    <span class="cm">/* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the "safe" threshold, we resize doubling
     * the number of buckets. */</span>
    <span class="c1">// 当使用的数据大于哈希表大小就可以扩展了。当`dict_can_resize` 不允许扩展时，数据的使用与哈希表的大小对比，超出一个比率强制扩展内存。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">dict_can_resize</span> <span class="o">||</span>
         <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span><span class="o">/</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">dict_force_resize_ratio</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 使用数据大小的两倍增长</span>
        <span class="k">return</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="62-扩容容量大小">6.2. 扩容容量大小</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Our hash table capability is a power of two */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">_dictNextPower</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="n">DICT_HT_INITIAL_SIZE</span><span class="p">;</span>

    <span class="c1">// 新容量大小是 2 的 n 次方，并且这个数值是第一个大于 2 * 原长度 的值。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">LONG_MAX</span><span class="p">)</span> <span class="k">return</span> <span class="n">LONG_MAX</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="63-扩容">6.3. 扩容</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Expand or create the hash table */</span>
<span class="kt">int</span> <span class="nf">dictExpand</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictht</span> <span class="n">n</span><span class="p">;</span> <span class="cm">/* the new hash table */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">realsize</span> <span class="o">=</span> <span class="n">_dictNextPower</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

    <span class="cm">/* the size is invalid if it is smaller than the number of
     * elements already inside the hash table */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">||</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DICT_ERR</span><span class="p">;</span>

    <span class="cm">/* Rehashing to the same table size is not useful. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">realsize</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">)</span> <span class="k">return</span> <span class="n">DICT_ERR</span><span class="p">;</span>

    <span class="cm">/* Allocate the new hash table and initialize all pointers to NULL */</span>
    <span class="n">n</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">realsize</span><span class="p">;</span>
    <span class="n">n</span><span class="p">.</span><span class="n">sizemask</span> <span class="o">=</span> <span class="n">realsize</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">n</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">zcalloc</span><span class="p">(</span><span class="n">realsize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dictEntry</span><span class="o">*</span><span class="p">));</span>
    <span class="n">n</span><span class="p">.</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Is this the first initialization? If so it's not really a rehashing
     * we just set the first hash table so that it can accept keys. */</span>
    <span class="c1">// 如果哈希表还是空的，给表1分配空间，否则空间分配给表2</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Prepare a second hash table for incremental rehashing */</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="64-缩容">6.4. 缩容</h3>

<ul>
  <li>缩容，部分删除操作，会触发重新分配内存进行存储。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define HASHTABLE_MIN_FILL        10      </span><span class="cm">/* Minimal hash table fill 10% */</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">zsetDel</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">zobj</span><span class="p">,</span> <span class="n">sds</span> <span class="n">ele</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">htNeedsResize</span><span class="p">(</span><span class="n">zs</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">))</span> <span class="n">dictResize</span><span class="p">(</span><span class="n">zs</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">htNeedsResize</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">used</span><span class="p">;</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">dictSlots</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    <span class="n">used</span> <span class="o">=</span> <span class="n">dictSize</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">DICT_HT_INITIAL_SIZE</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">used</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">HASHTABLE_MIN_FILL</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Resize the table to the minimal size that contains all the elements,
 * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span>
<span class="kt">int</span> <span class="nf">dictResize</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">minimal</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dict_can_resize</span> <span class="o">||</span> <span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="n">DICT_ERR</span><span class="p">;</span>
    <span class="n">minimal</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">minimal</span> <span class="o">&lt;</span> <span class="n">DICT_HT_INITIAL_SIZE</span><span class="p">)</span>
        <span class="n">minimal</span> <span class="o">=</span> <span class="n">DICT_HT_INITIAL_SIZE</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">minimal</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="7-随机键">7. 随机键</h2>

<p>随机键是配合一些算法使用的，例如 <code class="highlighter-rouge">maxmemory</code> 的淘汰策略，需要对数据进行采样，如果要随机取多个数据，<code class="highlighter-rouge">dictGetSomeKeys</code> 速度要比 <code class="highlighter-rouge">dictGetRandomKey</code> 快，但是随机分布效果没有<code class="highlighter-rouge">dictGetRandomKey</code> 好。</p>

<h3 id="71-随机取多个">7.1. 随机取多个</h3>

<p>字典随机连续采样。不保证能采样满足 count 个数。采集到指定数量样本，或者样本不够，但是查找次数到达上限，会退出。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">dictGetSomeKeys</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">dictEntry</span> <span class="o">**</span><span class="n">des</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">;</span> <span class="cm">/* internal hash table id, 0 or 1. */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tables</span><span class="p">;</span> <span class="cm">/* 1 or 2 tables? */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stored</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxsizemask</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxsteps</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="n">count</span> <span class="o">=</span> <span class="n">dictSize</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="n">maxsteps</span> <span class="o">=</span> <span class="n">count</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>

    <span class="c1">// 如果字典正在数据迁移，多迁移几个数据，然后再进行逻辑。</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="n">_dictRehashStep</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tables</span> <span class="o">=</span> <span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">maxsizemask</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tables</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">maxsizemask</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sizemask</span><span class="p">)</span>
        <span class="n">maxsizemask</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">maxsizemask</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">emptylen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 两个条件，采集到指定数量样本，或者样本不够，但是查找次数到达上限。</span>
    <span class="k">while</span><span class="p">(</span><span class="n">stored</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">maxsteps</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">tables</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tables</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* 哈希表正在数据迁移，我们在表 1 上采样，如果 i &lt; d-&gt;rehashidx，
                 * 说明 i 下标指向的数据已经迁移到表 2 中去了，那么我们到表 2 中进行采样。
                 * 如果 i 下标大于表 2 的大小，那么在表2 中索引将会越界，那么继续在表 1 中
                 * 没有迁移的数据段（ &gt; rehashidx）中查找。*/</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 如果下标已经超出了当前表大小，继续遍历下一张表。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">size</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">dictEntry</span> <span class="o">*</span><span class="n">he</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="c1">// 如果连续几个桶都是空的，再随机位置进行采样。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">he</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">emptylen</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">emptylen</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">emptylen</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">maxsizemask</span><span class="p">;</span>
                    <span class="n">emptylen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">emptylen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">he</span><span class="p">)</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">des</span> <span class="o">=</span> <span class="n">he</span><span class="p">;</span>
                    <span class="n">des</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">he</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="n">stored</span><span class="o">++</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">stored</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span> <span class="k">return</span> <span class="n">stored</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">maxsizemask</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">stored</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="72-随机取一个">7.2. 随机取一个</h3>

<p>先找一个随机非空桶，再在桶里随机找一个元素。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return a random entry from the hash table. Useful to
 * implement randomized algorithms */</span>
<span class="n">dictEntry</span> <span class="o">*</span><span class="nf">dictGetRandomKey</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">he</span><span class="p">,</span> <span class="o">*</span><span class="n">orighe</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">listlen</span><span class="p">,</span> <span class="n">listele</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="n">_dictRehashStep</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="c1">// 哈希表正在进行数据迁移，</span>
            <span class="c1">// 从 表 1 的 rehashidx 到 d-&gt;ht[0].size 和 表 2 上随机抽取数据。</span>
            <span class="c1">// 但是当哈希表正在扩容时，表2的大小至少是表 1 的两倍，而随机值落在表 2 的几率会更</span>
            <span class="c1">//大。这个时候表2 的数据还没怎么进行填充，所以数据采集就会失败。失败几率会比较高。</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">+</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">+</span>
                                            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">-</span>
                                            <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">));</span>
            <span class="n">he</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">)</span> <span class="o">?</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">]</span> <span class="o">:</span>
                                      <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">he</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
            <span class="n">he</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">he</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">listlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">orighe</span> <span class="o">=</span> <span class="n">he</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">he</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">he</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">listlen</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">listele</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="n">listlen</span><span class="p">;</span>
    <span class="n">he</span> <span class="o">=</span> <span class="n">orighe</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">listele</span><span class="o">--</span><span class="p">)</span> <span class="n">he</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">he</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="8-参考">8. 参考</h2>

<ul>
  <li><a href="https://blog.csdn.net/men_wen/article/details/69787532">Redis源码剖析和注释（三）— Redis 字典结构</a></li>
  <li>《redis 设计与实现》</li>
  <li><a href="https://blog.csdn.net/qq_30085733/article/details/79843175">Redis源码学习简记（三）dict哈希原理与个人理解</a></li>
  <li><a href="https://blog.csdn.net/men_wen/article/details/69787532">Redis源码剖析和注释</a></li>
  <li><a href="http://chenzhenianqing.com/articles/1101.html">Redis Scan迭代器遍历操作原理（二）–dictScan反向二进制迭代器</a></li>
</ul>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/2020/01/12/redis-dict/">wenfh2020.com</a></p>
</blockquote>
