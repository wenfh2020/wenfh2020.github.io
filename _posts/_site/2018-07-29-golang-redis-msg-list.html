<p>用 redis  的 list 数据结构作为轻量级的消息队列，对于小系统确实是小而美，可控能力强。当然与 kafka 相比它还有很多缺陷。</p>

<ul id="markdown-toc">
  <li><a href="#1-测试机器" id="markdown-toc-1-测试机器">1. 测试机器</a></li>
  <li><a href="#2-生产者" id="markdown-toc-2-生产者">2. 生产者</a></li>
  <li><a href="#3-消费者" id="markdown-toc-3-消费者">3. 消费者</a></li>
  <li><a href="#4-总结" id="markdown-toc-4-总结">4. 总结</a></li>
</ul>

<hr />

<h2 id="1-测试机器">1. 测试机器</h2>

<p>机器配置：双核，4G</p>

<p>测试数据：100 w</p>

<hr />

<h2 id="2-生产者">2. 生产者</h2>

<p>生产者，生产 100 w 条数据， 并发 13817 。(<a href="https://github.com/wenfh2020/go-test/blob/master/redis/redis_list/producer/produce.go">测试源码</a>)</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Produce</span><span class="p">(</span><span class="n">szBytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pConn</span> <span class="o">:=</span> <span class="n">GetRedisConn</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pConn</span><span class="o">.</span><span class="n">Err</span><span class="p">()</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">pConn</span><span class="o">.</span><span class="n">Err</span><span class="p">()</span><span class="o">.</span><span class="n">Error</span><span class="p">())</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="n">pConn</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">pConn</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="s">"lpush"</span><span class="p">,</span> <span class="s">"redislist"</span><span class="p">,</span> <span class="n">szBytes</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">Error</span><span class="p">())</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/2020-02-20-16-54-38.png" alt="生产者负载" data-action="zoom" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>begin <span class="nb">time</span>: 2018-07-29 14:03:55.606
end   <span class="nb">time</span>: 2018-07-29 14:05:07.976
Produce message: 1000000
avg: 13817.860879118389
</code></pre></div></div>

<hr />

<h2 id="3-消费者">3. 消费者</h2>

<p>消费者，消费 100 w 条数据，并发 9433。(<a href="https://github.com/wenfh2020/go-test/blob/master/redis/redis_list/customer/logic.go">测试源码</a>)</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Custom</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">redis</span><span class="o">.</span><span class="n">Dial</span><span class="p">(</span><span class="s">"tcp"</span><span class="p">,</span> <span class="n">REDIS_ADDR</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="n">c</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

    <span class="o">...</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="n">vals</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">redis</span><span class="o">.</span><span class="n">Values</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="s">"brpop"</span><span class="p">,</span> <span class="n">MESSAGE_KEY</span><span class="p">,</span> <span class="n">WAIT_TIME</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="o">...</span>
            <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/2020-02-20-16-55-06.png" alt="消费者负载" data-action="zoom" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>begin <span class="nb">time</span>: 2018-07-29 14:46:11.166
end <span class="nb">time</span>: 2018-07-29 14:47:58.038
custom message: 1000000
avg: 9433
</code></pre></div></div>

<hr />

<h2 id="4-总结">4. 总结</h2>

<p>以上生产和消费测试都是独立测试的，生产数据和消费数据，能达到 1w 左右的并发；如果生产者和消费者同时进行工作，各自并发能力还要下降 20%左右。消费者为了保证数据被消费失败后，能保重新消费，还需要写一部分逻辑，估计性能还会下降一部分，所以单实例的Redis消息队列消费并发应该是5000左右(根据业务多开几条队列，通过性能叠加，解决更高的并发问题？！）</p>

<hr />

<p>测试代码用的是 golang 第三方库 <code class="highlighter-rouge">redigo</code> 做的压测，如果换成 C++ 的 hiredis 异步特性（参考我的帖子<a href="https://wenfh2020.com/2018/06/17/redis-hiredis-libev/">《hiredis + libev 异步测试》）</a>，生产者单进程并发轻松上 10w+，原则上消费能力也一样，但是消费为了保证数据的时序性，一般是一条条取出来入库处理，入库是同步操作，速度显然快不了多少。</p>
