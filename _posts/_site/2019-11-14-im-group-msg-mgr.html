<p>即时通讯，消息有很多种类型，单聊，群聊等等。群组聊天消息管理相对比较麻烦，因为涉及到多个用户，尤其是千人群组，1 个人发送消息，999 个人接收，数据库针对每个用户存储一条记录吗？这个量级的数据存储是十分恐怖的，所以消息的存储策略显得十分重要。</p>

<ul id="markdown-toc">
  <li><a href="#1-消息时序" id="markdown-toc-1-消息时序">1. 消息时序</a></li>
  <li><a href="#2-redis-设计" id="markdown-toc-2-redis-设计">2. redis 设计</a></li>
  <li><a href="#3-database-设计" id="markdown-toc-3-database-设计">3. database 设计</a></li>
  <li><a href="#4-服务存储架构" id="markdown-toc-4-服务存储架构">4. 服务存储架构</a></li>
  <li><a href="#5-数据读写时序" id="markdown-toc-5-数据读写时序">5. 数据读写时序</a>    <ul>
      <li><a href="#51-写数据" id="markdown-toc-51-写数据">5.1. 写数据</a></li>
      <li><a href="#52-读数据" id="markdown-toc-52-读数据">5.2. 读数据</a></li>
    </ul>
  </li>
  <li><a href="#6-总结" id="markdown-toc-6-总结">6. 总结</a></li>
</ul>

<hr />

<h2 id="1-消息时序">1. 消息时序</h2>

<p>理想状态下，客户端和服务端数据是一致的。实际情况，涉及到用户上线或下线。（详见下图）</p>

<ol>
  <li>用户在线：服务实时发送消息。</li>
  <li>用户离线：服务保存消息；用户重新上线后，向服务获取离线消息。</li>
</ol>

<hr />

<p><img src="/images/2020-02-25-08-14-15.png" alt="消息时序" data-action="zoom" /></p>

<hr />

<ul>
  <li>
    <p>群组离线消息数据分页链式管理。</p>

    <p>如上图，每条消息都是有时序的，像链表一样，串联起来，每个 node 都可以通过 next 指向上一条消息：</p>
    <ol>
      <li>如果上一条消息 msg_id 是  0，说明当前结点是第一条消息（如上图 msg_id == 1 的消息）。</li>
      <li>如果上一条消息 msg_id 不是 0，且消息存在于本地，那么消息是连续的，不需要向服务同步（如上图 msg_id == 2 的消息）。</li>
      <li>如果上一条消息 msg_id 不是 0，但本地消息不存在，那么需要向服务器获取。（如上图 msg_id == 9 的消息）。
        <blockquote>
          <p>终端通过消息链表方式的检查，很容易确认是否需要向服务同步数据。</p>
        </blockquote>
      </li>
    </ol>
  </li>
  <li>
    <p>群组未读消息总条数。</p>

    <p>从 client 的缓存中提取最新（lastest）的 msg_id，对应消息体有 recv_time。
 服务端消息的时序通过 redis 的 sortset 存储的，redis 的 sortset 结构，很容易通过一个 score 获取一个区间的数据总数。</p>
  </li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key: group_id, score: recv_time, value: msg_id
</code></pre></div></div>

<hr />

<h2 id="2-redis-设计">2. redis 设计</h2>

<ul>
  <li>sortset 存储存储消息时序。</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key: group_id, score: recv_time, value: msg_id
</code></pre></div></div>

<ul>
  <li>
    <p>string 存储消息体。</p>

    <p>因为消息体数量较多，而且活跃时间比较短（因为大部分用户只关心最近接收的消息），所以把它独立出来。便于 timeout 后 redis 能删除节省内存。</p>
  </li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key: msg_id, value: msg_body
</code></pre></div></div>

<ul>
  <li>
    <p>set 存储未读消息对象。</p>

    <p>每个用户都可能有 N 个群组，N 个好友。用户重新上线后，不可能遍历所有好友或群组对象。所以服务在处理离线消息时，需要记录未读消息对象。</p>
  </li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key: uid, member:group_id/send_uid
</code></pre></div></div>

<hr />

<h2 id="3-database-设计">3. database 设计</h2>

<ul>
  <li>群组和群组成员关系</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>group_id, uid
</code></pre></div></div>

<ul>
  <li>消息结构</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msg_id, group_id, send_uid, recv_uid,  recv_time, msg_body
</code></pre></div></div>

<hr />

<h2 id="4-服务存储架构">4. 服务存储架构</h2>

<p>即时通讯服务是读多写少类型。服务端有三层存储（如下图），通过热点数据的缓存，让服务高效读取。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">msg server</code> 服务进程内存 <code class="highlighter-rouge">session</code> 缓存热点数据。
 缓存当前活跃的数据：头像信息，用户名称，消息实体等数据，缓存一般 5 - 30 分钟，根据具体的业务需要</p>
  </li>
  <li>
    <p>redis 第二层缓存热点数据。
 缓存大量的热点数据，减少对 db 的访问频率，缓存时间相对较长，几个月不等。</p>
  </li>
  <li>
    <p>database 数据落地。</p>
  </li>
</ul>

<p><img src="/images/2020-02-25-08-16-18.png" alt="存储架构" data-action="zoom" /></p>

<hr />

<h2 id="5-数据读写时序">5. 数据读写时序</h2>

<h3 id="51-写数据">5.1. 写数据</h3>

<p><img src="/images/2020-02-25-08-16-44.png" alt="写逻辑" data-action="zoom" /></p>

<hr />

<h3 id="52-读数据">5.2. 读数据</h3>

<p><img src="/images/2020-02-25-08-17-14.png" alt="读逻辑" data-action="zoom" /></p>

<hr />

<h2 id="6-总结">6. 总结</h2>

<p>基于以上分析，群组消息，每个用户发送的消息，不需要针对每个群组成员存一条记录到数据库，数据库只需要存一条记录即可。通过多级缓存的架构，服务的性能一般体量的消息实时通讯是没有问题的。当然这里面还有很多细节问题需要在实际的业务场景中调优。</p>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/2019/11/14/im-group-msg-mgr/">wenfh2020.com</a></p>
</blockquote>
