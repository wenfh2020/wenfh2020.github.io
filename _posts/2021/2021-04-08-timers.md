---
layout: post
title:  "基于 stl map 的定时器"
categories: c/c++
tags: timer map stl
author: wenfh2020
---

项目要添加 session，每个 session 需要设置过期时间，所以需要定时器。

定时器实现逻辑：对每个定时器事件到期时间进行排序，对有序数据进行检查处理，需要支持查找。

比较了多种方案后，决定通过参考 [C++11实现的定时器](https://blog.csdn.net/hiwubihe/article/details/84206235) ，基于 stl 的字典（map）造个简单点的轮子。





* content
{:toc}

---

## 1. 实现

方案选择 std::map 实现。原因：

* std::map 内部是一颗红黑树，读写时间复杂度 O(logN)。
* std::map 迭代器默认是根据 key 索引的中序排列。
* 支持查询。

> 实现源码：[timers.h](https://github.com/wenfh2020/co_kimserver/blob/main/src/core/timers.h), [timers.cpp](https://github.com/wenfh2020/co_kimserver/blob/main/src/core/timers.cpp)
> 测试源码：[test_timers.cpp](https://github.com/wenfh2020/co_kimserver/blob/main/src/test/test_timers/test_timers.cpp)

---

### 1.1. 定时器事件

事件组合 id（TimerGrpID）设计，主要为了方便 std::map 内部排序，还有去重。

```c++
/* 定时器事件组合 id。
 * 第一个参数是事件到期时间，方便 std::map 排序。
 * 第二个参数是定时器事件 id。*/
typedef std::pair<int64_t, uint32_t> TimerGrpID;

/* 定时器事件回调函数。 */
typedef std::function<void(int, bool, void*)> TimerEvent;

/* 定时器事件。 */
class Timer {
    ...
    int m_id = 0;               /* timer's id. */
    uint64_t m_after_time = 0;  /* timeout in `after` milliseconds. */
    uint64_t m_repeat_time = 0; /* repeat milliseconds. */
    void* m_privdata = nullptr; /* user's data. */
    TimerEvent m_callback_fn;   /* callback function. */
};
```

---

### 1.2. 定时器事件管理

主要通过两个数据结构进行维护：`std::map` 和 `std::unordered_map`，前者方便定时器事件的排序和数据存储，后者方便查询定时事件。

```c++
class Timers {
    ...
   public:
    /* 删除定时器事件。 */
    bool del_timer(int id);
    /* 添加定时器事件。 */
    int add_timer(const TimerEvent& fn, uint64_t after, uint64_t repeat = 0, void* privdata = nullptr);

   public:
    /* 外部定时刷新，检查事件是否过期. */
    virtual void on_repeat_timer() override;
    ...
   protected:
    int m_last_timer_id = 0;
    std::map<TimerGrpID, Timer*> m_timers;
    std::unordered_map<int, TimerGrpID> m_ids; /* 通过哈希表方便对 std::map 的组合 id 进行查询，删除. */
};
```

---

## 2. 方案筛选

### 2.1. libco

项目基于 libco，libco 有自己的时间轮，效率很高。但缺点也明显：

* 不支持查找事件事件。
* 处理超过一分钟的过期事件效率下降。
* 而且耦合在 libco 内部，对外使用不友好。

> [[libco] libco 定时器（时间轮）](https://wenfh2020.com/2021/03/30/libco-timer/)

---

### 2.2. libev

libev 的定时器也不错，4叉堆排序，支持查找。但是 libev 代码可读性比较差，要将代码扣出来感觉点复杂。

> [Libev源码分析03：Libev使用堆管理定时器](https://www.cnblogs.com/gqtcgq/p/7247107.html)

---

### 2.3. redis

redis 定时器是基于双向列表的，时间复杂度更差了，如果用它的跳跃表数据结构实现估计不错的，但是想到要扣那么多代码，还是算了。

> [[redis 源码走读] 事件 - 定时器](https://wenfh2020.com/2020/04/06/ae-timer/)
> [[redis 源码走读] 跳跃表(skiplist)]( https://wenfh2020.com/2020/02/03/redis-skiplist/)

---

### 2.4. stl

#### 2.4.1. heap

stl 有堆算法，[std::make_heap](https://www.cplusplus.com/reference/algorithm/make_heap/)，可惜它不支持查找功能。

---

#### 2.4.2. map

std::map 内部是一颗红黑树，读写时间复杂度 O(n)，迭代器默认是根据 key 索引排列，支持排序和查询，方案不错。

---

## 3. 参考

* [[libco] libco 定时器（时间轮）](https://wenfh2020.com/2021/03/30/libco-timer/)
* [[redis 源码走读] 事件 - 定时器](https://wenfh2020.com/2020/04/06/ae-timer/)
* [[redis 源码走读] 跳跃表(skiplist)]( https://wenfh2020.com/2020/02/03/redis-skiplist/)
* [std::make_heap](https://www.cplusplus.com/reference/algorithm/make_heap/)
* [C++11实现的定时器](https://blog.csdn.net/hiwubihe/article/details/84206235)
