---
layout: post
title:  "Linux 系统调用（x86_64）"
categories: kernel
tags: linux kernel syscall
author: wenfh2020
---

Linux 操作系统，为了避免用户程序非法操作设备资源，需要限制进程的操作权限，只有内核才有最高操作权限，用户程序可以通过内核间接操作设备资源。

这样内核为用户程序提供了一组交互的接口，提供用户程序进行 `系统调用` 对应的接口。

操作系统这样做的目的，一方面是为了将复杂困难的逻辑封装起来，简化方便用户程序操作，另一方面也最大限度降低用户程序非法操作的风险，保证操作系统能安全，稳定地工作。

> 详细信息请参考：[wiki](https://en.wikipedia.org/wiki/System_call)（链接需要翻墙）

---

本文，会通过调试方式，从用户程序到内核，理解一下系统调用的工作流程。

> 本文 Linux 内核源码基于 Linux 5.0.1。



* content
{:toc}

---

* 用户空间参数是怎么传过来的呢。
* 用户空间状态是如何保存的。
* 用户态和内核态是如何切换的。
* 从内核空间到用户空间是如何恢复的。

<div align=center><img src="/images/2021-09-12-23-14-13.png" data-action="zoom"/></div>

<div align=center><img src="/images/2021-09-12-23-10-14.png" data-action="zoom"/></div>

<div align=center><img src="/images/2021-09-12-23-14-42.png" data-action="zoom"/></div>

<div align=center><img src="/images/2021-09-13-10-09-27.png" data-action="zoom"/></div>

## 1. 概述

Linux 应用程序要与内核通信，需要通过 `系统调用`。系统调用，相当于用户空间和内核空间之间添加了一个中间层。

<div align=center><img src="/images/2021-09-13-10-12-21.png" data-action="zoom"/></div>

---

### 1.1. 系统调用作用

系统调用相当于用户空间和内核空间之间添加了一个中间层，它的作用是：

1. 操作系统为用户空间提供一组抽象接口，将困难复杂的逻辑封装起来，相当于用户程序黑盒操作，方便简化了用户的操作。
2. 保证了系统的安全和稳定性，避免用户非法操作，影响系统的正常运行。

---

### 1.2. CPU 上下文切换

系统调用，进程从用户模式转换到内核模式，会发生 CPU 上下文切换，切换的流程：

1. 保存 CPU 寄存器里原理用户态的指令位。
2. 为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。
3. 跳转到内核态运行内核任务。
4. 当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。

---

## 2. 用户空间

### 2.1. 应用程序

* c 语言程序（hello.c）。

```c
/* hello.c 
 * gcc main.c -g -O0 -o hello */
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main() {
    write(1, "hello world", strlen("hello world"));
    return 0;
}
```

* 系统为了运行 c 程序，每条 c 语句，被编译器翻译成低级语言指令，然后将这些指令按照一种可执行 `目标程序` 的格式打包，并以二进制磁盘文件的形式存放起来，目标程序也称为可执行目标程序。

  <div align=center><img src="/images/2021-09-14-10-19-50.png" data-action="zoom"/></div>

  > 图片来源：《深入理解计算机系统》- 第一章 计算机系统漫游 - 1.2 程序被其它程序翻译成不同的个数。

---

### 2.2. 动态库链接

程序通过 libc.so 动态库系统调用进入内核，具体源码实现还是比较复杂的，可以通过反汇编方式观察程序的工作流程，这样思路就清晰多了。
  
> 涉及到动态库链接原理，可以参考《深入理解计算机系统》- 第七章 链接 - 7.12 位置无关）。

```shell
# 用 gcc 编译 hello.c 源码。
➜ gcc main.c -g -O0 -o hello

# 查看 hello 程序调用的动态库，可见 hello 连接的是 libc.so 动态库。
➜ ldd hello 
    linux-vdso.so.1 =>  (0x00007ffc424fc000)
    libc.so.6 => /lib64/libc.so.6 (0x00007f03462a4000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f0346672000)

# 通过 objdump 查看程序的汇编代码。
➜ objdump -dS hello > asm.txt

#######################################################################
# 查看 asm.txt 文件保存的 hello 的汇编源码，hello 程序调用 libc.so 的接口。
#######################################################################

# 通过 (PLT) 调用全局偏移量表（GOT）对应的函数指针。
0000000000400400 <.plt>:
  400400:   ff 35 02 0c 20 00       pushq  0x200c02(%rip)        # 601008 <_GLOBAL_OFFSET_TABLE_+0x8>
  400406:   ff 25 04 0c 20 00       jmpq   *0x200c04(%rip)       # 601010 <_GLOBAL_OFFSET_TABLE_+0x10>
  40040c:   0f 1f 40 00             nopl   0x0(%rax)

# 跳转到过程链接表（PLT）。
0000000000400410 <write@plt>:

  400410:   ff 25 02 0c 20 00       jmpq   *0x200c02(%rip)       # 601018 <write@GLIBC_2.2.5>
  400416:   68 00 00 00 00          pushq  $0x0
  40041b:   e9 e0 ff ff ff          jmpq   400400 <.plt>

int main()                              
{
  # objdump -j .rodata -S hello | grep hello
  # 4005e0:       68 65 6c 6c 6f 20 77 6f 72 6c 64 00                 hello world
  ...
  # 将 write 的3个参数写入寄存器。
    write(1, "hello world", strlen("hello world"));
  400531:   ba 0b 00 00 00          mov    $0xb,%edx
  400536:   be e0 05 40 00          mov    $0x4005e0,%esi
  40053b:   bf 01 00 00 00          mov    $0x1,%edi
  # 调用 write 接口。
  400540:   e8 cb fe ff ff          callq  400410 <write@plt>
    return 0;
  ...
}
```

---

### 2.3. 程序运行流程

通过 gdb 调试，查看程序汇编源码，分析程序运行流程，观察系统调用 `syscall` 指令出现的位置。

```shell
# 将 write 函数的参数，写入寄存器进行传递。
B+>|0x400531 <main+4>               mov    $0xb,%edx                                                                |
   |0x400536 <main+9>               mov    $0x4005e0,%esi                                                           |
   |0x40053b <main+14>              mov    $0x1,%edi                                                                |
# 调用 write 函数，通过 PLT（过程链接表）去查找 libc.so 动态库的对应接口。  
   |0x400540 <main+19>              callq  0x400410 <write@plt>                                                     |
   |0x400545 <main+24>              mov    $0x0,%eax                                                                |
   |0x40054a <main+29>              pop    %rbp                                                                     |
   |0x40054b <main+30>              retq

# 链接动态库对应的接口。
   |0x400416 <write@plt+6>          pushq  $0x0                                                                     |
  >|0x40041b <write@plt+11>         jmpq   0x400400

# 进入 libc 动态库源码。
# ../sysdeps/unix/syscall-template.S
B+>|81    T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)                                                 |
   |82    ret                                                                                            |
   |83    T_PSEUDO_END (SYSCALL_SYMBOL)  

#############################
# gdb 在 write 接口设置断点，断点落在 libc 库里。
#############################
(gdb) b write
Breakpoint 2 at 0x7ffff7afca80: file ../sysdeps/unix/syscall-template.S, line 81.
(gdb) c
Continuing.
#############################

B+ |0x7ffff7afca80 <write>                  cmpl   $0x0,0x2dd52d(%rip)        # 0x7ffff7dd9fb4 <__libc_multiple_thre
   00x7ffff7afca87 <write+7>                jne    0x7ffff7afca99 <write+25>                                       |
# 将 write 的系统调用号，填充到 %eax 寄存器（注意：64 位是 %rax 寄存器）。
  >|0x7ffff7afca89 <__write_nocancel>       mov    $0x1,%eax                                                       |
# 执行系统调用，进程工作空间从用户空间转换到内核空间。
   |0x7ffff7afca8e <__write_nocancel+5>     syscall
   |0x7ffff7afca90 <__write_nocancel+7>     cmp    $0xfffffffffffff001,%rax                                        |
   |0x7ffff7afca96 <__write_nocancel+13>    jae    0x7ffff7afcac9 <write+73>                                       |
   |0x7ffff7afca98 <__write_nocancel+15>    retq                                                                   |

#############################
# gdb 查看寄存器数据
#############################
(gdb) info registers
# 系统调用号 1。
rax    0x1              1
# "hello world" 字符串长度。
rdx    0xb              11
# 0x4005e0 是 "hello world" 字符串虚拟地址。
rsi    0x4005e0         4195808
# fd 数值是 1。
rdi    0x1              1
# rip 寄存器记录 syscall 系统调用后返回的地址。
rip    0x7ffff7afca8e   0x7ffff7afca8e <__write_nocancel+5>
#############################
```

---

### 2.4. 系统调用号

在上面 gdb 调试过程中，在 syscall 指令调用前，会先将 write 的系统调用号 1，填充到 %eax 寄存器。

为什么要传递系统调用号到内核呢？因为每个系统调用在内核都有一个对应的处理函数，这个函数指针保存在 `内核的跳转表` 中，这个表是一个数组，而系统调用号就是这个数组的下标，通过下标就能找到对应的系统调用函数。

而用户空间的函数参数也像系统调用号一样，通过写入寄存器传递到内核。

<div align=center><img src="/images/2021-09-15-10-37-15.png" data-action="zoom"/></div>

> 图片来源：《深入理解计算机系统》- 8.1 异常

---

## 3. 内核空间

承接上文，用户空间通过 syscall 指令，从用户空间进入内核空间。

### 3.1. 内核实现函数

系统调用号可以通过寄存器从用户空间传递到内核，那么系统调用号对应的系统调用函数，可以从内核 syscall_64.tbl 文件找到 --> 系统调用号 1 对应的内核实现函数：`__x64_sys_write`。

```shell
# arch/x86/entry/syscalls/syscall_64.tbl
#
# 64-bit system call numbers and entry vectors
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls
#
# The abi is "common", "64" or "x32" for this file.
#
# 系统调用号             系统调用函数     系统调用在内核的实现函数
     0      common        read          __x64_sys_read
     1      common        write         __x64_sys_write
     2      common        open          __x64_sys_open
...
```

---

### 3.2. 内核调试

* 设置断点。在（Linux 5.0.1）内核 `write` 函数下断点，调试跟踪函数的调用堆栈。

```c
/* fs/read_write.c : 610 */
SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
        size_t, count) {
    return ksys_write(fd, buf, count);
}
```

* 调试触发断点。查看函数调用堆栈，可知 syscall 指令触发 `entry_SYSCALL_64` 处理函数。

```shell
__do_sys_write() (/root/linux-5.0.1/fs/read_write.c:610)
__se_sys_write() (/root/linux-5.0.1/fs/read_write.c:607)
__x64_sys_write(const struct pt_regs * regs) (/root/linux-5.0.1/fs/read_write.c:607)
do_syscall_64(unsigned long nr, struct pt_regs * regs) (/root/linux-5.0.1/arch/x86/entry/common.c:290)
entry_SYSCALL_64() (/root/linux-5.0.1/arch/x86/entry/entry_64.S:175)
[Unknown/Just-In-Time compiled code] (Unknown Source:0)
```

> 参考：[vscode + gdb 远程调试 linux (EPOLL) 内核源码](https://www.bilibili.com/video/bv1yo4y1k7QJ)

---

### 3.3. entry_SYSCALL_64

linux 内核启动，初始化 syscall。当调用 syscall 指令时，会从 `MSR_LSTAR` 这个特殊模块寄存器（MSR：Model Specific Registers）里面拿出函数地址来调用，也就是调用 entry_SYSCALL_64。

```shell
start_kernel # init/main.c
|-- trap_init # arch/x86/kernel/traps.c
    |-- cpu_init # arch/x86/kernel/cpu/common.c
        |-- syscall_init # arch/x86/kernel/cpu/common.c
```

```c
/* arch/x86/kernel/cpu/common.c */
void syscall_init(void) {
    ...
    wrmsrl(MSR_LSTAR, (unsigned long)entry_SYSCALL_64);
    ...
}
```

entry_SYSCALL_64 把记录当前进程状态的寄存器数据保存到 struct pt_regs 结构体里，例如：用户态的代码段，数据段，保存参数的寄存器。然后取出保存在 %rax 寄存器的系统调用号，调用 do_syscall_64 函数里的系统跳转表 `sys_call_table` 执行对应的函数。

> 实现的详细流程，可以参考 entry_SYSCALL_64 的源码注释。

```c
/* arch/x86/entry/entry_64.S
 *
 * 64-bit SYSCALL instruction entry. Up to 6 arguments in registers.
 *
 * This is the only entry point used for 64-bit system calls.  The
 * hardware interface is reasonably well designed and the register to
 * argument mapping Linux uses fits well with the registers that are
 * available when SYSCALL is used.
 *
 * SYSCALL instructions can be found inlined in libc implementations as
 * well as some other programs and libraries.  There are also a handful
 * of SYSCALL instructions in the vDSO used, for example, as a
 * clock_gettimeofday fallback.
 *
 * 64-bit SYSCALL saves rip to rcx, clears rflags.RF, then saves rflags to r11,
 * then loads new ss, cs, and rip from previously programmed MSRs.
 * rflags gets masked by a value from another MSR (so CLD and CLAC
 * are not needed). SYSCALL does not save anything on the stack
 * and does not change rsp.
 *
 * Registers on entry:
 * rax  system call number
 * rcx  return address
 * r11  saved rflags (note: r11 is callee-clobbered register in C ABI)
 * rdi  arg0
 * rsi  arg1
 * rdx  arg2
 * r10  arg3 (needs to be moved to rcx to conform to C ABI)
 * r8   arg4
 * r9   arg5
 * (note: r12-r15, rbp, rbx are callee-preserved in C ABI)
 *
 * Only called from user space.
 *
 * When user can change pt_regs->foo always force IRET. That is because
 * it deals with uncanonical addresses better. SYSRET has trouble
 * with them due to bugs in both AMD and Intel CPUs.
 */
ENTRY(entry_SYSCALL_64)
    UNWIND_HINT_EMPTY
    /*
     * Interrupts are off on entry.
     * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,
     * it is too small to ever cause noticeable irq latency.
     */

    swapgs
    /* tss.sp2 is scratch space. */
    movq    %rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)
    SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp
    movq    PER_CPU_VAR(cpu_current_top_of_stack), %rsp

    /* Construct struct pt_regs on stack */
    pushq    $__USER_DS                           /* pt_regs->ss */
    pushq    PER_CPU_VAR(cpu_tss_rw + TSS_sp2)    /* pt_regs->sp */
    pushq    %r11                                 /* pt_regs->flags */
    pushq    $__USER_CS                           /* pt_regs->cs */
    pushq    %rcx                                 /* pt_regs->ip */
GLOBAL(entry_SYSCALL_64_after_hwframe)
    pushq    %rax                                 /* pt_regs->orig_ax */

    PUSH_AND_CLEAR_REGS rax=$-ENOSYS

    TRACE_IRQS_OFF

    /* IRQs are off. 
     * 通过寄存器传递参数到 do_syscall_64。*/
    movq    %rax, %rdi
    movq    %rsp, %rsi
    call    do_syscall_64           /* returns with IRQs disabled */
    ...
END(entry_SYSCALL_64)
```

---

### 3.4. 系统跳转表（sys_call_table）

程序通过系统调用进入内核空间，通过一系列处理，系统调用号有了，系统调用传递的参数已经存储在 struct pt_regs 结构体了，接下来，就要通过 `系统跳转表（sys_call_table）` 找到系统调用号对应的函数，执行逻辑。

```shell
syscall -> entry_SYSCALL_64 -> do_syscall_64 -> sys_call_table -> __x64_sys_write
```

```c
/* arch/x86/entry/common.c */
#ifdef CONFIG_X86_64
__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs) {
    struct thread_info *ti;

    /* 退出用户模式，进入内核模式。 */
    enter_from_user_mode();
    local_irq_enable();
    ti = current_thread_info();
    if (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)
        nr = syscall_trace_enter(regs);

    /*
     * NB: Native and x32 syscalls are dispatched from the same
     * table.  The only functional difference is the x32 bit in
     * regs->orig_ax, which changes the behavior of some syscalls.
     */
    nr &= __SYSCALL_MASK;
    if (likely(nr < NR_syscalls)) {
        nr = array_index_nospec(nr, NR_syscalls);
        /* 通过系统调用跳转表，调用系统调用号对应的函数。
         * 函数返回值保存在 regs->ax 里，最后将这个值，保存到 rax 寄存器传递到用户空间。 */
        regs->ax = sys_call_table[nr](regs);
    }

    syscall_return_slowpath(regs);
}
#endif
```

* 系统调用接口实现，`write` 系统接口，在内核里最终实现是 `__x64_sys_write`，这样 `SYSCALL_DEFINE3` 宏，封装了一系列操作，目的只有两个：
  
  1. 将 write 转变为 __x64_sys_write。
  2. 将 `struct pt_regs` 保存的寄存器数据，转变为 __x64_sys_write 函数的参数。

  这样一个 __x64_sys_write(...) 函数，就通过通用的宏 SYSCALL_DEFINE3，转化出来。

  > 流程：write --> syscall --> __x64_sys_write

```shell
# arch/x86/entry/syscalls/syscall_64.tbl
#
# 64-bit system call numbers and entry vectors
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls
#
# The abi is "common", "64" or "x32" for this file.
#
# 系统调用号             系统调用函数     系统调用在内核的实现函数
...
     1      common        write         __x64_sys_write
...
```

```c
/* arch/x86/include/generated/asm/syscalls_64.h */
#ifdef CONFIG_X86
__SYSCALL_64(0, __x64_sys_read, )
#else /* CONFIG_UML */
__SYSCALL_64(0, sys_read, )
#endif
#ifdef CONFIG_X86
__SYSCALL_64(1, __x64_sys_write, )
#else /* CONFIG_UML */
__SYSCALL_64(1, sys_write, )
#endif

/* arch/x86/entry/syscall_64.c */
#define __SYSCALL_64(nr, sym, qual) [nr] = sym,

asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
    /*
     * Smells like a compiler bug -- it doesn't work
     * when the & below is removed.
     */
    [0 ... __NR_syscall_max] = &sys_ni_syscall,
#include <asm/syscalls_64.h>
};
```

```c
asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
    /*
     * Smells like a compiler bug -- it doesn't work
     * when the & below is removed.
     */
    [0 ... __NR_syscall_max] = &sys_ni_syscall,
    [1] = __x64_sys_read,
    [2] = __x64_sys_write,
    ...
};
```

```c
/* include/linux/syscalls.h */
#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)

#define SYSCALL_DEFINEx(x, sname, ...)                \
    SYSCALL_METADATA(sname, x, __VA_ARGS__)           \
    __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)

/* arch/x86/include/asm/syscall_wrapper.h */
#define __SYSCALL_DEFINEx(x, name, ...)                                \
    asmlinkage long __x64_sys##name(const struct pt_regs *regs);       \
    ALLOW_ERROR_INJECTION(__x64_sys##name, ERRNO);                     \
    static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));        \
    static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__)); \
    asmlinkage long __x64_sys##name(const struct pt_regs *regs)        \
    {                                                                  \
        return __se_sys##name(SC_X86_64_REGS_TO_ARGS(x,__VA_ARGS__));  \
    }                                                                  \
    __IA32_SYS_STUBx(x, name, __VA_ARGS__)                             \
    static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))         \
    {                                                                  \
        long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));     \
        __MAP(x,__SC_TEST,__VA_ARGS__);                                \
        __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));              \
        return ret;                                                    \
    }                                                                  \
    static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))


/* fs/read_write.c */
SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
        size_t, count) {
    return ksys_write(fd, buf, count);
}
```

---

## 4. 参考

* 《Linux 内核设计与实现》
* 《深入理解计算机系统》
* [一文让你明白CPU上下文切换](https://segmentfault.com/a/1190000017457234#comment-area)
* [ctf中关于syscall系统调用的简单分析](https://zhuanlan.zhihu.com/p/106014234)
* [09 \| 系统调用：公司成立好了就要开始接项目](https://www.codenong.com/cs109190055/)
* [使用objdump查看动态库和静态库中具有哪些函数](https://blog.csdn.net/tao546377318/article/details/51727696)