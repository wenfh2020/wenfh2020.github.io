---
layout: post
title:  "[redis æºç èµ°è¯»] å­—ç¬¦ä¸²(sds)"
categories: redis
tags: redis sds
author: wenfh2020
---

ä¸ºäº†èŠ‚çœå†…å­˜ç©ºé—´ï¼Œçµæ´»å¤„ç†ä¸åŒé•¿åº¦èŒƒå›´çš„å­—ç¬¦ä¸²ï¼Œredis å®šä¹‰äº†å‡ ç§ `sdshdr(X)` æ•°æ®ç»“æ„ï¼Œå¯¹ä¸åŒé•¿åº¦çš„å­—ç¬¦ä¸²æ•°æ®è¿›è¡Œå­˜å‚¨ã€‚



* content
{:toc}

## 1. æ•°æ®ç»“æ„

![æ•°æ®ç»“æ„å†…å­˜](/images/2020-02-20-16-48-09.png){: data-action="zoom"}

ä¸ºäº†èŠ‚çœå†…å­˜ç©ºé—´ï¼Œçµæ´»å¤„ç†ä¸åŒé•¿åº¦èŒƒå›´çš„å­—ç¬¦ä¸²

* redis å®šä¹‰äº†`sdshdr(X)`å‡ ç§æ•°æ®ç»“æ„ï¼Œå¯ä»¥æŸ¥çœ‹`æ•°æ®ç»“æ„å¤§å°`ã€‚
* åŒæ—¶ struct æ•°æ®ç»“æ„æ²¡æœ‰è¿›è¡Œå†…å­˜å¯¹é½ã€‚

```c
typedef char *sds;
#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));

/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */
struct __attribute__ ((__packed__)) sdshdr5 {
    // å½“å­—ç¬¦ä¸²å¾ˆå°æ—¶ï¼Œ `flags` æ˜¯ä¸€ä¸ª8 ä¸ªå­—èŠ‚çš„ç»„åˆå­—ç¬¦ï¼Œå‰ 3 bit æ˜¯å­—ç¬¦ä¸²ç±»å‹ï¼Œåé¢5bitæ˜¯å­—ç¬¦ä¸²é•¿åº¦ã€‚
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

| æˆå‘˜  | æè¿°                                                          |
| :---- | :------------------------------------------------------------ |
| len   | å½“å‰å·²ä½¿ç”¨çš„å†…å­˜ç©ºé—´é•¿åº¦                                      |
| alloc | åˆ†é…çš„å†…å­˜ç©ºé—´é•¿åº¦                                            |
| flags | æ•°æ®ç»“æ„ç±»å‹ æˆ–è€… ï¼ˆæ•°æ®ç»“æ„ç±»å‹ + å­—ç¬¦ä¸²é•¿åº¦ ä¾‹å¦‚ï¼šsdshdr5ï¼‰ |
| buf   | uf å¦‚æœæœ‰æ•°æ®ï¼Œæ˜¯ä»¥ '\0' ç»“æŸçš„å­—ç¬¦ä¸²ã€‚                       |

### 1.1. sds æ•°æ®ç»“æ„è§†å›¾

![æ•°æ®ç»“æ„å†…å­˜](/images/2020-02-20-16-48-09.png){: data-action="zoom"}

> åˆ¶ä½œå›¾è¡¨æ–¹æ³•å¯ä»¥ç”¨ processonï¼Œå‚è€ƒè§†é¢‘
>
> * bilibili: [ç»˜åˆ¶ redis sds æ•°æ®ç»“æ„å†…å­˜ç©ºé—´è§†å›¾](https://www.bilibili.com/video/av83487454/)
> * youtube: [Draw Redis SDS Struct Memmory Chart](https://youtu.be/eT_qW3-q8no)


### 1.2. ç»“æ„å¤§å°

å¯ä»¥é€šè¿‡å‡½æ•° `sdsReqType` çŸ¥é“ï¼Œsds æ•°æ®ç»“æ„ï¼Œæ˜¯æ ¹æ®æ•°æ®é•¿åº¦èŒƒå›´å»ç¡®å®šæ•°æ®ç»“æ„ç±»å‹çš„ã€‚ä¸‹é¢åˆ—å‡ºçš„æ•°æ®ç»“æ„çš„æ¯”è¾ƒã€‚

| ç»“æ„ç±»å‹ | å¤§å° | å­—ç¬¦ä¸²é•¿åº¦   |
| :------- | :--- | :----------- |
| sdshdr5  | 1    | 1 << 5 - 1   |
| sdshdr8  | 3    | 1 << 8 - 1   |
| sdshdr16 | 5    | 1 << 16 - 1  |
| sdshdr32 | 9    | 1 << 32 - 1  |
| sdshdr64 | 17   | å¤§äº 1 << 32 |

```c
static inline char sdsReqType(size_t string_size) {
    if (string_size < 1<<5)
        // 1 << 5 == 32ï¼Œæ‰€ä»¥é•¿åº¦æœ€å¤§ 31ï¼ŒäºŒè¿›åˆ¶ 11111ï¼Œå  5 ä½ã€‚ç»“åˆæ•°æ®ç»“æ„å¯ä»¥æŸ¥çœ‹ flags çš„ç»„åˆï¼Œå·¦ç§» 5 ä½ï¼Œå­˜å‚¨å­—ç¬¦ä¸²é•¿åº¦ï¼Œå³è¾¹3ä½å­˜å‚¨å­—ç¬¦ä¸²é•¿åº¦ã€‚
        return SDS_TYPE_5;
    if (string_size < 1<<8)
        return SDS_TYPE_8;
    if (string_size < 1<<16)
        return SDS_TYPE_16;
#if (LONG_MAX == LLONG_MAX)
    if (string_size < 1ll<<32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
#else
    return SDS_TYPE_32;
#endif
}
```

* ä¾‹å¦‚ sdshdr32 æ•°æ®ç»“æ„ï¼Œ sizeof(sdshdr32) == 9 ï¼Œå¦‚æœæ˜¯å­—èŠ‚å¯¹é½ï¼Œåº”è¯¥ 12 æ‰å¯¹ã€‚

```c
struct __attribute__((__packed__)) sdshdr32 {
    uint32_t len;        /* used */
    uint32_t alloc;      /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

---

## 2. æ ¸å¿ƒæ¥å£

sds ä¸»è¦çš„é€»è¾‘æ˜¯å¯¹å­—ç¬¦ä¸²å†…å­˜ç®¡ç†ã€‚å¯ä»¥å‚è€ƒä¸‹é¢æ¥å£è¿›è¡Œç†è§£ã€‚

| æ¥å£           | æè¿°                                                                              |
| :------------- | :-------------------------------------------------------------------------------- |
| sdsnew         | åˆ›å»ºå­—ç¬¦ä¸²å¯¹è±¡                                                                    |
| sdsfree        | é‡Šæ”¾å­—ç¬¦ä¸²ç»“æ„å¯¹è±¡                                                                |
| sdsavail       | æŸ¥è¯¢å­—ç¬¦ä¸²å¯¹è±¡ç©ºé—²å†…å­˜å¤§å°                                                        |
| sdsnewlen      | æ ¹æ®å­—ç¬¦ä¸²é•¿åº¦ï¼Œåˆ†é…åˆé€‚çš„å†…å­˜ç©ºé—´ï¼Œè®¾ç½®æ•°æ®ç»“æ„çš„ç›¸å…³çš„æˆå‘˜æ•°æ®                  |
| sdsMakeRoomFor | ä¸ºå¯¹è±¡åˆ†é…å¢é•¿çš„ç©ºé—´ï¼Œå¢é•¿å°äº 1Mï¼Œ newlen *= 2ï¼Œå¦åˆ™  newlen += SDS_MAX_PREALLOC |

---

## 3. å·¥ä½œæµç¨‹

æˆ‘ä»¬ä¾æ—§å¯ä»¥ç”¨ gdb å¯¹ sds è¿›è¡Œè°ƒè¯•ï¼Œç†Ÿæ‚‰å®ƒå¯¹å·¥ä½œæµç¨‹ã€‚ä½œè€…åœ¨ sds.c æ–‡ä»¶å°±è®¾ç½®äº†æµ‹è¯•å®`SDS_TEST_MAIN`ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–è¯‘ä¸€ä¸ªæ–‡ä»¶è¿›è¡Œè°ƒè¯•ã€‚

```shell
gcc -g  -DSDS_TEST_MAIN sds.c zmalloc.c -o sds
```

> è°ƒè¯•æ–¹æ³•ï¼Œå¯ä»¥å‚è€ƒè§†é¢‘
>
> * bilibili: [Debug Redis sds with Gdb](https://www.bilibili.com/video/av83332533/)
> * youtube: [Debug Redis sds with Gdb](https://youtu.be/_buPUWclhU0)

* å †æ ˆä¿¡æ¯

```shell
#0  sdsnewlen (init=0x100006a71, initlen=3) at sds.c:99
#1  0x00000001000018a6 in sdsnew (init=0x100006a71 "foo") at sds.c:156
#2  0x0000000100004cb7 in sdsTest () at sds.c:1130
#3  0x0000000100006124 in main () at sds.c:1294
```

* sdsnewlen æ ¹æ®å­—ç¬¦ä¸²é•¿åº¦ï¼Œç”¨ä¸åŒæ•°æ®ç»“æ„è¿›è¡Œå­˜å‚¨ï¼Œæ¯ä¸ªæ•°æ®ç»“æ„æœ‰ä¸åŒç±»å‹ã€‚

```c
/* Create a new sds string starting from a null terminated C string. */
sds sdsnew(const char *init) {
    size_t initlen = (init == NULL) ? 0 : strlen(init);
    return sdsnewlen(init, initlen);
}
```

* æ ¹æ®å­—ç¬¦ä¸²é•¿åº¦ï¼Œåˆ†é…åˆé€‚çš„å†…å­˜ç©ºé—´ï¼Œè®¾ç½®æ•°æ®ç»“æ„çš„ç›¸å…³çš„æˆå‘˜æ•°æ® 

```c
/* Create a new sds string with the content specified by the 'init' pointer
 * and 'initlen'.
 * If NULL is used for 'init' the string is initialized with zero bytes.
 * If SDS_NOINIT is used, the buffer is left uninitialized;
 *
 * The string is always null-termined (all the sds strings are, always) so
 * even if you create an sds string with:
 *
 * mystring = sdsnewlen("abc",3);
 *
 * You can print the string with printf() as there is an implicit \0 at the
 * end of the string. However the string is binary safe and can contain
 * \0 characters in the middle, as the length is stored in the sds header. */
sds sdsnewlen(const void *init, size_t initlen) {
    void *sh;
    sds s;
    char type = sdsReqType(initlen);
    /* Empty strings are usually created in order to append. Use type 8
     * since type 5 is not good at this. */
    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
    int hdrlen = sdsHdrSize(type);
    unsigned char *fp; /* flags pointer. */

    // ç”³è¯·æ•°æ®ç»“æ„å†…å­˜ã€‚+ 1 æ˜¯ä¸ºäº†å­—ç¬¦ä¸²çš„ç»“æŸç¬¦ '\0'ã€‚
    sh = s_malloc(hdrlen+initlen+1);
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
        memset(sh, 0, hdrlen+initlen+1);
    if (sh == NULL) return NULL;
    s = (char*)sh+hdrlen;
    fp = ((unsigned char*)s)-1;
    switch(type) {
        case SDS_TYPE_5: {
            // SDS_TYPE_BITS 
            *fp = type | (initlen << SDS_TYPE_BITS);
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
    }
    if (initlen && init)
        memcpy(s, init, initlen);
    s[initlen] = '\0';
    return s;
}
```

* è·å–å­—ç¬¦ä¸²é•¿åº¦

```c
#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)

static inline size_t sdslen(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            // ä¸€ä¸ªå­—èŠ‚é«˜ 5 ä½æ˜¯é•¿åº¦ï¼Œé€šè¿‡å‘å³ç§»åŠ¨ 3 ä½è·å¾—å¤§å°ã€‚
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->len;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->len;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->len;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->len;
    }
    return 0;
}
```

* é‡Šæ”¾å†…å­˜ï¼Œå› ä¸º sds struct æ˜¯ä¸€ä¸ªè¿ç»­çš„å†…å­˜æ•°æ®ç»“æ„ï¼Œæ ¹æ® sds æŒ‡å‘çš„ bufï¼Œå¾€å›æ‰¾ struct çš„èµ·å§‹åœ°å€ï¼Œè¿›è¡Œé‡Šæ”¾ã€‚

> çœ‹çœ‹ `sdsnewlen` æ˜¯å¦‚ä½•ç”³è¯·å†…å­˜çš„ã€‚

```c
/* Free an sds string. No operation is performed if 's' is NULL. */
void sdsfree(sds s) {
    if (s == NULL) return;
    s_free((char*)s-sdsHdrSize(s[-1]));
}
```

```c
static inline int sdsHdrSize(char type) {
    switch(type&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return sizeof(struct sdshdr5);
        case SDS_TYPE_8:
            return sizeof(struct sdshdr8);
        case SDS_TYPE_16:
            return sizeof(struct sdshdr16);
        case SDS_TYPE_32:
            return sizeof(struct sdshdr32);
        case SDS_TYPE_64:
            return sizeof(struct sdshdr64);
    }
    return 0;
}
```

* æŸ¥è¯¢æ•°æ®ç»“æ„å¤šå°‘ç©ºé—²å†…å­˜ç©ºé—´

```c
static inline size_t sdsavail(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5: {
            // å°äº 32 é•¿åº¦çš„å†…å­˜ï¼Œéƒ½æ˜¯ç›´æ¥ç”³è¯·çš„ï¼Œæ²¡æœ‰ç©ºä½™å†…å­˜ã€‚
            return 0;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            return sh->alloc - sh->len;
        }
    }
    return 0;
}
```

* è¿½åŠ å†…å­˜

```c
/* Append the specified null termianted C string to the sds string 's'.
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call. */
sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}
```

* redis sds ä¹ æƒ¯å…ˆæ ¹æ®é•¿åº¦ï¼Œåˆ†é…åˆé€‚çš„å†…å­˜ï¼Œå†è¿›è¡Œæ•°æ®æ‹·è´ç­‰æ“ä½œã€‚

```c
/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the
 * end of the specified sds string 's'.
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call. */
sds sdscatlen(sds s, const void *t, size_t len) {
    size_t curlen = sdslen(s);

    // æ ¹æ®å½“å‰æ•°æ®å’Œè¿½åŠ çš„æ•°æ®ï¼Œåˆ†é…åˆé€‚é•¿åº¦çš„å†…å­˜èµ„æºã€‚
    s = sdsMakeRoomFor(s,len);
    if (s == NULL) return NULL;
    memcpy(s+curlen, t, len);
    sdssetlen(s, curlen+len);
    s[curlen+len] = '\0';
    return s;
}
```

* æ ¹æ®å¢é•¿çš„é•¿åº¦ï¼Œä¸º sds ç”³è¯·åˆé€‚é•¿åº¦çš„ç©ºé—´ã€‚

```c
/* Enlarge the free space at the end of the sds string so that the caller
 * is sure that after calling this function can overwrite up to addlen
 * bytes after the end of the string, plus one more byte for nul term.
 *
 * Note: this does not change the *length* of the sds string as returned
 * by sdslen(), but only the free buffer space we have. */
sds sdsMakeRoomFor(sds s, size_t addlen) {
    void *sh, *newsh;
    // è·å–å‰©ä½™çš„å†…å­˜
    size_t avail = sdsavail(s);
    size_t len, newlen;
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen;

    /* Return ASAP if there is enough space left. */
    if (avail >= addlen) return s;

    len = sdslen(s);
    sh = (char*)s-sdsHdrSize(oldtype);
    newlen = (len+addlen);
    // å°äº 1 M å†…å­˜çš„ç¿»å€å¢åŠ ï¼Œå¦åˆ™æ¯æ¬¡å¢åŠ  1M
    if (newlen < SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        newlen += SDS_MAX_PREALLOC;

    type = sdsReqType(newlen);

    // å¦‚æœå°æ•°æ®ï¼Œé‡åˆ° cat æ“ä½œï¼Œç±»å‹å‡çº§åˆ° SDS_TYPE_8ï¼Œæ–¹ä¾¿ cat çš„åç»­æ“ä½œã€‚è¿™é‡Œä½œè€…ä¼°è®¡æ˜¯æ ¹æ®å¾ˆå¤šåœºæ™¯ç»“åˆçš„ç»éªŒå¾—å‡ºçš„ç»“è®ºã€‚
    /* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;

    // æ ¹æ®å¯¹åº”ç±»å‹çš„å¯¹è±¡ç”³è¯·ç›¸åº”çš„ç©ºé—´ã€‚
    hdrlen = sdsHdrSize(type);
    if (oldtype==type) {
        newsh = s_realloc(sh, hdrlen+newlen+1);
        if (newsh == NULL) return NULL;
        s = (char*)newsh+hdrlen;
    } else {
        /* Since the header size changes, need to move the string forward,
         * and can't use realloc */
        newsh = s_malloc(hdrlen+newlen+1);
        if (newsh == NULL) return NULL;
        memcpy((char*)newsh+hdrlen, s, len+1);
        s_free(sh);
        s = (char*)newsh+hdrlen;
        s[-1] = type;
        sdssetlen(s, len);
    }
    sdssetalloc(s, newlen);
    return s;
}
```

* ç©ºæ•°æ®ç»“æ„ `sdsempty()`ï¼Œä¸€äº›ä¸å®šé•¿çš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ `sdscatprintf`ï¼Œæ ¼å¼åŒ–çš„å­—ç¬¦ä¸²ï¼Œç»å¸¸æ€§æœ‰å¾ˆé•¿çš„å­—ç¬¦ä¸²ã€‚æ‰€ä»¥åœ¨ `sdsnewlen` ä¸­ç»™ç”³è¯· `SDS_TYPE_8` ç±»å‹è¿›è¡Œå¤„ç†ã€‚

```c
sds sdsnewlen(const void *init, size_t initlen) {
    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
}
```

* å»æ‰å­—ç¬¦ä¸²å¤´å°¾å‡ºç°åœ¨å­—ä¸²çš„æ‰€æœ‰å­—ç¬¦

```c
/* Remove the part of the string from left and from right composed just of
 * contiguous characters found in 'cset', that is a null terminted C string.
 *
 * After the call, the modified sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 *
 * Example:
 *
 * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");
 * s = sdstrim(s,"Aa. :");
 * printf("%s\n", s);
 *
 * Output will be just "HelloWorld".
 */
sds sdstrim(sds s, const char *cset) {
    char *start, *end, *sp, *ep;
    size_t len;

    // é€šè¿‡ä¸¤æ¬¡éå†ï¼Œä»å¤´å‘å°¾ï¼Œ
    sp = start = s;
    ep = end = s+sdslen(s)-1;
    while(sp <= end && strchr(cset, *sp)) sp++;
    while(ep > sp && strchr(cset, *ep)) ep--;
    len = (sp > ep) ? 0 : ((ep-sp)+1);
    if (s != sp) memmove(s, sp, len);
    s[len] = '\0';
    sdssetlen(s,len);
    return s;
}
```

* ä¸¤ä¸ª sds å­—ç¬¦ä¸²æ¯”è¾ƒ

> å–æœ€çŸ­å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œè¯¥é•¿åº¦çš„ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸æ¯”è¾ƒï¼Œåœ¨è¿™ä¸ªæ¡ä»¶åŸºç¡€ä¸Šï¼Œå¯¹ä½™ä¸‹å­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒã€‚è¿”å›ç›¸åº”ç»“æœã€‚

```c
/* Compare two sds strings s1 and s2 with memcmp().
 *
 * Return value:
 *
 *     positive if s1 > s2.
 *     negative if s1 < s2.
 *     0 if s1 and s2 are exactly the same binary string.
 *
 * If two strings share exactly the same prefix, but one of the two has
 * additional characters, the longer string is considered to be greater than
 * the smaller one. */
int sdscmp(const sds s1, const sds s2) {
    size_t l1, l2, minlen;
    int cmp;

    l1 = sdslen(s1);
    l2 = sdslen(s2);
    minlen = (l1 < l2) ? l1 : l2;
    cmp = memcmp(s1, s2, minlen);
    if (cmp == 0) return l1 > l2 ? 1 : (l1 < l2 ? -1 : 0);
    return cmp;
}
```

---

## 4. åè®°

æºç èµ°è¯»ç³»åˆ—ï¼Œé€šè¿‡è°ƒè¯•æ‰‹æ®µï¼Œèµ°è¯»æºç ï¼Œæ˜¯è‡ªå·±æµæ°´è´¦å¼çš„è®°å½•ï¼Œä»è€Œç†è§£äº†æ›´å¤šçš„å®ç°ç»†èŠ‚ã€‚

---

> ğŸ”¥ æ–‡ç« æ¥æºï¼š[wenfh2020.com](https://wenfh2020.com/)
>
> ğŸ‘ å¤§å®¶è§‰å¾—æ–‡ç« å¯¹ä½ æœ‰äº›ä½œç”¨ï¼ å¦‚æœæƒ³ <font color=green>èµèµ</font>ï¼Œå¯ä»¥ç”¨å¾®ä¿¡æ‰«æä¸‹é¢çš„äºŒç»´ç ï¼Œæ„Ÿè°¢!
<div align=center><img src="/images/2020-08-06-15-49-47.png" width="120"/></div>
