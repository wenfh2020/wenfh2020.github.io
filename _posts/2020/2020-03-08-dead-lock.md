---
layout: post
title:  "剖析嵌套式死锁问题"
categories: 技术
tags: dead lock
author: wenfh2020
---

在多线程模型中，锁是一个复杂的东西，即便老司机也经常会翻车。

锁是配对出现的。锁上了，就要解锁，忘记解锁会产生死锁，一般这种低级错误很容易避免，然而在复杂的业务体系中，往往会产生嵌套式死锁问题，而这个问题藏得很深。



* content
{:toc}

---

## 1. 嵌套死锁理解

嵌套式死锁：系统中存在多个锁，跨线程相互调用。

下面伪代码，展示两个线程同时运行，极有可能产生嵌套死锁问题。

<div align=center><img src="/images/2023-07-09-21-21-52.png" data-action="zoom"></div>

> 设计图来源：《[嵌套式死锁原理](https://www.processon.com/view/5aa09cd3e4b0805a7f250f86)》
>

---

## 2. 测试

### 2.1. Demo

根据上述分析，写个简单的 Demo 演示一下（详细源码已上传 [Github](https://github.com/wenfh2020/c_test/blob/master/normal/thread/deadlock)）。

<div align=center><img src="/images/2023-07-09-16-54-41.png" data-action="zoom"></div>

* a.cpp

```cpp
void A::funcA1() {
    std::lock_guard<std::mutex> lck(m_mtx);
    std::shared_ptr<B> p(m_obj_b.lock());
    if (p) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        p->funcB2();
    }
}

void A::funcA2() {
    std::lock_guard<std::mutex> lck(m_mtx);
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
```

* b.cpp

```cpp
void B::funcB1() {
    std::lock_guard<std::mutex> lck(m_mtx);
    std::shared_ptr<A> p(m_obj_a.lock());
    if (p) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        p->funcA2();
    }
}

void B::funcB2() {
    std::lock_guard<std::mutex> lck(m_mtx);
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
```

* test.cpp

```cpp
//  g++ -std='c++11' a.cpp b.cpp test.cpp -lpthread -o t  && ./t

void thread_func1(std::shared_ptr<A> obj) {
    obj->funcA1();
}

void thread_func2(std::shared_ptr<B> obj) {
    obj->funcB1();
}

int main() {
    auto obj_a = std::make_shared<A>();
    auto obj_b = std::make_shared<B>();
    obj_a->setObjB(obj_b);
    obj_b->setObjA(obj_a);

    std::thread t1(thread_func1, obj_a);
    std::thread t2(thread_func2, obj_b);
    t1.join();
    t2.join();
    std::cout << "finished!" << std::endl;
    return 0;
}
```

---

### 2.2. Gdb 分析

通过 Gdb 工具绑定死锁进程，然后查看死锁程序函数堆栈。

```shell
(gdb) thread apply all bt

Thread 3 (Thread 0x7f97f6cb8700 (LWP 31706)):
#0  __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007f97f78b0e9b in _L_lock_883 () from /lib64/libpthread.so.0
#2  0x00007f97f78b0d68 in __GI___pthread_mutex_lock (mutex=0x2550088)
    at ../nptl/pthread_mutex_lock.c:78
#3  0x0000000000401248 in __gthread_mutex_lock(pthread_mutex_t*) ()
#4  0x0000000000401618 in std::mutex::lock() ()
#5  0x0000000000401708 in std::lock_guard<std::mutex>::lock_guard(std::mutex&) ()
#6  0x0000000000401c82 in B::funcB2() ()
#7  0x00000000004013ff in A::funcA1() ()
#8  0x000000000040201f in thread_func1(std::shared_ptr<A>) ()
...

Thread 2 (Thread 0x7f97f64b7700 (LWP 31708)):
#0  __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007f97f78b0e9b in _L_lock_883 () from /lib64/libpthread.so.0
#2  0x00007f97f78b0d68 in __GI___pthread_mutex_lock (mutex=0x2550028)
    at ../nptl/pthread_mutex_lock.c:78
#3  0x0000000000401248 in __gthread_mutex_lock(pthread_mutex_t*) ()
#4  0x0000000000401618 in std::mutex::lock() ()
#5  0x0000000000401708 in std::lock_guard<std::mutex>::lock_guard(std::mutex&) ()
#6  0x0000000000401328 in A::funcA2() ()
#7  0x0000000000401c1b in B::funcB1() ()
#8  0x0000000000402041 in thread_func2(std::shared_ptr<B>) ()
...
```

---

## 3. 小结

* 在一个功能单元里，尽量不要调用有其它锁的函数。
* 锁的粒度尽量小，锁是锁数据的，不是锁逻辑。在一个函数里，函数入口加锁，函数退出解锁，这种操作看似方便，其实隐藏了很多问题。假如锁住了插入数据库语句逻辑，刚好这个数据库堵了，那么整个多线程系统有可能卡在这里。
* 可见 `nginx` 和 `redis` 为什么主逻辑都在单进程单线程里实现，单线程最大的好处是避开了锁带来的复杂度。
