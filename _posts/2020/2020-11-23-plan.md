---
layout: post
title:  "工作计划"
categories: tool
tags: tmux usage
author: wenfh2020
---

每天到自习室。
每天不要发脾气。

动手做事，时间过得比较快。只是看知识的话，时间过得特别慢。

整理工作目标，计划，问题；--> 聚焦 + 基础 + 时间 + 实践 + 方法论。

短期目标：分布式理论实践，高性能框架，让工作变得更简单。





* content
{:toc}

---

## 1. 当前工作

* [ ] connect，accept，write，read 非阻塞作用。
* [ ] SO_REUSEPORT 是如何解决 epoll 惊群问题的。[从linux源码看epoll](https://my.oschina.net/alchemystar/blog/3008840)
* [ ] 惊群问题处理。[全网惊群本质最透彻的分析](https://zhuanlan.zhihu.com/p/351065391)
* [ ] 调试多线程切换原理。
* [ ] 处理 select
* [ ] 做 epoll 实现原理视频。

---

* [ ] close 是如何回收 fd 的（close 后会回收 fd，但是文件数据的清理，要看 f_count 了是否有引用）。
* [ ] shutdown, redis 退出时策略。
* [ ] 软件中断后，是如何唤醒进程的。（需要理解中断原理，睡眠的进程会被中断唤醒，例如 epoll_wait。）
* [ ] socket 接口的理解。
* [ ] listen backlog 作用。
* [ ] write / read 和 recv / send 区别。
* [ ] bind 有啥作用。
* [ ] read == 0 是什么时候调用的。

---

* [ ] libco http 功能。 - 2 天。
* [ ] 调整负载信息。（读写数据，负载内容，统计协程个数。） - 1 天。
* [ ] libco 节点转发效率。（7 天，锁，参考 redis 多线程。） - 7 天。
* [ ] 将 socket buffer 层修改为 sds。 - 3 天。
* [ ] [task_struct](https://kernel.blog.csdn.net/article/details/51383272#comments_15735257)

---

* [ ] libco 测试 codis。（从 codis 去了解 zookeeper 的通信逻辑。）（7 天）
* [ ] mysql 使用效率总结。（[大厂如何解决mysql读写效率问题](https://www.bilibili.com/video/BV1nz4y1m7TX)）（3 天）
* [ ] libco 测试数据库 [kingshard](http://xiaorui.cc/archives/2795)，处理读写分离。（3 天）

---

* [ ] socket 的关闭和创建。（参考 redis，参考 Linux 内核源代码情景分析。 ）
* [ ] redis 连接池添加回收机制。
* [ ] mysql 连接池支持 last_id。
* [ ] 写 im 压力测试。

---

* [ ] libco send / write 效率问题。
* [ ] 检查配置加载模块。
* [ ] co_kimserver socketpair 关闭问题。
* [ ] libco 锁的工作原理。

---

* [ ] nginx 切换方案。(nginx-upsync-module 处理 http 切换，后面在做 http 切换的时候可以用。)

---

* [ ] 查看 redis 的 client 是什么时候关闭的。（绝大部分是延时关闭的，例如读数据失败不会 close，因为还有写。）
* [ ] 节点支持 disable，删除节点。（先做简单实现功能。sleep）
* [ ] 删除节点对整个系统的影响。
* [x] 数据转发超时处理。(超时时间设置大一点。)
* [x] 数据转发 seq 校验。（不需要校验 seq，因为转发是同步发的，多个 socket 达到并发效果，一个请求一个应答方式，只会出现超时，超时了有两种可能，B 节点处理慢，或故障丢包，这样重新发送已经没意义，出现问题，断掉连接重新处理。）

---

* [ ] cmake 打包方法。
* [ ] 线程和进程的区别，内核源码阅读。
* [ ] malloc 内存分配流程，内核源码阅读。
* [ ] accept 和 listen 内部实现。

---

### 1.1. 协程

* [ ] libco 测试 kafka。
* [ ] golang / python 协程。

---

## 2. 目标

python 协程，golang 协程。用 libco 作为 c++ 作为手段，处理 zookeeper 和 kafka。

* [ ] 打通整个系统工作流程。
* [ ] raft 算法。
* [ ] redis 集群原理。
* [ ] zookeeper 算法。
* [ ] 数据库索引原理。
* [ ] 数据库主从同步，数据一致性解决方案。
* [ ] 数据库代理功能原理。
* [ ] [分布式算法](https://www.bilibili.com/video/BV1TW411M7Fx?from=search&seid=17518808748339724468)

---

* [ ] elk 分布式日志管理。
* [ ] nginx 切换集群。(etcd + nginx第三方模块(nginx-upsync-module)的方式来实现nginx零重启更新upstream的操作。)
* [ ] kafka。
* [ ] kimserver 节点连接失败后，缓存被清除，没有返回对应错误个数。

---

### 2.1. kimserver

* [ ] 后台修改配置生效。
* [ ] 优化状态机使用。
* [ ] 未经账号验证的客户端连接发送数据过来，直接断开。
* [ ] 转发功能。

---

### 2.2. 小步

* [ ] django 框架。
* [ ] 协程框架。
* [ ] beego 管理后台框架。

---

## 3. 工作

### 3.1. 2020-12

* [ ] kingshard 搭建。
* [ ] codis 框架搭建。
* [ ] nginx 工作流程。（反向代理，静态网站文件服务，负载均衡。）
* [ ] redis，mysql 异步处理。
* [ ] 测试 mysql 索引，explain，slowlog，等功能。
* [ ] zookeeper 原理。

---

* [ ] 优化状态机。
* [ ] raft 算法。
* [ ] zookeeper 原理。
* [ ] redis 集群文章。

---

## 4. kimserver

### 4.1. wating

* [ ] 接 websocket。
* [ ] 分布式日志查询。
* [ ] zk_client 线程退出处理。
* [ ] nginx 工作流程。[反向代理调试](https://blog.csdn.net/cjd6568358/article/details/51871039)。

---

* [ ] kimserver 转发功能。
* [ ] 虚函数的继承顺序。
* [ ] 数据拷贝优化。
* [ ] 限流。
* [ ] kimserver 命令更新配置文件。
* [ ] kimserver so module.

---

### 4.2. 文章

* [ ] kimserver 架构。
* [ ] so 高可用，99%。
* [ ] module cmd 逻辑。
* [ ] shell 执行 redis 命令。

---

## 5. 其它

* [ ] 基础复习。
* [ ] 小步复习。
* [ ] 数据库总结。
* [ ] kafka 学习。
* [ ] stl 源码走读(数组，map)。
* [ ] 二叉树。
* [ ] B+ 树。

---

### 5.1. done

#### 5.1.1. 2021-07

* [x] 《UNIX 网络编程卷 1》
* [x] 走读内核源码，socket 的实现。

---

#### 5.1.2. 2021-06

* [x] vscode 调试视频（把声音处理好）。
* [x] 优化好 epoll demo，能独立的程序进行调试。
* [x] 调试 epoll 底层。
* [x] 《网络是如何连接的》和 《图解 TCP_IP》。

---

#### 5.1.3. 2021-05

* [x] 搭建内核调试环境（[gdb 调试 Linux 内核网络源码](https://www.bilibili.com/video/bv1cq4y1E79C)）。

---

#### 5.1.4. 2021-04

* [x] 走读 glibc 源码，熟悉 malloc / free 的工作流程。（基本搞清楚流程了。可以参考 [深入理解 malloc](https://hanfeng.ink/post/understand_glibc_malloc/)，[Glibc内存管理-ptmalloc2](https://www.cnblogs.com/mysky007/p/12349508.html)，[glibc内存管理ptmalloc源代码分析.pdf](https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf)）
* [x] 搭建 glibc 调试。（已经整理成视频。）
* [x] 漫游计算机工作流程。(参考：学习 Linux 内存分配)
* [x] 内存伙伴算法。(大致了解了流程。参考：学习 Linux 内存分配)
* [x] 内存 slab 算法。(大致了解了流程。参考：学习 Linux 内存分配)
* [x] 内存泄漏文章。
* [x] 多定时器文章。
* [x] libco session。怎么才不会崩溃。（建立一个临时变量对象。模仿 sx_client，时钟管理，添加索引进行保护。） - 3 天。

---

#### 5.1.5. 2021-03

* [x] libco session。怎么才不会崩溃。（建立一个临时变量对象。模仿 sx_client，时钟管理用堆。） - 3 天。
* [x] 进程强制退出崩溃，切换回主进程退出。（强退崩溃的原因是拷贝了 so。）
* [x] libco cond signal 工作原理。（co_cond_timedwait 添加一个任务到双向链表，signal 将任务添加到 timeout 列表或者 activelist 列表，激活协程处理。）
* [x] mysql 连接池文章。
* [x] co_kimserver 简介文章。
* [x] mysql 连接池添加回收机制，（不够添加，太少回收，采用类似 lru 方法，将最不活跃的淘汰。）
* [x] mysql 开启慢日志和 explain 数据库。
* [x] 压测工具设置信号，退出清理数据。（作用不大。）
* [x] mysql 连接池添加慢日志。（已完成，配置添加了 slowlog_log_slower_than， 但是 mstime() ）
* [x] 单独购买 mysql 机器，压力测 mysql。(阿里云，2核2G)
* [x] 部署主从数据库，测试主从分离。（压力测试还是需要使用实体机，因为涉及到写硬盘的。）
* [x] redis 添加唤醒协程，测试并发能力。（添加唤醒协程并不能解决问题，实际应该是数据传输消耗了性能。空包跑，有可能跑 20w 并发。测试 redis 只有 6 w 左右，感觉也正常。）
* [x] redis pipeline 文章。（1 天 客户端 hiredis 和服务端剖析。）
* [x] 优化 redis 连接池 pipeline 和 limit 和返回错误码。
* [x] libco redis 支持 pipeline.（同步也支持 pipline）
* [x] 父进程退出，通知子进程。（父进程给子进程发 SIGUSR1 信号。）
* [x] co 协程退出。（co_eventloop 添加退出函数。）
* [x] 子进程调试信号捕捉。（添加信号处理，SIGINT, SIGTERM。）
* [x] 调整好时钟。（在 timerCron 里添加 on_timer）
* [x] 修正 libco 的关闭协程崩溃问题。（共享栈内存拷贝问题，参考别人的 issue 已修正。）
* [x] maxclients 两个函数作用。(参考了博客，setrlimit 可以设置进程的资源限制。)
* [x] libco 协程共享栈。
* [x] epoll userdata 文章。
* [x] co_kimserver 需要替换查找 fd 的方式。（替换为 id 了。）

---

#### 5.1.6. 2021-02

* [x] 限制进程打开文件个数否则超量导致 fd 传输失败。（参考 redis 实现了。）
* [x] 查看空跑为啥 CPU 那么高。（时钟问题。）
* [x] 虚拟机 rsync 调通。（参数和用户需要对应，特别是 rsa 方式。）
* [x] 安装虚拟机，安装环境，写基本的测试流程。（把主要虚拟机搭建写了一个帖子。）
* [x] 压力测 redis 和 mysql 连接池。（虚拟机压测效果理想，已更新文档。）
* [x] zookeeper 管理简化。（二级节点放到代码管理，配置只管理一级节点。）
* [x] libco 退出进程异常。（初步认为是脚本同时关闭父子进程导致，优化脚本只关闭父进程，添加了退出删除 zk 节点逻辑。）
* [x] co_kimserver 压力测试。（redis 和 mysql 压测并发均已达标。单进程 mysql 并发 1w 左右。）
* [x] libco 整合 zookeeper，以及节点间通信的逻辑。（整合成功。）
* [x] 父子进程信号。（子进程崩溃，父进程可以感知。）

---

#### 5.1.7. 2021-01

* [x] co_kimserver 添加 hiredis 的连接池。（基本测试通过，idle 后续处理。）
* [x] mysqlclient 断线重连。（mysql_real_query 有断线重连功能，只要 MYSQL_OPT_RECONNECT 属性被设置，不需要 mysql_ping()。）
* [x] libco 可以整合日志么。（可以，但是如果日志切出去了，日志会很乱，后续可以 hook 日志接口。但是在海量的服务处理里，服务的调度也是切来切去的，日志也很难找。）
* [x] libco 整合到 kimserver，调通 tcp 协议。（已实现压力测试。）
* [x] libco 时钟。（libco 内部时钟，无法直接拿出来使用，但是通过协程模拟时钟，里面通过 poll 超时切换即可。）
* [x] libco 函数跑完了协程怎么办。(事件切换出去后，要进来，那么需要主协程调度，如果协程跑完了，如果时钟和事件驱动，无法调度那么它将永远沉睡。如果协程跑完了，无法再调度了，可以通过 co_reset 重新跑。)
* [x] 初步实现了 co_kimserver。

---

#### 5.1.8. 2020-12

* [x] libco 网络库调度。（用 lldb 走通工作流程。）
* [x] libco 协程切换调度。(resume 和 yield 的处理。)
* [x] libco 128 的装载数组。（一般是协程嵌套才会递增，正常情况下数组大小为 2.）
* [x] libco 协程独立栈和共享栈。（libco 的栈空间都分配在堆上，独立栈是每个协程有自己的堆内存空间，共享栈分配了公共的堆空间，不同的协程函数在上面运行，当协程切出，将会将当前的栈空间拷贝出来，运行的时候再拷贝进去。）
* [x] blog 目录排序整理。(_config.yml 进行配置，还有待处理。)
* [x] 异步 mysqlclient 并发效率。（在 mac 上效果正常，但是 centos 效率比不上 libco。性能主要耗在 mariadb client 的问题。）
* [x] 工作协程 rbp 是怎么来的。（开始的时候是没有数据的，在 coctx_swap 里会 save 进去。）
* [x] libco 协程切换函数内容细节。（call/ret 两汇编指令和 rsp 寄存器数据变化。）
* [x] 查看 rip 与 rax 是什么时候切入的。（主要是 rsp rbp rsi rdi rip 这几个寄存器的数据。rip 存储程序当前运行指令，rax 一般存储返回地址，但是 ret 指令会操作返回。留意 ret 后 rsp 变化，还有它执行了跳转地址，看它跳转到哪了。）
* [x] 工作协程的栈空间到底保存了什么。（保存了协程函数的上下文。）
* [x] 工作协程 ret （跳转程序执行指令）
* [x] libco 协程栈切换原理。(coctx_swap 汇编实现，实现压栈和执行指令跳转)
* [x] http auto_send 逻辑。（域名解析使用阻塞的 getaddrinfo，综合优缺点的选择。）
* [x] 做了 libco 测试 mysql 视频。([测试源码](https://github.com/wenfh2020/test_libco))
* [x] 协程测试实现 mysql 的异步方式。（初步理解协程的工作原理。）
* [x] redis 域名解析文章。（getaddrinfo 虽然阻塞，但是正常情况下效率也不错。）
* [x] kimserver 域名解析。（用 getaddrinfo，内部服务，一般场景效率比较高。）
* [x] 当 cmd 返回错误后，不能关闭 fd，只有编解码出现问题才能直接关闭 socket。
* [x] zk 没起来，没返回错误。（cmd 逻辑实现问题。）
* [x] 写日志检查磁盘变化。（压力测试查看 iotop 命令）
* [x] 负载 sys cmd 发送失败后，fd 被删除问题。（用时钟检查。）
* [x] 事件处理，系统与正常逻辑要分开。（connection 已经添加了 system 逻辑。）
* [x] 文章：kimserver 配置。（已修改）
* [x] 文章：kimserver 负载。（已修改）
* [x] 文章：修改文章节点发现，添加 config.json 处理。（不处理也行。）
* [x] 做一期火焰图使用视频。
* [x] 转移 Redis 文章 sentinel 系列。

---

#### 5.1.9. 2020-11

* [x] 火焰图查看负载。（优化了 connection 时间。）
* [x] gittalk.
* [x] needShareButton.
* [x] 处理负载数据显示问题。（payload 接口调用错误导致。）
* [x] auto send 压力测试子进程分配问题。（节点间通信，一致性哈希，分布不是绝对均匀，最大和最小值可能有 20 % 的差距。）
* [x] blog 评论，分享，赞赏功能。
* [x] kimserver 负载功能。
* [x] 压力测试 auto send.（节点在连接过程中，没有打通道路前，需要将数据先缓存在等待发送缓冲区。）
* [x] daemonize。（再三考虑，没有什么意义。用 tail 可以解决。）
* [x] http fetch 整理。（跟 tcp 的解包类似。）
* [x] auto send 大量数据下的场景，数据写入 waiting buffer。(只要 connetting / try 状态业务数据要放 wait buffer，系统的数据放到 send_buf 中去。发送事件，只要 conneted 状态，先发 waiting ，再发 send_buf。只要缓冲区还有数据，就要触发写事件。)
* [x] manager 和 worker 整合事件类。(整合到 events_callback。)
* [x] kimserver 多进程节点联系，添加流程图。
* [x] 去掉 Module 与 cmd 的联系，callback 处理。（module 在这里只是个路由，开始的时候有用。后面不需要处理。）
* [x] 整理 syscmd send_ack。
* [x] close_conn() 发现直接关闭原来的。（强制关闭 cmd 没有意义，即便连接断掉，部分逻辑还可以继续进行。）
* [x] 处理 cmd 和 connection 的逻辑。（conn 被销毁后，cmd 还可以继续工作，因为 cmd 可能有多个步骤，直接删除会导致脏数据写入。不如让它执行完成。）
* [x] 时钟被销毁，cmd 的过期时间没法控制。(销毁的是 io 时钟，cmd 时钟独立，与 cmd 的生命期一致。)
* [x] 连接断开，接收和发送缓冲区数据，如何处理。（连接断开，本连接的发送和接收数据不允许操作了，但是接收缓冲区数据支持解包处理，避免丢包，例如日志数据，无论丢弃或者继续处理都不可能完美解决问题，因为丢掉说明数据丢失，继续处理，终端无法接收。）
* [x] const（保证接口安全性。）
* [x] 指针改为引用。（引用比指针安全一点。）
* [x] 处理 cmd "std::shared_ptr"。（修改为指针，有点像 c 了，有点不安全，已经修改为 const 引用。）
* [x] auto connect 心跳。(不设置心跳，不工作就让它释放掉。IO_TIMEOUT_VAL)
* [x] 完善节点发现，如果没有根目录就创建，这样比较方便。-（先不处理了，节点还是留给用户创建，可控性较强。）
* [x] 完善 auto send 的流程。(send_to_node)
* [x] sgx ./http_test.sh 6 问题。(topnews2016)
* [x] 剥离 manger 等事件剥离。
* [x] 完善多进程通信文章。

---

## 6. 生活好习惯

1. 早睡。
2. 运动。
3. 正常情绪，戒怒。（想想鹿犬的培养。）
4. 保证工作效率，早上 6:30 -- 晚上 12:00
5. 周末带媳妇和孩子晨运，接触阳光。
6. 孩子情绪不好的时候，不要进入工作状态。
7. 要经常让孩子和父母保持沟通。
8. 空闲时间，集中和快速完成小问题。
9. 关心孩子每天在学校发生的事，学习等等。

---

## 7. 工作好习惯

* 别在琐事上纠缠。
* 手机放在见不到的地方。
* 禁止工作时，看百度统计，简书，CSDN 等统计。
* 聚焦动手，快速处理完成重要的任务。
* 切换主题，一天两个任务，一大一小，先做大任务。
* 善于利用 trello，processon，markdown 等工具落地思路。
* 将复杂的问题对象全部整理在一个页面上，方便查找，理清逻辑。
* 尽量让大脑做选择题。
* 遇到问题卡住了，翻看其它帖子。
* 可以听音乐释放压力。
* 注意负面情绪叠加，尽快转移焦点，即便是 smoke。
* 头脑混沌时，用清水洗脸。

---

## 8. 核心问题分析

### 8.1. 内存泄漏

1. valgrind.
2. 日志。
3. gdb。
4. git 回退。折半排除法。

---

### 8.2. select/poll/epoll 区别

select/poll共有的缺点是：

一，返回后需要遍历fd集合找到就绪的fd，但fd集合就绪的描述符很少；
二，select/poll均需将fd集合在用户态和内核态之间来回拷贝。

epoll的引入是为了解决select/poll上述两个缺点，epoll提供三个函数epoll_create、epoll_ctl、epoll_wait。epoll_create在内核的高速cache中建一棵红黑树以及就绪链表(activeList)。epoll_ctl的add在红黑树上添加fd结点，并且注册fd的回调函数，内核在检测到某fd就绪时会调用回调函数将fd添加到activeList。epoll_wait将activeList中的fd返回。epoll_ctl每次只往内核添加红黑树节点，不需像select/poll拷贝所有fd到内核，epoll_wait通过共享内存从内核传递就绪fd到用户，不需像select/poll拷贝出所有fd并遍历所有fd找到就绪的。
