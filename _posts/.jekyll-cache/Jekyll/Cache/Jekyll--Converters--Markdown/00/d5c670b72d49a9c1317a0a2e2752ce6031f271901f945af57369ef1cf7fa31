I"1<p>redis 内存管理实现，有三种方式：</p>

<ol>
  <li><code class="highlighter-rouge">jemalloc</code> (谷歌)</li>
  <li><code class="highlighter-rouge">tcmalloc</code> （facebook）</li>
  <li><code class="highlighter-rouge">libc</code> （系统）</li>
</ol>

<p>其中 <code class="highlighter-rouge">jemalloc</code>， <code class="highlighter-rouge">tcmalloc</code> 是第三方的实现，<code class="highlighter-rouge">libc</code> 的实现相对简单，没有做成一个内存池。没有像 <code class="highlighter-rouge">nginx</code>那样，有自己的内存管理链表。频繁向内核申请内存不是明智的做法。作者应该是推荐使用 <code class="highlighter-rouge">tcmallic</code> 或 <code class="highlighter-rouge">jemalloc</code>。</p>

<ul id="markdown-toc">
  <li><a href="#1-内存管理" id="markdown-toc-1-内存管理">1. 内存管理</a></li>
  <li><a href="#2-核心接口" id="markdown-toc-2-核心接口">2. 核心接口</a></li>
  <li><a href="#3-测试" id="markdown-toc-3-测试">3. 测试</a></li>
  <li><a href="#4-参考" id="markdown-toc-4-参考">4. 参考</a></li>
</ul>

<h2 id="1-内存管理">1. 内存管理</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 理解宏对相关库的引入使用。</span>
<span class="cp">#if defined(USE_TCMALLOC)
#define ZMALLOC_LIB ("tcmalloc-" __xstr(TC_VERSION_MAJOR) "." __xstr(TC_VERSION_MINOR))
#include &lt;google/tcmalloc.h&gt;
#if (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6) || (TC_VERSION_MAJOR &gt; 1)
#define HAVE_MALLOC_SIZE 1
#define zmalloc_size(p) tc_malloc_size(p)
#else
#error "Newer version of tcmalloc required"
#endif
</span>
<span class="cp">#elif defined(USE_JEMALLOC)
#define ZMALLOC_LIB ("jemalloc-" __xstr(JEMALLOC_VERSION_MAJOR) "." __xstr(JEMALLOC_VERSION_MINOR) "." __xstr(JEMALLOC_VERSION_BUGFIX))
#include &lt;jemalloc/jemalloc.h&gt;
#if (JEMALLOC_VERSION_MAJOR == 2 &amp;&amp; JEMALLOC_VERSION_MINOR &gt;= 1) || (JEMALLOC_VERSION_MAJOR &gt; 2)
#define HAVE_MALLOC_SIZE 1
#define zmalloc_size(p) je_malloc_usable_size(p)
#else
#error "Newer version of jemalloc required"
#endif
</span>
<span class="cp">#elif defined(__APPLE__)
#include &lt;malloc/malloc.h&gt;
#define HAVE_MALLOC_SIZE 1
#define zmalloc_size(p) malloc_size(p)
#endif
</span>
<span class="cp">#ifndef ZMALLOC_LIB
#define ZMALLOC_LIB "libc"
#ifdef __GLIBC__
#include &lt;malloc.h&gt;
#define HAVE_MALLOC_SIZE 1
#define zmalloc_size(p) malloc_usable_size(p)
#endif
#endif
</span></code></pre></div></div>

<hr />
<p>c 语言比较精简的内存池，可以参考 <code class="highlighter-rouge">nginx</code> 的<a href="https://github.com/nginx/nginx/blob/master/src/core/ngx_palloc.c">实现</a>。nginx 这种简单的链式内存池，虽然避免了频繁从内核分配内存，也容易产生内存碎片。即便是 glibc 的 slab 实现内存管理，也不能很好地解决内存碎片问题。所以内存池就是个复杂的问题。在 redis 上要很好地解决该问题，必然会提高整个项目的复杂度，与其自己造轮子，不如用优秀的第三方库：<code class="highlighter-rouge">tcmalloc</code>, <code class="highlighter-rouge">jemalloc</code></p>
<blockquote>
  <p><a href="https://wenfh2020.com/2020/01/21/nginx-pool/">[nginx 源码走读] 内存池</a></p>
</blockquote>

<hr />

<h2 id="2-核心接口">2. 核心接口</h2>

<ul>
  <li>内存管理
如果是 <code class="highlighter-rouge">libc</code> 实现的内存管理，内存分配会加一个前缀，保存内存长度。有点像 <code class="highlighter-rouge">nginx</code> 的字符串结构。分配内存返回内容指针，释放内存，指针要从数据部分移动到内存长度部分。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// nginx 字符串结构</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">size_t</span>      <span class="n">len</span><span class="p">;</span>
    <span class="n">u_char</span>     <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ngx_str_t</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef HAVE_MALLOC_SIZE
#define PREFIX_SIZE (0)
#else
#if defined(__sun) || defined(__sparc) || defined(__sparc__)
#define PREFIX_SIZE (sizeof(long long))
#else
#define PREFIX_SIZE (sizeof(size_t))
#endif
#endif
</span>
<span class="c1">// 分配内存</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">zmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 内存长度前缀</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PREFIX_SIZE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="n">zmalloc_oom_handler</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="cp">#ifdef HAVE_MALLOC_SIZE
</span>    <span class="n">update_zmalloc_stat_alloc</span><span class="p">(</span><span class="n">zmalloc_size</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="cp">#else
</span>    <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="c1">// 统计</span>
    <span class="n">update_zmalloc_stat_alloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PREFIX_SIZE</span><span class="p">);</span>
    <span class="c1">// 返回内容内存</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">PREFIX_SIZE</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">}</span>

<span class="c1">// 释放内存</span>
<span class="kt">void</span> <span class="nf">zfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef HAVE_MALLOC_SIZE
</span>    <span class="kt">void</span> <span class="o">*</span><span class="n">realptr</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">oldsize</span><span class="p">;</span>
<span class="cp">#endif
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
<span class="cp">#ifdef HAVE_MALLOC_SIZE
</span>    <span class="n">update_zmalloc_stat_free</span><span class="p">(</span><span class="n">zmalloc_size</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="cp">#else
</span>    <span class="c1">// 指针移动到内存起始位置</span>
    <span class="n">realptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">-</span> <span class="n">PREFIX_SIZE</span><span class="p">;</span>
    <span class="n">oldsize</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">realptr</span><span class="p">);</span>
    <span class="c1">// 统计</span>
    <span class="n">update_zmalloc_stat_free</span><span class="p">(</span><span class="n">oldsize</span> <span class="o">+</span> <span class="n">PREFIX_SIZE</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">realptr</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>内存对齐和统计
<code class="highlighter-rouge">used_memory</code> 统计内存使用
分配内存，内存对齐是为了提高 cpu 效率。但是 <code class="highlighter-rouge">update_zmalloc_stat_alloc</code></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define update_zmalloc_stat_alloc(__n) do { \
    size_t _n = (__n); \
    // 对齐
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">_n</span><span class="o">&amp;</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="n">_n</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">_n</span><span class="o">&amp;</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span> \
    <span class="n">atomicIncr</span><span class="p">(</span><span class="n">used_memory</span><span class="p">,</span><span class="n">__n</span><span class="p">);</span> \
<span class="err">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>这个函数的实现让人费解，代码对 <code class="highlighter-rouge">_n</code> 进行操作，最后却保存了 <code class="highlighter-rouge">__n</code> 。github 上虽然提出了这个<a href="https://github.com/antirez/redis/issues/4739">问题</a>，貌似没有得到解决.</p>

<p>历史版本 <a href="https://github.com/antirez/redis/blame/9390c384b88de6b2363c3f33ba42bd25c1c3346d/src/zmalloc.c">blame</a></p>

<p><img src="/images/2020-02-20-16-47-12.png" alt="历史" data-action="zoom" /></p>

<p>当前版本 <a href="https://github.com/antirez/redis/blame/unstable/src/zmalloc.c">blame</a></p>

<p><img src="/images/2020-02-20-16-47-28.png" alt="当前" data-action="zoom" /></p>

<hr />

<ul>
  <li>获得系统已使用内存</li>
</ul>

<p>redis 内存申请几乎都调用 zmalloc 接口，每次申请和回收都会被 <code class="highlighter-rouge">used_memory</code> 记录起来。当系统处理 <code class="highlighter-rouge">maxmemory</code> 的时候，就要知道系统使用了多少内存，从而进行一些回收数据的策略。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">zmalloc_used_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">um</span><span class="p">;</span>
    <span class="n">atomicGet</span><span class="p">(</span><span class="n">used_memory</span><span class="p">,</span><span class="n">um</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">um</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-测试">3. 测试</h2>

<p><code class="highlighter-rouge">jemalloc, tcmalloc, libc</code> 到底哪个库比较好用，是马是驴拉出来溜溜才能知道，要根据线上情况进行评估。</p>
<blockquote>
  <p>可以用 <code class="highlighter-rouge">redis-benchmark</code> 压力测试。</p>
</blockquote>

<hr />

<h2 id="4-参考">4. 参考</h2>

<ul>
  <li><a href="https://blog.csdn.net/libaineu2004/article/details/79400357">关于redis源码的内存分配,jemalloc,tcmalloc,libc</a></li>
</ul>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/">wenfh2020.com</a></p>
</blockquote>
:ET