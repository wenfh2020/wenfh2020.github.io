I".W<p>理解 libev 工作流程，<a href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_timer_code_relative_and_opti">官方文档</a> 和网上有很多资料可以查阅（<a href="https://my.oschina.net/u/917596/blog/176658">事件库之Libev（一）</a>，<a href="https://www.cnblogs.com/gqtcgq/category/1043758.html">随笔分类 - libev</a>）。libev 源码，宏的使用频率比较高，也因为这样，源码理解起来比较费脑，可以展开宏查阅源码，或者通过调试方式，理解 libev 的工作流程。redis-ae 事件管理与 libev 有点类似，也可以相互比较一下。</p>

<ul id="markdown-toc">
  <li><a href="#1-展开宏" id="markdown-toc-1-展开宏">1. 展开宏</a></li>
  <li><a href="#2-gdb-调试" id="markdown-toc-2-gdb-调试">2. gdb 调试</a></li>
  <li><a href="#3-对比-redis-ae" id="markdown-toc-3-对比-redis-ae">3. 对比 redis-ae</a></li>
  <li><a href="#4-参考" id="markdown-toc-4-参考">4. 参考</a></li>
</ul>

<hr />

<h2 id="1-展开宏">1. 展开宏</h2>

<p>程序编译流程：预编译，编译，汇编器，链接。预编译阶段，还没涉及程序语义解析，可以将文件的宏进行展开。</p>

<p>libev 核心逻辑在 <code class="highlighter-rouge">ev.c</code> 文件，对这个文件进行预编译（其它文件也可以参考这个方法）。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-E</span> ev.c <span class="nt">-o</span> ev.i
</code></pre></div></div>

<ul>
  <li>宏展开前</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ev.c</span>
<span class="kt">void</span> <span class="n">noinline</span>
<span class="n">ev_timer_start</span> <span class="p">(</span><span class="n">EV_P_</span> <span class="n">ev_timer</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span> <span class="n">EV_THROW</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">expect_false</span> <span class="p">(</span><span class="n">ev_is_active</span> <span class="p">(</span><span class="n">w</span><span class="p">)))</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">ev_at</span> <span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">+=</span> <span class="n">mn_now</span><span class="p">;</span>

  <span class="n">assert</span> <span class="p">((</span><span class="s">"libev: ev_timer_start called with negative timer repeat value"</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">repeat</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">.));</span>

  <span class="n">EV_FREQUENT_CHECK</span><span class="p">;</span>

  <span class="o">++</span><span class="n">timercnt</span><span class="p">;</span>
  <span class="n">ev_start</span> <span class="p">(</span><span class="n">EV_A_</span> <span class="p">(</span><span class="n">W</span><span class="p">)</span><span class="n">w</span><span class="p">,</span> <span class="n">timercnt</span> <span class="o">+</span> <span class="n">HEAP0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">array_needsize</span> <span class="p">(</span><span class="n">ANHE</span><span class="p">,</span> <span class="n">timers</span><span class="p">,</span> <span class="n">timermax</span><span class="p">,</span> <span class="n">ev_active</span> <span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">EMPTY2</span><span class="p">);</span>
  <span class="n">ANHE_w</span> <span class="p">(</span><span class="n">timers</span> <span class="p">[</span><span class="n">ev_active</span> <span class="p">(</span><span class="n">w</span><span class="p">)])</span> <span class="o">=</span> <span class="p">(</span><span class="n">WT</span><span class="p">)</span><span class="n">w</span><span class="p">;</span>
  <span class="n">ANHE_at_cache</span> <span class="p">(</span><span class="n">timers</span> <span class="p">[</span><span class="n">ev_active</span> <span class="p">(</span><span class="n">w</span><span class="p">)]);</span>
  <span class="n">upheap</span> <span class="p">(</span><span class="n">timers</span><span class="p">,</span> <span class="n">ev_active</span> <span class="p">(</span><span class="n">w</span><span class="p">));</span>

  <span class="n">EV_FREQUENT_CHECK</span><span class="p">;</span>

  <span class="cm">/*assert (("libev: internal timer heap corruption", timers [ev_active (w)] == (WT)w));*/</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>宏展开后</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ev.i</span>
<span class="kt">void</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__noinline__</span><span class="p">))</span>
<span class="n">ev_timer_start</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="n">ev_timer</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">((</span><span class="o">!!</span><span class="p">((</span><span class="mi">0</span> <span class="o">+</span> <span class="p">((</span><span class="n">ev_watcher</span> <span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">w</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">))),(</span><span class="mi">0</span><span class="p">)))</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="p">((</span><span class="n">WT</span><span class="p">)(</span><span class="n">w</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">at</span> <span class="o">+=</span> <span class="p">((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mn_now</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="k">do</span> <span class="p">{</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="o">++</span><span class="p">((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timercnt</span><span class="p">);</span>
  <span class="n">ev_start</span> <span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="p">(</span><span class="n">W</span><span class="p">)</span><span class="n">w</span><span class="p">,</span> <span class="p">((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timercnt</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">((</span><span class="o">!!</span><span class="p">((((</span><span class="n">W</span><span class="p">)(</span><span class="n">w</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timermax</span><span class="p">)))),(</span><span class="mi">0</span><span class="p">)))</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__unused__</span><span class="p">))</span> <span class="n">ocur_</span> <span class="o">=</span> <span class="p">(((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timermax</span><span class="p">));</span> <span class="p">(((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="n">ANHE</span> <span class="o">*</span><span class="p">)</span><span class="n">array_realloc</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">ANHE</span><span class="p">),</span> <span class="p">(((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">)),</span> <span class="o">&amp;</span><span class="p">(((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timermax</span><span class="p">)),</span> <span class="p">(((</span><span class="n">W</span><span class="p">)(</span><span class="n">w</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="p">;</span> <span class="p">};</span>
  <span class="p">(((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">)</span> <span class="p">[((</span><span class="n">W</span><span class="p">)(</span><span class="n">w</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">]).</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">WT</span><span class="p">)</span><span class="n">w</span><span class="p">;</span>
  <span class="p">(((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">)</span> <span class="p">[((</span><span class="n">W</span><span class="p">)(</span><span class="n">w</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">]).</span><span class="n">at</span> <span class="o">=</span> <span class="p">(((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">)</span> <span class="p">[((</span><span class="n">W</span><span class="p">)(</span><span class="n">w</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">]).</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">;</span>
  <span class="n">upheap</span> <span class="p">(((</span><span class="n">loop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">),</span> <span class="p">((</span><span class="n">W</span><span class="p">)(</span><span class="n">w</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">);</span>

  <span class="k">do</span> <span class="p">{</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="2-gdb-调试">2. gdb 调试</h2>

<ol>
  <li>下载 libev 源码：<a href="http://dist.schmorp.de/libev/">源码地址</a></li>
  <li>修改源码目录下的 configure 文件，将所有编译优化项（CFLAGS），修改为 CFLAGS=”-g O0”。</li>
  <li>编译安装源码：./configure &amp;&amp; make &amp;&amp; make install</li>
  <li>gdb 调试测试源码。</li>
</ol>

<blockquote>
  <p>详细请参考：<a href="https://www.bilibili.com/video/BV1U54y1D7uM/">gdb &amp; libev 调试视频</a></p>
</blockquote>

<p><img src="/images/2020-05-28-21-04-53.png" alt="libev 调试" data-action="zoom" /></p>

<hr />

<h2 id="3-对比-redis-ae">3. 对比 redis-ae</h2>

<p>redis 事件管理 <code class="highlighter-rouge">aeEventLoop</code> 与 libev 类似。总体来说，libev 要比 redis 功能丰富实用，redis 不用 libev，可能 redis 作者希望源码更可控。</p>

<ul>
  <li>libev 处理事件类型更丰富，<code class="highlighter-rouge">aeEventLoop</code> 只处理了文件事件和时钟事件。</li>
  <li>redis <code class="highlighter-rouge">aeEventLoop</code> 有 <code class="highlighter-rouge">beforesleep</code> 和 <code class="highlighter-rouge">aftersleep</code> 等操作处理。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">aeMain</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
        <span class="n">aeProcessEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">AE_ALL_EVENTS</span><span class="o">|</span><span class="n">AE_CALL_AFTER_SLEEP</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>libev 很多源码细节做得更好，例如：
    <ol>
      <li>时钟，redis 用的是列表存储（不优化的原因，目前时钟事件并不多，暂时没有改进的必要），而 libev 用数组存储时钟事件，通过堆排序，过期策略做得非常高效。</li>
      <li>例如 epoll_ctl 出现重复插入事件错误（EEXIST），libev 会主动进行修改 EPOLL_CTL_MOD。而 redis 这种场景，就直接返回错误，让用户处理了。</li>
    </ol>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// libev - ev_epoll.c</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">epoll_modify</span> <span class="p">(</span><span class="n">EV_P_</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nev</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">expect_true</span> <span class="p">(</span><span class="o">!</span><span class="n">epoll_ctl</span> <span class="p">(</span><span class="n">backend_fd</span><span class="p">,</span> <span class="n">oev</span> <span class="o">&amp;&amp;</span> <span class="n">oldmask</span> <span class="o">!=</span> <span class="n">nev</span> <span class="o">?</span> <span class="n">EPOLL_CTL_MOD</span> <span class="o">:</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)))</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="c1">// 错误处理。</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">expect_true</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EEXIST</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="cm">/* EEXIST means we ignored a previous DEL, but the fd is still active */</span>
      <span class="cm">/* if the kernel mask is the same as the new mask, we assume it hasn't changed */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">oldmask</span> <span class="o">==</span> <span class="n">nev</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">dec_egen</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epoll_ctl</span> <span class="p">(</span><span class="n">backend_fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// redis - ep_epoll.c</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiAddEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ee</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="cm">/* avoid valgrind warning */</span>
    <span class="cm">/* If the fd was already monitored for some event, we need a MOD
     * operation. Otherwise we need an ADD operation. */</span>
    <span class="kt">int</span> <span class="n">op</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="n">mask</span> <span class="o">==</span> <span class="n">AE_NONE</span> <span class="o">?</span>
            <span class="n">EPOLL_CTL_ADD</span> <span class="o">:</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">;</span>

    <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">mask</span> <span class="o">|=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="cm">/* Merge old events */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>
    <span class="n">ee</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">,</span><span class="n">op</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ee</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-参考">4. 参考</h2>

<ul>
  <li><a href="http://software.schmorp.de/pkg/libev.html">官网</a></li>
  <li><a href="http://dist.schmorp.de/libev/">官方源码</a></li>
  <li><a href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_timer_code_relative_and_opti">官方文档</a></li>
  <li><a href="https://my.oschina.net/u/917596/blog/176658">事件库之Libev（一）</a></li>
  <li><a href="https://www.cnblogs.com/gqtcgq/category/1043758.html">随笔分类 - libev</a></li>
  <li><a href="https://wenfh2020.com/2020/04/06/ae-timer/">[redis 源码走读] 事件 - 定时器</a></li>
  <li><a href="https://wenfh2020.com/2020/04/09/redis-ae-file/">[redis 源码走读] 事件 - 文件事件</a></li>
  <li><a href="http://chenzhenianqing.com/articles/1051.html">Libev轻网络库 源码浅析</a></li>
</ul>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/2020/05/28/libev-source-reading/">wenfh2020.com</a></p>
</blockquote>
:ET