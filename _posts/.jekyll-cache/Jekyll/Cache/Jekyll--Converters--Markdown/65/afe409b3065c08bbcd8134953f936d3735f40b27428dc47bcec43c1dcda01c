I"Oe<p>redis 是内存数据库，可以通过 <code class="highlighter-rouge">redis.conf</code> 配置 <code class="highlighter-rouge">maxmemory</code>，限制 redis 内存使用量。当 redis 主库内存超出限制时，命令处理将会触发数据淘汰机制，淘汰（<code class="highlighter-rouge">key-value</code>）数据，直至当前内存使用量小于限制阈值。</p>

<ul id="markdown-toc">
  <li><a href="#1-数据淘汰策略概述" id="markdown-toc-1-数据淘汰策略概述">1. 数据淘汰策略概述</a></li>
  <li><a href="#2-配置" id="markdown-toc-2-配置">2. 配置</a></li>
  <li><a href="#3-数据淘汰时机" id="markdown-toc-3-数据淘汰时机">3. 数据淘汰时机</a></li>
  <li><a href="#4-数据淘汰策略" id="markdown-toc-4-数据淘汰策略">4. 数据淘汰策略</a>    <ul>
      <li><a href="#41-不淘汰数据noeviction" id="markdown-toc-41-不淘汰数据noeviction">4.1. 不淘汰数据（noeviction）</a></li>
      <li><a href="#42-随机淘汰" id="markdown-toc-42-随机淘汰">4.2. 随机淘汰</a></li>
      <li><a href="#43-采样淘汰" id="markdown-toc-43-采样淘汰">4.3. 采样淘汰</a>        <ul>
          <li><a href="#431-淘汰快到期数据volatile-ttl" id="markdown-toc-431-淘汰快到期数据volatile-ttl">4.3.1. 淘汰快到期数据（volatile-ttl）</a></li>
          <li><a href="#432-lru" id="markdown-toc-432-lru">4.3.2. lru</a></li>
          <li><a href="#433-lfu" id="markdown-toc-433-lfu">4.3.3. lfu</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#5-总结" id="markdown-toc-5-总结">5. 总结</a></li>
  <li><a href="#6-参考" id="markdown-toc-6-参考">6. 参考</a></li>
</ul>

<hr />

<h2 id="1-数据淘汰策略概述">1. 数据淘汰策略概述</h2>

<p>redis.conf</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">配置</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">maxmemory <字节></字节></td>
      <td style="text-align: left">将内存使用限制设置为指定的字节数。</td>
    </tr>
  </tbody>
</table>

<hr />

<p>redis 申请和回收内存基本上都是通过 <code class="highlighter-rouge">zmalloc</code> 接口统一管理的，可以通过接口统计 redis 的内存使用量。当 redis 超出了内存的使用限制 <code class="highlighter-rouge">maxmemory</code>，服务在处理命令时会触发 redis 内部的数据淘汰机制。淘汰目标数据一共有两种：</p>

<ol>
  <li>数据库所有(<code class="highlighter-rouge">key-value</code>)数据。</li>
  <li>数据库所有被设置了过期时间的(<code class="highlighter-rouge">key-value</code>)数据。</li>
</ol>

<blockquote>
  <p>aof 缓存，主从同步的积压缓冲区这些数据是不会被淘汰的，也没有计算在 maxmemory 里面。</p>
</blockquote>

<p>针对这两种目标数据，它有几种淘汰策略：</p>

<ol>
  <li>随机淘汰。</li>
  <li>先淘汰到期或快到期数据。</li>
  <li>近似 LRU 算法（最近最少使用）</li>
  <li>近似 LFU 算法 （最近使用频率最少）</li>
</ol>

<hr />

<p>关于近似的 <code class="highlighter-rouge">lru</code> 和 <code class="highlighter-rouge">lfu</code> 淘汰策略，英文好的朋友，可以去看看 <code class="highlighter-rouge">antirez</code> 的这两篇文章： <a href="https://redis.io/topics/lru-cache">Using Redis as an LRU cache</a>， <a href="http://antirez.com/news/109">Random notes on improving the Redis LRU algorithm</a> ，<code class="highlighter-rouge">redis.conf</code> 也有不少阐述。再结合源码，基本能理解它们的实现思路。</p>

<hr />

<p><code class="highlighter-rouge">maxmemory</code> 核心数据淘汰策略在函数 <code class="highlighter-rouge">freeMemoryIfNeeded</code> 中，可以仔细阅读这个函数的源码。</p>

<hr />

<h2 id="2-配置">2. 配置</h2>

<p>当 <code class="highlighter-rouge">redis.conf</code> 配置了 <code class="highlighter-rouge">maxmemory</code>，可以根据配置采用相应的数据淘汰策略。<code class="highlighter-rouge">volatile-xxx</code> 这种类型配置，都是只淘汰设置了过期时间的数据，<code class="highlighter-rouge">allkeys-xxx</code> 淘汰数据库所有数据。如果 redis 在你的应用场景中，只是作为缓存，任何数据都可以淘汰，可以设置 <code class="highlighter-rouge">allkeys-xxx</code>。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">配置</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">noeviction</td>
      <td style="text-align: left">不要淘汰任何数据，大部分写操作会返回错误。</td>
    </tr>
    <tr>
      <td style="text-align: left">volatile-random</td>
      <td style="text-align: left">随机删除设置了过期时间的键。</td>
    </tr>
    <tr>
      <td style="text-align: left">allkeys-random</td>
      <td style="text-align: left">删除随机键，任何键。</td>
    </tr>
    <tr>
      <td style="text-align: left">volatile-ttl</td>
      <td style="text-align: left">删除最接近到期​​时间（较小的TTL）的键。</td>
    </tr>
    <tr>
      <td style="text-align: left">volatile-lru</td>
      <td style="text-align: left">使用近似的LRU淘汰数据，仅设置过期的键。</td>
    </tr>
    <tr>
      <td style="text-align: left">allkeys-lru</td>
      <td style="text-align: left">使用近似的LRU算法淘汰长时间没有使用的键。</td>
    </tr>
    <tr>
      <td style="text-align: left">volatile-lfu</td>
      <td style="text-align: left">在设置了过期时间的键中，使用近似的LFU算法淘汰使用频率比较低的键。</td>
    </tr>
    <tr>
      <td style="text-align: left">allkeys-lfu</td>
      <td style="text-align: left">使用近似的LFU算法淘汰整个数据库的键。</td>
    </tr>
  </tbody>
</table>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAXMEMORY_FLAG_LRU (1&lt;&lt;0)
#define MAXMEMORY_FLAG_LFU (1&lt;&lt;1)
#define MAXMEMORY_FLAG_ALLKEYS (1&lt;&lt;2)
</span>
<span class="cp">#define MAXMEMORY_VOLATILE_LRU ((0&lt;&lt;8)|MAXMEMORY_FLAG_LRU)
#define MAXMEMORY_VOLATILE_LFU ((1&lt;&lt;8)|MAXMEMORY_FLAG_LFU)
#define MAXMEMORY_VOLATILE_TTL (2&lt;&lt;8)
#define MAXMEMORY_VOLATILE_RANDOM (3&lt;&lt;8)
#define MAXMEMORY_ALLKEYS_LRU ((4&lt;&lt;8)|MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_ALLKEYS)
#define MAXMEMORY_ALLKEYS_LFU ((5&lt;&lt;8)|MAXMEMORY_FLAG_LFU|MAXMEMORY_FLAG_ALLKEYS)
#define MAXMEMORY_ALLKEYS_RANDOM ((6&lt;&lt;8)|MAXMEMORY_FLAG_ALLKEYS)
#define MAXMEMORY_NO_EVICTION (7&lt;&lt;8)
</span></code></pre></div></div>

<hr />

<h2 id="3-数据淘汰时机">3. 数据淘汰时机</h2>

<p>在事件循环处理命令时触发检查</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">processCommand</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">lua_timedout</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">out_of_memory</span> <span class="o">=</span> <span class="n">freeMemoryIfNeededAndSafe</span><span class="p">()</span> <span class="o">==</span> <span class="n">C_ERR</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">current_client</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">out_of_memory</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_DENYOOM</span> <span class="o">||</span>
             <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MULTI</span> <span class="o">&amp;&amp;</span>
              <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">!=</span> <span class="n">execCommand</span> <span class="o">&amp;&amp;</span>
              <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">!=</span> <span class="n">discardCommand</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="n">flagTransaction</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">oomerr</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">freeMemoryIfNeededAndSafe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">lua_timedout</span> <span class="o">||</span> <span class="n">server</span><span class="p">.</span><span class="n">loading</span><span class="p">)</span> <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">freeMemoryIfNeeded</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-数据淘汰策略">4. 数据淘汰策略</h2>

<p>下面从简单到复杂，说说这几种策略。</p>

<hr />

<h3 id="41-不淘汰数据noeviction">4.1. 不淘汰数据（noeviction）</h3>

<p>超出内存限制，可以淘汰数据，当然也可以不使用淘汰策略淘汰数据，<code class="highlighter-rouge">noeviction</code> 配置允许我们这样做。服务允许读，但禁止大部分<code class="highlighter-rouge">写</code>命令，返回 <code class="highlighter-rouge">oomerr</code> 错误。只有少数写命令可以执行，例如删除命令 <code class="highlighter-rouge">del</code>，<code class="highlighter-rouge">hdel</code>，<code class="highlighter-rouge">unlink</code> 这些<strong>能降低内存使用的写命令</strong>。</p>

<ul>
  <li>32 位系统，如果没有设置 <code class="highlighter-rouge">maxmemory</code>，系统默认最大值是 <code class="highlighter-rouge">3G</code>，过期淘汰策略是：<code class="highlighter-rouge">MAXMEMORY_NO_EVICTION</code></li>
</ul>

<blockquote>
  <p>64 位系统不设置 <code class="highlighter-rouge">maxmemory</code>，是没有限制的，Linux 以及其它很多系统通过虚拟内存管理物理内存，进程可以使用超出物理内存大小的内存，只是那个时候，物理内存和磁盘间频繁地 swap，导致系统性能下降，对于 redis 这种高性能内存数据库，这不是一个友好的体验。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">initServer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">arch_bits</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span><span class="s">"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now."</span><span class="p">);</span>
        <span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">=</span> <span class="mi">3072LL</span><span class="o">*</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span> <span class="cm">/* 3 GB */</span>
        <span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">=</span> <span class="n">MAXMEMORY_NO_EVICTION</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<ul>
  <li>服务禁止大部分<code class="highlighter-rouge">写</code>命令</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">processCommand</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">lua_timedout</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 当内存超出限制，进行回收处理。</span>
        <span class="kt">int</span> <span class="n">out_of_memory</span> <span class="o">=</span> <span class="n">freeMemoryIfNeededAndSafe</span><span class="p">()</span> <span class="o">==</span> <span class="n">C_ERR</span><span class="p">;</span>
        <span class="cm">/* freeMemoryIfNeeded may flush slave output buffers. This may result
         * into a slave, that may be the active client, to be freed. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">current_client</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>

        <span class="cm">/* It was impossible to free enough memory, and the command the client
         * is trying to execute is denied during OOM conditions or the client
         * is in MULTI/EXEC context? Error. */</span>
        <span class="c1">// 内存回收后，还是办法将内存减少到限制以下，那么大部分写命令将会被禁止执行。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out_of_memory</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_DENYOOM</span> <span class="o">||</span>
             <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MULTI</span> <span class="o">&amp;&amp;</span>
              <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">!=</span> <span class="n">execCommand</span> <span class="o">&amp;&amp;</span>
              <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">!=</span> <span class="n">discardCommand</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="n">flagTransaction</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">oomerr</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">freeMemoryIfNeededAndSafe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">lua_timedout</span> <span class="o">||</span> <span class="n">server</span><span class="p">.</span><span class="n">loading</span><span class="p">)</span> <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">freeMemoryIfNeeded</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">freeMemoryIfNeeded</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">==</span> <span class="n">MAXMEMORY_NO_EVICTION</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">cant_free</span><span class="p">;</span> <span class="cm">/* We need to free memory, but policy forbids. */</span>
    <span class="p">...</span>
<span class="nl">cant_free:</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>CMD_DENYOOM 命令属性（use-memory）</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">populateCommandTableParseFlags</span><span class="p">(</span><span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strflags</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span><span class="s">"use-memory"</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CMD_DENYOOM</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">redisCommand</span> <span class="n">redisCommandTable</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="p">{</span><span class="s">"get"</span><span class="p">,</span><span class="n">getCommand</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span>
     <span class="s">"read-only fast @string"</span><span class="p">,</span>
     <span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span>

    <span class="cm">/* Note that we can't flag set as fast, since it may perform an
     * implicit DEL of a large key. */</span>
    <span class="p">{</span><span class="s">"set"</span><span class="p">,</span><span class="n">setCommand</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span>
     <span class="s">"write use-memory @string"</span><span class="p">,</span>
     <span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span>

    <span class="p">{</span><span class="s">"setnx"</span><span class="p">,</span><span class="n">setnxCommand</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>
     <span class="s">"write use-memory fast @string"</span><span class="p">,</span>
     <span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span>
     <span class="p">...</span>
    <span class="p">{</span><span class="s">"del"</span><span class="p">,</span><span class="n">delCommand</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>
     <span class="s">"write @keyspace"</span><span class="p">,</span>
     <span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span>

    <span class="p">{</span><span class="s">"unlink"</span><span class="p">,</span><span class="n">unlinkCommand</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>
     <span class="s">"write fast @keyspace"</span><span class="p">,</span>
     <span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span>
     <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<hr />

<h3 id="42-随机淘汰">4.2. 随机淘汰</h3>

<p><code class="highlighter-rouge">volatile-random</code>，<code class="highlighter-rouge">allkeys-random</code> 这两个随机淘汰机制相对比较简单，也比较暴力，随机从库中挑选数据进行淘汰。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">freeMemoryIfNeeded</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
        <span class="cm">/* volatile-random and allkeys-random policy */</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">==</span> <span class="n">MAXMEMORY_ALLKEYS_RANDOM</span> <span class="o">||</span>
                 <span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">==</span> <span class="n">MAXMEMORY_VOLATILE_RANDOM</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* When evicting a random key, we try to evict a key for
             * each DB, so we use the static 'next_db' variable to
             * incrementally visit all DBs. */</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">dbnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">next_db</span><span class="p">)</span> <span class="o">%</span> <span class="n">server</span><span class="p">.</span><span class="n">dbnum</span><span class="p">;</span>
                <span class="n">db</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>
                <span class="n">dict</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">==</span> <span class="n">MAXMEMORY_ALLKEYS_RANDOM</span><span class="p">)</span> <span class="o">?</span>
                        <span class="n">db</span><span class="o">-&gt;</span><span class="n">dict</span> <span class="o">:</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">dict</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">de</span> <span class="o">=</span> <span class="n">dictGetRandomKey</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
                    <span class="n">bestkey</span> <span class="o">=</span> <span class="n">dictGetKey</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
                    <span class="n">bestdbid</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="43-采样淘汰">4.3. 采样淘汰</h3>

<p>redis 作为一个数据库，里面保存了大量数据，可以根据到期时间（<code class="highlighter-rouge">ttl</code>），<code class="highlighter-rouge">lru</code> 或 <code class="highlighter-rouge">lfu</code> 进行数据淘汰，严格来说，需要维护一些数据结构才能准确筛选出目标数据，但是 <code class="highlighter-rouge">maxmemory</code> 触发的概率比较低，小系统有可能永远不会触发。为了一个概率低的场景去维护一些数据结构，这显然不是一个聪明的做法。所以 redis 通过采样的方法，近似的数据淘汰策略。</p>

<hr />

<p>采样方法：遍历数据库，每个数据库随机采集<code class="highlighter-rouge">maxmemory_samples</code>个样本，放进一个样本池中（数组）。样本池中的样本 <code class="highlighter-rouge">idle</code> 值从低到高排序（数组从左到右存储），数据淘汰策略将会每次淘汰 <code class="highlighter-rouge">idle</code> 最高的那个数据。因为样本池大小是有限制的（<code class="highlighter-rouge">EVPOOL_SIZE</code>），所以采集的样本要根据自己的 <code class="highlighter-rouge">idle</code> 值大小或池中是否有空位来确定是否能成功插入到样本池中。如果池中没有空位或被插入样本的<code class="highlighter-rouge">idle</code> 值都小于池子中的数据，那插入将会失败。<strong>所以池子中一直存储着<code class="highlighter-rouge">idle</code>最大，最大几率被淘汰的那些数据样本</strong>。</p>

<p><img src="/images/2020-03-10-12-39-50.png" alt="采样淘汰" data-action="zoom" /></p>

<hr />

<p>对于样本，显然是采样越多，筛选目标数据就越精确。redis 作者根据实践经验，<code class="highlighter-rouge">maxmemory_samples</code> 默认每次采样 5 个已经比较高效了，10 个就非常接近 LRU 算法效果。例如<a href="http://redis.io/images/redisdoc/lru_comparison.png" data-action="zoom">下图</a>近似 <code class="highlighter-rouge">lru</code> 算法：</p>

<blockquote>
  <p>图 1 是正常的 LRU 算法。</p>

  <ol>
    <li>浅灰色表示已经删除的键。</li>
    <li>深灰色表示没有被删除的键。</li>
    <li>绿色表示新加入的键。</li>
  </ol>
</blockquote>

<p><img src="/images/2020-03-10-16-16-02.png" alt="lru 采样" data-action="zoom" /></p>

<ul>
  <li>样本数据池</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define EVPOOL_SIZE 16
#define EVPOOL_CACHED_SDS_SIZE 255
</span><span class="k">struct</span> <span class="n">evictionPoolEntry</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">idle</span><span class="p">;</span>    <span class="cm">/* Object idle time (inverse frequency for LFU) */</span>
    <span class="n">sds</span> <span class="n">key</span><span class="p">;</span>                    <span class="cm">/* Key name. */</span>
    <span class="n">sds</span> <span class="n">cached</span><span class="p">;</span>                 <span class="cm">/* Cached SDS object for key name. */</span>
    <span class="kt">int</span> <span class="n">dbid</span><span class="p">;</span>                   <span class="cm">/* Key DB number. */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">evictionPoolEntry</span> <span class="o">*</span><span class="n">EvictionPoolLRU</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">evictionPoolAlloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">evictionPoolEntry</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="n">ep</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ep</span><span class="p">)</span><span class="o">*</span><span class="n">EVPOOL_SIZE</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">EVPOOL_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ep</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ep</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ep</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cached</span> <span class="o">=</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">EVPOOL_CACHED_SDS_SIZE</span><span class="p">);</span>
        <span class="n">ep</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dbid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">EvictionPoolLRU</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>采样淘汰机制实现，扫描数据库，从样本池中取出淘汰键 <code class="highlighter-rouge">bestkey</code> 进行淘汰。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">freeMemoryIfNeeded</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">mem_freed</span> <span class="o">&lt;</span> <span class="n">mem_tofree</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="c1">// 采样，从样本中选出一个合适的键，进行数据淘汰。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAXMEMORY_FLAG_LRU</span><span class="o">|</span><span class="n">MAXMEMORY_FLAG_LFU</span><span class="p">)</span> <span class="o">||</span>
            <span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">==</span> <span class="n">MAXMEMORY_VOLATILE_TTL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">struct</span> <span class="n">evictionPoolEntry</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">EvictionPoolLRU</span><span class="p">;</span>

            <span class="k">while</span><span class="p">(</span><span class="n">bestkey</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_keys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keys</span><span class="p">;</span>

                <span class="c1">// 将采集的键放进 pool 中。</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">dbnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">db</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
                    <span class="c1">// 从过期键中扫描，还是全局键扫描抽样。</span>
                    <span class="n">dict</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="n">MAXMEMORY_FLAG_ALLKEYS</span><span class="p">)</span> <span class="o">?</span>
                            <span class="n">db</span><span class="o">-&gt;</span><span class="n">dict</span> <span class="o">:</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">keys</span> <span class="o">=</span> <span class="n">dictSize</span><span class="p">(</span><span class="n">dict</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// 采样到样本池中</span>
                        <span class="n">evictionPoolPopulate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="n">pool</span><span class="p">);</span>
                        <span class="n">total_keys</span> <span class="o">+=</span> <span class="n">keys</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total_keys</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* No keys to evict. */</span>

                <span class="c1">// 从数组高到低，查找键进行数据淘汰</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">EVPOOL_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                    <span class="n">bestdbid</span> <span class="o">=</span> <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">dbid</span><span class="p">;</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="n">MAXMEMORY_FLAG_ALLKEYS</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">de</span> <span class="o">=</span> <span class="n">dictFind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">dbid</span><span class="p">].</span><span class="n">dict</span><span class="p">,</span>
                            <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">de</span> <span class="o">=</span> <span class="n">dictFind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">dbid</span><span class="p">].</span><span class="n">expires</span><span class="p">,</span>
                            <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="cm">/* Remove the entry from the pool. */</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span> <span class="o">!=</span> <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cached</span><span class="p">)</span>
                        <span class="n">sdsfree</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
                    <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                    <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                    <span class="cm">/* If the key exists, is our pick. Otherwise it is
                     * a ghost and we need to try the next element. */</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">bestkey</span> <span class="o">=</span> <span class="n">dictGetKey</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="cm">/* Ghost... Iterate again. */</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>采样到样本池中</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">evictionPoolPopulate</span><span class="p">(</span><span class="kt">int</span> <span class="n">dbid</span><span class="p">,</span> <span class="n">dict</span> <span class="o">*</span><span class="n">sampledict</span><span class="p">,</span> <span class="n">dict</span> <span class="o">*</span><span class="n">keydict</span><span class="p">,</span> <span class="k">struct</span> <span class="n">evictionPoolEntry</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">samples</span><span class="p">[</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_samples</span><span class="p">];</span>

    <span class="c1">// 随机采样多个数据。</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">dictGetSomeKeys</span><span class="p">(</span><span class="n">sampledict</span><span class="p">,</span><span class="n">samples</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_samples</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="n">MAXMEMORY_FLAG_LRU</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// lru 近似算法，淘汰长时间没有使用的数据。</span>
            <span class="n">idle</span> <span class="o">=</span> <span class="n">estimateObjectIdleTime</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="n">MAXMEMORY_FLAG_LFU</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 淘汰使用频率比较小的数据。</span>
            <span class="n">idle</span> <span class="o">=</span> <span class="mi">255</span><span class="o">-</span><span class="n">LFUDecrAndReturn</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">==</span> <span class="n">MAXMEMORY_VOLATILE_TTL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 淘汰最快过期数据。</span>
            <span class="n">idle</span> <span class="o">=</span> <span class="n">ULLONG_MAX</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">serverPanic</span><span class="p">(</span><span class="s">"Unknown eviction policy in evictionPoolPopulate()"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 将采集的 key，填充到 pool 数组中去。</span>
        <span class="c1">// 在 pool 数组中，寻找合适到位置。pool[k].key == NULL 或者 idle &lt; pool[k].idle</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">EVPOOL_SIZE</span> <span class="o">&amp;&amp;</span>
               <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span> <span class="o">&amp;&amp;</span>
               <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">idle</span> <span class="o">&lt;</span> <span class="n">idle</span><span class="p">)</span> <span class="n">k</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pool</span><span class="p">[</span><span class="n">EVPOOL_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// pool 已满，当前采样没能找到合适位置插入。</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">EVPOOL_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 找到合适位置插入，不需要移动数组其它元素。</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 找到数组中间位置，需要移动数据。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">EVPOOL_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 数组还有空间，数据从插入位置向右移动。</span>
                <span class="n">sds</span> <span class="n">cached</span> <span class="o">=</span> <span class="n">pool</span><span class="p">[</span><span class="n">EVPOOL_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">cached</span><span class="p">;</span>
                <span class="n">memmove</span><span class="p">(</span><span class="n">pool</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pool</span><span class="o">+</span><span class="n">k</span><span class="p">,</span>
                    <span class="k">sizeof</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">EVPOOL_SIZE</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
                <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cached</span> <span class="o">=</span> <span class="n">cached</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 数组右边已经没有空间，那么删除 idle 最小的元素。</span>
                <span class="n">k</span><span class="o">--</span><span class="p">;</span>
                <span class="n">sds</span> <span class="n">cached</span> <span class="o">=</span> <span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cached</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span> <span class="o">!=</span> <span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cached</span><span class="p">)</span> <span class="n">sdsfree</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
                <span class="n">memmove</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="n">pool</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">k</span><span class="p">);</span>
                <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cached</span> <span class="o">=</span> <span class="n">cached</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 内存的分配和销毁开销大，pool 缓存空间比较小的 key，方便内存重复使用。</span>
        <span class="kt">int</span> <span class="n">klen</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">klen</span> <span class="o">&gt;</span> <span class="n">EVPOOL_CACHED_SDS_SIZE</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">sdsdup</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cached</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">klen</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">sdssetlen</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cached</span><span class="p">,</span><span class="n">klen</span><span class="p">);</span>
            <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cached</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">idle</span> <span class="o">=</span> <span class="n">idle</span><span class="p">;</span>
        <span class="n">pool</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">dbid</span> <span class="o">=</span> <span class="n">dbid</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h4 id="431-淘汰快到期数据volatile-ttl">4.3.1. 淘汰快到期数据（volatile-ttl）</h4>

<ul>
  <li>数据库 <code class="highlighter-rouge">redisDb</code> 用 <code class="highlighter-rouge">expires</code> 字典保存了 key 对应的过期时间。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisDb</span> <span class="p">{</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>                 <span class="cm">/* The keyspace for this DB */</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">expires</span><span class="p">;</span>              <span class="cm">/* Timeout of keys with a timeout set */</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">volatile-ttl</code> 淘汰那些设置了过期时间且最快到期的数据。随机采样放进样本池，从样本池中先淘汰<code class="highlighter-rouge">idle</code>值最大数据。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">evictionPoolPopulate</span><span class="p">(</span><span class="kt">int</span> <span class="n">dbid</span><span class="p">,</span> <span class="n">dict</span> <span class="o">*</span><span class="n">sampledict</span><span class="p">,</span> <span class="n">dict</span> <span class="o">*</span><span class="n">keydict</span><span class="p">,</span> <span class="k">struct</span> <span class="n">evictionPoolEntry</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">==</span> <span class="n">MAXMEMORY_VOLATILE_TTL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// (long)dictGetVal(de) 时间越小，越快到期；idle 越大，越容易从样本池中淘汰。</span>
        <span class="n">idle</span> <span class="o">=</span> <span class="n">ULLONG_MAX</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h4 id="432-lru">4.3.2. lru</h4>

<p>缓存目的是缓存活跃数据，<code class="highlighter-rouge">volatile-ttl</code> 淘汰最快到期的数据，存在缺陷：有可能把活跃的数据先淘汰了，可以采用 <code class="highlighter-rouge">allkeys-lru</code> 和 <code class="highlighter-rouge">volatile-lru</code> 策略，根据当前时间与上一次访问的时间间隔，间隔越小说明越活跃。通过采样，用近似 lru 算法淘汰那些很久没有使用的数据。</p>

<blockquote>
  <p>简单的 lru 实现可以看看我这个帖子 <a href="https://wenfh2020.com/2020/03/11/lru/">lru c++ 实现</a></p>
</blockquote>

<hr />

<ul>
  <li><code class="highlighter-rouge">redisObject</code> 成员 <code class="highlighter-rouge">lru</code> 保存了一个 24 bit 的系统访问数据时间戳。保存 lru 时间精度是秒，<code class="highlighter-rouge">LRU_CLOCK_MAX</code> 时间范围大概 194 天。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define LRU_BITS 24
#define LRU_CLOCK_MAX ((1&lt;&lt;LRU_BITS)-1) </span><span class="cm">/* Max value of obj-&gt;lru */</span><span class="cp">
#define LRU_CLOCK_RESOLUTION 1000 </span><span class="cm">/* LRU clock resolution in ms */</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">type</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">encoding</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">lru</span><span class="o">:</span><span class="n">LRU_BITS</span><span class="p">;</span> <span class="cm">/* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */</span>
    <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>访问对应数据时，更新 lru 时间。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Low level key lookup API, not actually called directly from commands
 * implementations that should instead rely on lookupKeyRead(),
 * lookupKeyWrite() and lookupKeyReadWithFlags(). */</span>
<span class="n">robj</span> <span class="o">*</span><span class="nf">lookupKey</span><span class="p">(</span><span class="n">redisDb</span> <span class="o">*</span><span class="n">db</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictFind</span><span class="p">(</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">robj</span> <span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="cm">/* Update the access time for the ageing algorithm.
         * Don't do it if we have a saving child, as this will trigger
         * a copy on write madness. */</span>
        <span class="c1">// 当主进程 fork 子进程处理数据时，不要更新。</span>
        <span class="c1">// 否则父子进程 `copy-on-write` 模式将被破坏，产生大量新增内存。</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hasActiveChildProcess</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_NOTOUCH</span><span class="p">)){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="n">MAXMEMORY_FLAG_LFU</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">updateLFU</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 更新 lru 时间</span>
                <span class="n">val</span><span class="o">-&gt;</span><span class="n">lru</span> <span class="o">=</span> <span class="n">LRU_CLOCK</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>近似 lru 淘汰长时间没使用数据。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">evictionPoolPopulate</span><span class="p">(</span><span class="kt">int</span> <span class="n">dbid</span><span class="p">,</span> <span class="n">dict</span> <span class="o">*</span><span class="n">sampledict</span><span class="p">,</span> <span class="n">dict</span> <span class="o">*</span><span class="n">keydict</span><span class="p">,</span> <span class="k">struct</span> <span class="n">evictionPoolEntry</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="n">MAXMEMORY_FLAG_LRU</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// lru 近似算法，淘汰长时间没有使用的数据。</span>
        <span class="n">idle</span> <span class="o">=</span> <span class="n">estimateObjectIdleTime</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>返回当前时间与上一次访问时间间距。间隔越小，说明越活跃。（时间精度毫秒）</li>
</ul>

<p><img src="/images/2020-03-10-13-59-25.png" alt="时间间隔" data-action="zoom" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">estimateObjectIdleTime</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">lruclock</span> <span class="o">=</span> <span class="n">LRU_CLOCK</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lruclock</span> <span class="o">&gt;=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lruclock</span> <span class="o">-</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">)</span> <span class="o">*</span> <span class="n">LRU_CLOCK_RESOLUTION</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lruclock</span> <span class="o">+</span> <span class="p">(</span><span class="n">LRU_CLOCK_MAX</span> <span class="o">-</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">))</span> <span class="o">*</span>
                    <span class="n">LRU_CLOCK_RESOLUTION</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h4 id="433-lfu">4.3.3. lfu</h4>

<p>近似 <code class="highlighter-rouge">lru</code> 淘汰策略，似乎要比前面讲的策略都要先进，但是它也是有缺陷的。因为根据当前时间与上一次访问时间两个时间点间隔来判断数据是否活跃。也只能反映两个时间点的活跃度。对于一段时间内的活跃度是很难反映出来的。</p>

<hr />

<p>在同一个时间段内，B 的访问频率明显要比 A 高，显然 B 要比 A 热度更高。然而 <code class="highlighter-rouge">lru</code> 算法会把 B 数据淘汰掉。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~~~~~A~~~~~A~~~~~A~~~~A~~~~~A~~~~A~A~|
~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~|
</code></pre></div></div>

<hr />

<p>所以 redis 作者又引入了一种新的算法，近似 <code class="highlighter-rouge">lfu</code> 算法，反映数值访问频率，也就是数据访问热度。它重复利用了 <code class="highlighter-rouge">redisObject</code> 结构 <code class="highlighter-rouge">lru</code> 成员。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">unsigned</span> <span class="n">lru</span><span class="o">:</span><span class="n">LRU_BITS</span><span class="p">;</span> <span class="cm">/* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#           16 bits      8 bits</span>
<span class="c">#      +----------------+--------+</span>
<span class="c">#      + Last decr time | LOG_C  |</span>
<span class="c">#      +----------------+--------+</span>
</code></pre></div></div>

<p>前 16 bits 用来存储上一个访问衰减时间（<code class="highlighter-rouge">ldt</code>），后 8 bits 用来存储衰减计数频率(<code class="highlighter-rouge">counter</code>)。那衰减时间和计数到底有什么用呢？<strong>其实是在一个时间段内，访问频率越高，计数就越大（计数最大值为 255）。我们通过计数的大小判断数据的热度。</strong></p>

<hr />

<ul>
  <li>近似 lfu 淘汰使用频率比较低的数据。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">evictionPoolPopulate</span><span class="p">(</span><span class="kt">int</span> <span class="n">dbid</span><span class="p">,</span> <span class="n">dict</span> <span class="o">*</span><span class="n">sampledict</span><span class="p">,</span> <span class="n">dict</span> <span class="o">*</span><span class="n">keydict</span><span class="p">,</span> <span class="k">struct</span> <span class="n">evictionPoolEntry</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="n">MAXMEMORY_FLAG_LRU</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 淘汰使用频率比较小的数据。</span>
        <span class="n">idle</span> <span class="o">=</span> <span class="mi">255</span><span class="o">-</span><span class="n">LFUDecrAndReturn</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>当前时间与上次访问的时间间隔，时间精度是分钟。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">LFUTimeElapsed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ldt</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">LFUGetTimeInMinutes</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&gt;=</span> <span class="n">ldt</span><span class="p">)</span> <span class="k">return</span> <span class="n">now</span><span class="o">-</span><span class="n">ldt</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">65535</span><span class="o">-</span><span class="n">ldt</span><span class="o">+</span><span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">LFUGetTimeInMinutes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="o">/</span><span class="mi">60</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">65535</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>衰减计数</p>

    <p>LFUTimeElapsed 值越大，counter 就越小。也就是说，两次访问的时间间隔越大，计数的递减就越厉害。这个递减速度会受到衰减时间因子（<code class="highlighter-rouge">lfu_decay_time</code>）影响。可以在配置文件中调节，一般默认为 1。</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">LFUDecrAndReturn</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ldt</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">lru</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">lru</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_periods</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">lfu_decay_time</span> <span class="o">?</span> <span class="n">LFUTimeElapsed</span><span class="p">(</span><span class="n">ldt</span><span class="p">)</span> <span class="o">/</span> <span class="n">server</span><span class="p">.</span><span class="n">lfu_decay_time</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num_periods</span><span class="p">)</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_periods</span> <span class="o">&gt;</span> <span class="n">counter</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">counter</span> <span class="o">-</span> <span class="n">num_periods</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<ul>
  <li>访问触发频率更新，更新 lfu 数据</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">robj</span> <span class="o">*</span><span class="nf">lookupKey</span><span class="p">(</span><span class="n">redisDb</span> <span class="o">*</span><span class="n">db</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictFind</span><span class="p">(</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">robj</span> <span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hasActiveChildProcess</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_NOTOUCH</span><span class="p">)){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="n">MAXMEMORY_FLAG_LFU</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 更新频率</span>
                <span class="n">updateLFU</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">val</span><span class="o">-&gt;</span><span class="n">lru</span> <span class="o">=</span> <span class="n">LRU_CLOCK</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 更新 lfu 数据</span>
<span class="kt">void</span> <span class="nf">updateLFU</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// LFUDecrAndReturn 的时间精度是分钟，所以只会每分钟更新一次 counter.</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">LFUDecrAndReturn</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="c1">// 实时更新当前 counter</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">LFULogIncr</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
    <span class="c1">// 保存 lfu 数据。</span>
    <span class="n">val</span><span class="o">-&gt;</span><span class="n">lru</span> <span class="o">=</span> <span class="p">(</span><span class="n">LFUGetTimeInMinutes</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>计数器统计访问频率</p>

    <p>这其实是一个概率计算，当数据被访问次数越多，那么随机数落在某个数据段的概率就越大。计数增加的可能性就越高。 redis 作者添加了控制因子 lfu_log_factor，当因子越大，那计数增长速度就越缓慢。</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="nf">LFULogIncr</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">counter</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span> <span class="k">return</span> <span class="mi">255</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span><span class="o">/</span><span class="n">RAND_MAX</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">baseval</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">-</span> <span class="n">LFU_INIT_VAL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">baseval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">baseval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="o">/</span><span class="p">(</span><span class="n">baseval</span><span class="o">*</span><span class="n">server</span><span class="p">.</span><span class="n">lfu_log_factor</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>数据库新增数据默认计数为 <code class="highlighter-rouge">LFU_INIT_VAL</code>，这样不至于刚添加进来就被淘汰了。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">robj</span> <span class="o">*</span><span class="nf">createEmbeddedStringObject</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">&amp;</span> <span class="n">MAXMEMORY_FLAG_LFU</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">o</span><span class="o">-&gt;</span><span class="n">lru</span> <span class="o">=</span> <span class="p">(</span><span class="n">LFUGetTimeInMinutes</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">LFU_INIT_VAL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下面是 redis 作者压力测试得出的 <code class="highlighter-rouge">factor</code> 和 <code class="highlighter-rouge">counter</code> 测试数据。因子越大，<code class="highlighter-rouge">counter</code> 增长越缓慢。</p>

<blockquote>
  <p>测试数据来自 redis.conf</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># +--------+------------+------------+------------+------------+------------+</span>
<span class="c"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span>
<span class="c"># +--------+------------+------------+------------+------------+------------+</span>
<span class="c"># | 0      | 104        | 255        | 255        | 255        | 255        |</span>
<span class="c"># +--------+------------+------------+------------+------------+------------+</span>
<span class="c"># | 1      | 18         | 49         | 255        | 255        | 255        |</span>
<span class="c"># +--------+------------+------------+------------+------------+------------+</span>
<span class="c"># | 10     | 10         | 18         | 142        | 255        | 255        |</span>
<span class="c"># +--------+------------+------------+------------+------------+------------+</span>
<span class="c"># | 100    | 8          | 11         | 49         | 143        | 255        |</span>
<span class="c"># +--------+------------+------------+------------+------------+------------+</span>
<span class="c">#</span>
<span class="c"># NOTE: The above table was obtained by running the following commands:</span>
<span class="c">#</span>
<span class="c">#   redis-benchmark -n 1000000 incr foo</span>
<span class="c">#   redis-cli object freq foo</span>
</code></pre></div></div>

<hr />

<h2 id="5-总结">5. 总结</h2>

<ul>
  <li><code class="highlighter-rouge">maxmemory</code> 淘汰数据机制，主要淘汰两种目标数据：整个数据库数据和设置了过期时间的数据。</li>
  <li><code class="highlighter-rouge">maxmemory</code> 淘汰策略，有：不使用淘汰策略淘汰数据，随机淘汰数据，采样的近似算法 <code class="highlighter-rouge">ttl</code>，<code class="highlighter-rouge">lru</code>，<code class="highlighter-rouge">lfu</code>。</li>
  <li>redis 版本从 2.x 到 6.x，一直不停地改进迭代，redis 作者精益求精的精神值得我们学习。</li>
  <li>采样近似淘汰策略，巧妙避免了维护额外的数据结构，达到差不多的效果，这个思路独具匠心。</li>
  <li>采样算法，根据样本的 idle 值进行数据淘汰，所以当我们采用一种采样算法时，不要密集地设置大量相似的 idle 数据，否则效率也是很低的。</li>
  <li><code class="highlighter-rouge">maxmemory</code> 设置其实是一个学问，到底应该设置多少，才比较合理。很多人建议是物理内存大小的一半，原因如下：
    <ol>
      <li>主从复制，全量复制场景，slave 从 master 接收 rdb 文件进行加载，在这个操作前 slave 可能会异步释放原有内存数据，所以 slave 有可能同时存在两份数据。</li>
      <li>数据持久化过程中，redis 会 fork 子进程，在 linux 系统中虽然父子进程有 ‘copy-on-write’ 模式，redis 也尽量避免子进程工作过程中修改数据，子进程部分操作会使用内存，例如写 rdb 文件。</li>
      <li><code class="highlighter-rouge">maxmemory</code> 限制的内存并不包括 <code class="highlighter-rouge">aof</code> 缓存和主从同步积压缓冲区部分内存。</li>
      <li>我们的机器很多时候不是只跑 redis 进程的，系统其它进程也要使用内存。</li>
    </ol>
  </li>
  <li><code class="highlighter-rouge">maxmemory</code> 虽然有众多的处理策略，然而超过阈值运行，这是不健康的，生产环境应该实时监控程序运行的健康状况。</li>
  <li>redis 经常作为缓存使用，其实它也有持久化，可以存储数据。redis 作为缓存和数据库一般都是交叉使用，没有明确的界限，所以不建议设置 <code class="highlighter-rouge">allkeys-xxx</code> 全局淘汰数据的策略。</li>
  <li>
    <p>当redis 内存到达 <code class="highlighter-rouge">maxmemory</code>，触发了数据淘汰，但是一顿操作后，内存始终无法成功降到阈值以下，那么 redis 主进程将会进入睡眠等待。这种问题是隐性的，很难查出来。新手很容易犯错误，经常把 redis 当做数据库使用，并发量高的系统，一段时间就跑满内存了，没经验的运维肯定第一时间想到切换到好点的机器解决问题。</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">freeMemoryIfNeeded</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="nl">cant_free:</span>
      <span class="c1">// 如果已经没有合适的键进行回收了，而且内存还没降到 maxmemory 以下，</span>
      <span class="c1">// 那么需要看看回收线程中是否还有数据需要进行回收，通过 sleep 主线程等待回收线程处理。</span>
      <span class="k">while</span><span class="p">(</span><span class="n">bioPendingJobsOfType</span><span class="p">(</span><span class="n">BIO_LAZY_FREE</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(((</span><span class="n">mem_reported</span> <span class="o">-</span> <span class="n">zmalloc_used_memory</span><span class="p">())</span> <span class="o">+</span> <span class="n">mem_freed</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">mem_tofree</span><span class="p">)</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="n">usleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h2 id="6-参考">6. 参考</h2>

<ul>
  <li><a href="https://wenfh2020.com/2020/01/12/redis-dict/">[redis 源码走读] 字典(dict)</a></li>
  <li><a href="https://redis.io/topics/lru-cache">Using Redis as an LRU cache</a></li>
  <li><a href="http://antirez.com/news/109">Random notes on improving the Redis LRU algorithm</a></li>
  <li><a href="https://www.jianshu.com/p/c8aeb3eee6bc">Redis的缓存淘汰策略LRU与LFU</a></li>
  <li><a href="https://blog.csdn.net/alex_xfboy/article/details/88959647">redis 过期策略及内存回收机制</a></li>
</ul>

<hr />

<blockquote>
  <p>🔥文章来源：<a href="https://wenfh2020.com/">wenfh2020.com</a></p>
</blockquote>
:ET