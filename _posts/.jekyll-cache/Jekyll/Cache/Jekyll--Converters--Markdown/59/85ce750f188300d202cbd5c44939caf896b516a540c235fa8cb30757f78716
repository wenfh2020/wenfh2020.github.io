I"|ğ<p>ç‚¹èµä½œè€…ï¼šredis æºç ï¼Œæ³¨é‡Šå¾ˆå¤šè€Œä¸”å¾ˆè¯¦ç»†ã€‚çœ‹å‹ç¼©åˆ—è¡¨æºç å‰ï¼Œå¯ä»¥å…ˆçœ‹çœ‹ ziplist.c æ–‡ä»¶é¡¶éƒ¨æ³¨é‡Šï¼ŒåŸºæœ¬å¯ä»¥äº†è§£è¯¥æ•°æ®ç»“æ„è®¾è®¡ã€‚å‹ç¼©åˆ—è¡¨æœ‰ç‚¹åƒæ•°æ®åºåˆ—åŒ–ï¼Œæ ¹æ®ä¸€å®šçš„é€»è¾‘ï¼Œå»æ‰æ•°æ®å†—ä½™å†…å­˜ï¼Œå¯¹æ•°æ®è¿›è¡Œå­˜å‚¨ï¼Œä»¥ä¾¿èŠ‚çœç³»ç»Ÿå†…å­˜ä½¿ç”¨ç©ºé—´ã€‚</p>

<ul id="markdown-toc">
  <li><a href="#1-åŸç†" id="markdown-toc-1-åŸç†">1. åŸç†</a></li>
  <li><a href="#2-ç»“æ„" id="markdown-toc-2-ç»“æ„">2. ç»“æ„</a>    <ul>
      <li><a href="#21-åˆ—è¡¨ç»“æ„" id="markdown-toc-21-åˆ—è¡¨ç»“æ„">2.1. åˆ—è¡¨ç»“æ„</a></li>
      <li><a href="#22-entry" id="markdown-toc-22-entry">2.2. entry</a></li>
      <li><a href="#23-prevlen" id="markdown-toc-23-prevlen">2.3. prevlen</a></li>
      <li><a href="#24-encoding" id="markdown-toc-24-encoding">2.4. encoding</a>        <ul>
          <li><a href="#241-å­—ç¬¦ä¸²" id="markdown-toc-241-å­—ç¬¦ä¸²">2.4.1. å­—ç¬¦ä¸²</a></li>
          <li><a href="#242-æ•°å€¼" id="markdown-toc-242-æ•°å€¼">2.4.2. æ•°å€¼</a></li>
          <li><a href="#243-ç¼–è§£ç å®ç°" id="markdown-toc-243-ç¼–è§£ç å®ç°">2.4.3. ç¼–è§£ç å®ç°</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#3-è°ƒè¯•" id="markdown-toc-3-è°ƒè¯•">3. è°ƒè¯•</a>    <ul>
      <li><a href="#31-è°ƒè¯•ä¸­é—´æ’å…¥ç»“ç‚¹" id="markdown-toc-31-è°ƒè¯•ä¸­é—´æ’å…¥ç»“ç‚¹">3.1. è°ƒè¯•ä¸­é—´æ’å…¥ç»“ç‚¹</a></li>
    </ul>
  </li>
  <li><a href="#4-æ¥å£" id="markdown-toc-4-æ¥å£">4. æ¥å£</a>    <ul>
      <li><a href="#41-æ’å…¥ç»“ç‚¹" id="markdown-toc-41-æ’å…¥ç»“ç‚¹">4.1. æ’å…¥ç»“ç‚¹</a></li>
    </ul>
  </li>
  <li><a href="#5-é—®é¢˜" id="markdown-toc-5-é—®é¢˜">5. é—®é¢˜</a></li>
  <li><a href="#6-å‚è€ƒ" id="markdown-toc-6-å‚è€ƒ">6. å‚è€ƒ</a></li>
</ul>

<hr />
<p>å‹ç¼©åˆ—è¡¨<code class="highlighter-rouge">ziplist</code>æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œè®¾è®¡ä¸»è¦æ˜¯ä¸ºäº†èŠ‚çœå†…å­˜ã€‚ä¿å­˜å­—ç¬¦ä¸²ï¼Œæ•°å€¼ä¸¤ç§ç±»å‹ï¼ˆ It stores both strings and integer valuesï¼‰ï¼Œåˆ—è¡¨å†…éƒ¨å®ç°ä¸»è¦æ˜¯å¯¹ä¸€å—è¿ç»­å†…å­˜è¿›è¡Œç®¡ç†ï¼Œåˆ—è¡¨æ”¯æŒåˆ—è¡¨å¤´å°¾çš„æ’å…¥æˆ–å¼¹å‡ºç»“ç‚¹æ“ä½œã€‚å› ä¸ºå†™æ“ä½œæ¶‰åŠåˆ°å†…å­˜é‡æ–°åˆ†é…ï¼Œæ‰€ä»¥å¤æ‚åº¦éœ€è¦æ ¹æ®å½“å‰ä½¿ç”¨å†…å­˜çš„ä½¿ç”¨æƒ…å†µè€Œå®šï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸å»ºè®®å­˜å‚¨å¤§é‡æ•°æ®ã€‚<code class="highlighter-rouge">sorted set</code> æ ¹æ®æ•°æ®é•¿åº¦ï¼Œå°±åˆ†åˆ«ç”¨ <code class="highlighter-rouge">ziplist</code> å’Œ <code class="highlighter-rouge">skiplist</code> ä¸¤ç§æ•°æ®ç»“æ„è¿›è¡Œä¿å­˜ã€‚</p>

<blockquote>
  <p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.</p>
</blockquote>

<hr />

<h2 id="1-åŸç†">1. åŸç†</h2>

<p>å‹ç¼©åŸç†ï¼šä¸¾ä¸ªä¾‹å­ï¼Œ<code class="highlighter-rouge">int a = 0</code> a æ˜¯ä¸€ä¸ªæ•´å‹å˜é‡ï¼Œå  4 ä¸ªå­—èŠ‚ã€‚ä½†æ˜¯ a = 0ï¼Œ0 è¿™ä¸ªæ•°å­—åªéœ€è¦ä¸€ä¸ª bit ä¿å­˜å°±è¶³å¤Ÿäº†ï¼Œå¦‚æœç”¨ 4 ä¸ªå­—èŠ‚ï¼ˆ32 bitï¼‰å†…å­˜å»ä¿å­˜å°±æœ‰ç‚¹æµªè´¹äº†ã€‚æŒ‰ç…§è¿™ä¸ªæ€è·¯ï¼Œå¤§è‡´å¯ä»¥ç†è§£å‹ç¼©ç­–ç•¥æ˜¯æ€ä¹ˆæ ·çš„ï¼Œè¯¦ç»†ä¿¡æ¯çœ‹æ–‡æ¡£å’Œæºç å§ã€‚</p>
<blockquote>
  <p>å‹ç¼©æ•°æ®ç®¡ç†æœ‰ç‚¹åƒæ•°æ®åºåˆ—åŒ–ï¼Œåºåˆ—åŒ–æ•°æ®å¹³å¸¸æ•°æ®çš„ä¼ è¾“ç»å¸¸ç”¨åˆ°ï¼Œå¯ä»¥äº†è§£ä¸‹ <code class="highlighter-rouge">protobuf</code> æºç ï¼Œçœ‹çœ‹æ•°æ®æ˜¯æ€ä¹ˆæ‰“åŒ…çš„ã€‚å‹ç¼©åˆ—è¡¨é™¤äº†æ•°æ®åºåˆ—åŒ–å¤–ï¼Œè¿˜éœ€è¦å¯¹æ•°æ®è¿›è¡Œæ’å…¥åˆ é™¤ç­‰æ“ä½œï¼Œéœ€è¦å¢åŠ ä¸€äº›é¢å¤–çš„ç»“æ„è¿›è¡Œå†…å­˜ç®¡ç†ã€‚</p>
</blockquote>

<hr />

<h2 id="2-ç»“æ„">2. ç»“æ„</h2>

<h3 id="21-åˆ—è¡¨ç»“æ„">2.1. åˆ—è¡¨ç»“æ„</h3>

<p><strong>å¤´ + ç»“ç‚¹ + å°¾</strong>
<code class="highlighter-rouge">&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</code></p>

<p><img src="/images/2020-02-20-16-44-19.png" alt="ç»“æ„" data-action="zoom" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Size of the "end of ziplist" entry. Just one byte. */</span>
<span class="cp">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
</span>
<span class="cm">/* Size of the "end of ziplist" entry. Just one byte. */</span>
<span class="cp">#define ZIPLIST_END_SIZE        (sizeof(uint8_t))
</span>
<span class="cm">/* Return total bytes a ziplist is composed of. */</span>
<span class="cp">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
</span>
<span class="cm">/* Return the offset of the last item inside the ziplist. */</span>
<span class="cp">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
</span>
<span class="cm">/* Return the length of a ziplist, or UINT16_MAX if the length cannot be
 * determined without scanning the whole ziplist. */</span>
<span class="cp">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
</span>
<span class="cm">/* Special "end of ziplist" entry. */</span>
<span class="cp">#define ZIP_END 255
</span></code></pre></div></div>

<h3 id="22-entry">2.2. entry</h3>

<p>ç»“ç‚¹ç»“æ„ï¼š<code class="highlighter-rouge">&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code>ï¼Œä½†æœ‰æ—¶å€™æ•°å€¼å¾ˆå°ï¼Œç”¨ <code class="highlighter-rouge">&lt;encoding&gt;</code> ä¹Ÿèƒ½ä¿å­˜æ•°æ®ï¼Œä¸éœ€è¦ <code class="highlighter-rouge">&lt;entry-data&gt;</code>ï¼Œ å³ <code class="highlighter-rouge">&lt;prevlen&gt; &lt;encoding&gt;</code>ã€‚</p>

<hr />
<p>å‹ç¼©é“¾è¡¨çš„ç»“ç‚¹æœ‰ç‚¹ç‰¹åˆ«ï¼Œè¿™é‡Œçš„é“¾è¡¨ä¸æ˜¯ä¼ ç»Ÿçš„é“¾è¡¨ï¼Œä¼ ç»Ÿçš„é“¾è¡¨æ¯ä¸ªç»“ç‚¹éƒ½æœ‰ prev æˆ–è€… next çš„æŒ‡é’ˆï¼Œè¿æ¥èµ·æ¥ã€‚å‹ç¼©é“¾è¡¨ç»“ç‚¹é€šè¿‡ prevlen åœ¨å†…å­˜ä¸Šè¿›è¡Œå®šä½å‰ä¸€ä¸ªç»“ç‚¹ï¼Œå› ä¸º <a href="#encoding"><code class="highlighter-rouge">&lt;encoding&gt;</code></a> å­˜å‚¨äº†å½“å‰ç»“ç‚¹æ•°æ®ç±»å‹å’Œæ•°æ®é•¿åº¦ï¼Œä»è€Œå¯ä»¥å‘åå®šä½ä¸‹ä¸€ä¸ªç»“ç‚¹ã€‚</p>

<h3 id="23-prevlen">2.3. prevlen</h3>

<table>
  <thead>
    <tr>
      <th>æ¡ä»¶</th>
      <th>é•¿åº¦</th>
      <th>æ ¼å¼</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&lt; 254 å­—èŠ‚</td>
      <td>1 å­—èŠ‚</td>
      <td><code class="highlighter-rouge">&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry-dagta&gt;</code></td>
    </tr>
    <tr>
      <td>&gt;= 254 å­—èŠ‚</td>
      <td>5 å­—èŠ‚</td>
      <td><code class="highlighter-rouge">0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></td>
    </tr>
  </tbody>
</table>

<p>å‰ä¸€ä¸ªç»“ç‚¹é•¿åº¦ï¼Œå­˜å‚¨åœ¨æœ¬ç»“ç‚¹é¦–éƒ¨ï¼Œæœ‰ä¸¤ç§å­˜å‚¨é•¿åº¦ï¼Œ1 å­—èŠ‚æˆ–è€… 5 å­—èŠ‚ç©ºé—´è¿›è¡Œå­˜å‚¨ï¼Œå…·ä½“äº§çœ‹å‰é¢çš„å…·ä½“æè¿°ã€‚</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return the number of bytes used to encode the length of the previous
 * entry. The length is returned by setting the var 'prevlensize'. */</span>
<span class="cp">#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
    if ((ptr)[0] &lt; ZIP_BIG_PREVLEN) {                                          \
        (prevlensize) = 1;                                                     \
    } else {                                                                   \
        (prevlensize) = 5;                                                     \
    }                                                                          \
} while(0);
</span></code></pre></div></div>

<p>prevlen: å‰ä¸€ä¸ªç»“ç‚¹ç»“ç‚¹é•¿åº¦ã€‚
prevlensize: ä¿å­˜ prevlen å ç”¨äº†å¤šå°‘å†…å­˜ï¼ˆ1/5ï¼‰</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return the length of the previous element, and the number of bytes that
 * are used in order to encode the previous element length.
 * 'ptr' must point to the prevlen prefix of an entry (that encodes the
 * length of the previous entry in order to navigate the elements backward).
 * The length of the previous entry is stored in 'prevlen', the number of
 * bytes needed to encode the previous entry length are stored in
 * 'prevlensize'. */</span>
<span class="cp">#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
    if ((prevlensize) == 1) {                                                  \
        (prevlen) = (ptr)[0];                                                  \
    } else if ((prevlensize) == 5) {                                           \
        assert(sizeof((prevlen)) == 4);                                    \
        memcpy(&amp;(prevlen), ((char*)(ptr)) + 1, 4);                             \
        memrev32ifbe(&amp;prevlen);                                                \
    }                                                                          \
} while(0);
</span></code></pre></div></div>

<h3 id="24-encoding">2.4. encoding</h3>

<p>ç¼–ç æœ‰ä¸¤ç§ç±»å‹ï¼šå­—ç¬¦ä¸²/æ•´æ•°</p>
<blockquote>
  <p>The encoding field of the entry depends on the content of the entry. When the entry is a string, the first 2 bits of the encoding first byte will hold the type of encoding used to store the length of the string, followed by the actual length of the string. When the entry is an integer the first 2 bits are both set to 1. The following 2 bits are used to specify what kind of integer will be stored after this header. An overview of the different types and encodings is as follows. The first byte is always enough to determine the kind of entry.</p>

</blockquote>

<h4 id="241-å­—ç¬¦ä¸²">2.4.1. å­—ç¬¦ä¸²</h4>

<p>å¦‚æœå½“ç»“ç‚¹å†…å®¹æ˜¯å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆ <code class="highlighter-rouge">&lt;encoding&gt;</code> å‰ä¸¤ä¸ª bit ä¸»è¦ç”¨æ¥å­˜å‚¨ç¼–ç ç±»å‹ï¼Œå‰©ä¸‹çš„ä¿å­˜å½“å‰å­—ç¬¦ä¸²çš„å­—ç¬¦ä¸²é•¿åº¦ã€‚ä» <code class="highlighter-rouge">&lt;encoding&gt;</code> å¯ä»¥è·å¾— 3 ä¸ªä¿¡æ¯ï¼š</p>

<ol>
  <li>ç¼–ç ç±»å‹ã€‚</li>
  <li>ç»“ç‚¹æ•°æ®å†…å®¹é•¿åº¦ã€‚</li>
  <li>æ•´ä¸ª <code class="highlighter-rouge">&lt;encoding&gt;</code> é•¿åº¦ã€‚</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: left">æ ‡è¯†</th>
      <th style="text-align: left">encoding é•¿åº¦</th>
      <th>å­—ç¬¦ä¸²é•¿åº¦</th>
      <th style="text-align: left">æè¿°</th>
      <th style="text-align: left">æ³¨æ„</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">|00pppppp|</td>
      <td style="text-align: left">1 byte</td>
      <td>&lt;= 63 å­—èŠ‚(6 bits)</td>
      <td style="text-align: left">encoding ç”¨ä¸€ä¸ªå­—èŠ‚ä¿å­˜ï¼Œå‰ 2 ä¸ª bitæ˜¯ 0ï¼Œåé¢ 6 ä¸ª bit ä¿å­˜å­—ç¬¦ä¸²é•¿åº¦</td>
      <td style="text-align: left">Â </td>
    </tr>
    <tr>
      <td style="text-align: left">|01pppppp|qqqqqqqq|</td>
      <td style="text-align: left">2 bytes</td>
      <td>&lt;= 16383 å­—èŠ‚(14 bits)</td>
      <td style="text-align: left">encoding å‰ 2 ä¸ª bitæ˜¯ 0ï¼Œç´§æ¥ç€åé¢ 6 ä¸ª bit ä¿å­˜å­—ç¬¦ä¸²é•¿åº¦ã€‚</td>
      <td style="text-align: left">14 bit æ•°å€¼ç”¨å¤§ç«¯æ–¹å¼ä¿å­˜</td>
    </tr>
    <tr>
      <td style="text-align: left">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td>
      <td style="text-align: left">5 bytes</td>
      <td>&gt;= 16384 å­—èŠ‚</td>
      <td style="text-align: left">encoding å‰é¢ä¸€ä¸ªå­—èŠ‚æ˜¯æ ‡è¯†ï¼Œåé¢ 4 ä¸ªå­—èŠ‚ä¿å­˜å­—ç¬¦ä¸²é•¿åº¦ã€‚</td>
      <td style="text-align: left">é•¿åº¦æ•°å€¼ç”¨å¤§ç«¯æ¨¡å¼ä¿å­˜</td>
    </tr>
  </tbody>
</table>

<p>åˆ¤æ–­å­—èŠ‚å‰é¢ä¸¤ä¸ª bit æ˜¯å¦ä¸º 1ï¼Œå¦‚æœä¸æ˜¯å°±æ˜¯å­—ç¬¦ä¸²ã€‚ZIP_STR_MASK = â€œ1100 0000â€</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Extract the encoding from the byte pointed by 'ptr' and set it into
 * 'encoding' field of the zlentry structure. */</span>
<span class="cp">#define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
    (encoding) = (ptr[0]); \
    if ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \
} while(0)
</span></code></pre></div></div>

<h4 id="242-æ•°å€¼">2.4.2. æ•°å€¼</h4>

<p>å½“ç»“ç‚¹å†…å®¹æ˜¯æ•°å€¼ï¼Œ<code class="highlighter-rouge">&lt;encoding&gt;</code> å‰ä¸¤ä¸ª bit è®¾ç½®æˆ <code class="highlighter-rouge">1</code>ï¼Œæ¥ä¸‹æ¥ä¸¤ä¸ª bit ç”¨æ¥ä¿å­˜æ•°å€¼ç±»å‹ã€‚ä» <code class="highlighter-rouge">&lt;encoding&gt;</code> å¯ä»¥è·å¾— 3 ä¸ªä¿¡æ¯ï¼š</p>

<ol>
  <li>ç¼–ç ç±»å‹ã€‚</li>
  <li>æ•°å€¼ç±»å‹ã€‚</li>
  <li>æ•°å€¼ã€‚</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: left">é¦–å­—èŠ‚æ ‡è¯†</th>
      <th style="text-align: left">encoding é•¿åº¦</th>
      <th style="text-align: left">æ•°å€¼é•¿åº¦</th>
      <th style="text-align: left">æè¿°</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">|11000000|</td>
      <td style="text-align: left">3 bytes</td>
      <td style="text-align: left">2 bytes</td>
      <td style="text-align: left">int16_t</td>
    </tr>
    <tr>
      <td style="text-align: left">|11010000|</td>
      <td style="text-align: left">5 bytes</td>
      <td style="text-align: left">4 bytes</td>
      <td style="text-align: left">int32_t</td>
    </tr>
    <tr>
      <td style="text-align: left">|11100000|</td>
      <td style="text-align: left">9 bytes</td>
      <td style="text-align: left">8 bytes</td>
      <td style="text-align: left">int64_t</td>
    </tr>
    <tr>
      <td style="text-align: left">|11110000|</td>
      <td style="text-align: left">4 bytes</td>
      <td style="text-align: left">3 bytes</td>
      <td style="text-align: left">Integer encoded as 24 bit signed (3 bytes).</td>
    </tr>
    <tr>
      <td style="text-align: left">|11111110|</td>
      <td style="text-align: left">2 bytes</td>
      <td style="text-align: left">1 byte</td>
      <td style="text-align: left">Integer encoded as 8 bit signed (1 byte).</td>
    </tr>
    <tr>
      <td style="text-align: left">|1111xxxx|</td>
      <td style="text-align: left">1 byte</td>
      <td style="text-align: left">4 bits</td>
      <td style="text-align: left">4 bit integer, å¯ä»¥å­˜å‚¨ 0 - 12ï¼Œ å› ä¸º 0000ï¼Œ1110ï¼Œ1111 ä¸èƒ½ä½¿ç”¨ï¼Œåªèƒ½å­˜å‚¨ 1 - 13ï¼Œæ‰€ä»¥ä¿å­˜è¿›æ¥çš„æ•°å­—è¿›è¡Œ + 1 æ“ä½œï¼Œè§£æåéœ€è¦ -1</td>
    </tr>
    <tr>
      <td style="text-align: left">|11111111|</td>
      <td style="text-align: left">1 byte</td>
      <td style="text-align: left">0 bit</td>
      <td style="text-align: left">åˆ—è¡¨ç»“æŸç¬¦</td>
    </tr>
  </tbody>
</table>

<h4 id="243-ç¼–è§£ç å®ç°">2.4.3. ç¼–è§£ç å®ç°</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#define ZIP_STR_MASK 0xc0
#define ZIP_INT_MASK 0x30
#define ZIP_STR_06B (0 &lt;&lt; 6)
#define ZIP_STR_14B (1 &lt;&lt; 6)
#define ZIP_STR_32B (2 &lt;&lt; 6)
#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4)
#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4)
#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4)
#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4)
#define ZIP_INT_8B 0xfe
</span>
<span class="cm">/* Macro to determine if the entry is a string. String entries never start
 * with "11" as most significant bits of the first byte. */</span>
<span class="cp">#define ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)
</span>
<span class="cm">/* Write the encoidng header of the entry in 'p'. If p is NULL it just returns
 * the amount of bytes required to encode such a length. Arguments:
 *
 * 'encoding' is the encoding we are using for the entry. It could be
 * ZIP_INT_* or ZIP_STR_* or between ZIP_INT_IMM_MIN and ZIP_INT_IMM_MAX
 * for single-byte small immediate integers.
 *
 * 'rawlen' is only used for ZIP_STR_* encodings and is the length of the
 * srting that this entry represents.
 *
 * The function returns the number of bytes used by the encoding/length
 * header stored in 'p'. */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">zipStoreEntryEncoding</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rawlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ZIP_IS_STR</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* Although encoding is given it may not be set for strings,
         * so we determine it here using the raw length. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&lt;=</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZIP_STR_06B</span> <span class="o">|</span> <span class="n">rawlen</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&lt;=</span> <span class="mh">0x3fff</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZIP_STR_14B</span> <span class="o">|</span> <span class="p">((</span><span class="n">rawlen</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">);</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rawlen</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZIP_STR_32B</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawlen</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
            <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">rawlen</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Implies integer encoding, so length is always 1. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Store this length at p. */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 'encoding' field of the zlentry structure. */</span>
<span class="cp">#define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
    (encoding) = (ptr[0]); \
    // å¦‚æœæ˜¯å­—ç¬¦ä¸²ç±»å‹ï¼Œå–å‰é¢ä¸¤ä¸ª bitï¼Œå…¶å®ƒ bit æ˜¯ 0 \
    if ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \
} while(0)
</span>
<span class="cp">#define ZIP_INT_IMM_MIN 0xf1    </span><span class="cm">/* 11110001 */</span><span class="cp">
#define ZIP_INT_IMM_MAX 0xfd    </span><span class="cm">/* 11111101 */</span><span class="cp">
</span>
<span class="cm">/* Return bytes needed to store integer encoded by 'encoding'. */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">zipIntSize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ZIP_INT_8B</span><span class="p">:</span>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ZIP_INT_16B</span><span class="p">:</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ZIP_INT_24B</span><span class="p">:</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ZIP_INT_32B</span><span class="p">:</span> <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ZIP_INT_64B</span><span class="p">:</span> <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">&gt;=</span> <span class="n">ZIP_INT_IMM_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">encoding</span> <span class="o">&lt;=</span> <span class="n">ZIP_INT_IMM_MAX</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* 4 bit immediate */</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"Invalid integer encoding 0x%02X"</span><span class="p">,</span> <span class="n">encoding</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Store integer 'value' at 'p', encoded as 'encoding' */</span>
<span class="kt">void</span> <span class="nf">zipSaveInteger</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int16_t</span> <span class="n">i16</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">i32</span><span class="p">;</span>
    <span class="kt">int64_t</span> <span class="n">i64</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_8B</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">((</span><span class="kt">int8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_16B</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i16</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i16</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i16</span><span class="p">));</span>
        <span class="n">memrev16ifbe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_24B</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i32</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">memrev32ifbe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i32</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_32B</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i32</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i32</span><span class="p">));</span>
        <span class="n">memrev32ifbe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">ZIP_INT_64B</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i64</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i64</span><span class="p">));</span>
        <span class="n">memrev64ifbe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">&gt;=</span> <span class="n">ZIP_INT_IMM_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">encoding</span> <span class="o">&lt;=</span> <span class="n">ZIP_INT_IMM_MAX</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Nothing to do, the value is stored in the encoding itself. */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Decode the entry encoding type and data length (string length for strings,
 * number of bytes used for the integer for integer entries) encoded in 'ptr'.
 * The 'encoding' variable will hold the entry encoding, the 'lensize'
 * variable will hold the number of bytes required to encode the entry
 * length, and the 'len' variable will hold the entry length. */</span>
<span class="cp">#define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
    if ((encoding) &lt; ZIP_STR_MASK) {                                           \
        if ((encoding) == ZIP_STR_06B) {                                       \
            (lensize) = 1;                                                     \
            (len) = (ptr)[0] &amp; 0x3f;                                           \
        } else if ((encoding) == ZIP_STR_14B) {                                \
            (lensize) = 2;                                                     \
            (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \
        } else if ((encoding) == ZIP_STR_32B) {                                \
            (lensize) = 5;                                                     \
            (len) = ((ptr)[1] &lt;&lt; 24) |                                         \
                    ((ptr)[2] &lt;&lt; 16) |                                         \
                    ((ptr)[3] &lt;&lt;  8) |                                         \
                    ((ptr)[4]);                                                \
        } else {                                                               \
            panic("Invalid string encoding 0x%02X", (encoding));               \
        }                                                                      \
    } else {                                                                   \
        (lensize) = 1;                                                         \
        (len) = zipIntSize(encoding);                                          \
    }                                                                          \
} while(0);
</span></code></pre></div></div>

<hr />

<h2 id="3-è°ƒè¯•">3. è°ƒè¯•</h2>

<p>æˆ‘ä»¬å¯ä»¥å…ˆé€šè¿‡è°ƒè¯•å»èµ°ä¸€æ¬¡ç¨‹åºé€»è¾‘ï¼Œè§‚å¯Ÿè¯¥æ•°æ®ç»“æ„çš„å†…å­˜ç®¡ç†ï¼Œäº†è§£ä¸‹ <code class="highlighter-rouge">ziplistNew</code>ï¼Œ <code class="highlighter-rouge">ziplistPush</code> ç­‰æ¥å£çš„å·¥ä½œæµç¨‹ã€‚</p>
<blockquote>
  <p>è°ƒè¯•ä¸ºäº†ç¼–è¯‘é€šè¿‡ï¼Œé€‚å½“å¢å‡éƒ¨åˆ†ä»£ç ã€‚</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-g</span> ziplist.c sds.c zmalloc.c util.c sha1.c <span class="nt">-o</span> ziplist  <span class="nt">-I</span>../deps/lua/src
<span class="nb">sudo </span>gdb ziplist
</code></pre></div></div>

<p><img src="/images/2020-02-20-16-45-03.png" alt="è°ƒè¯•" data-action="zoom" /></p>

<hr />

<h3 id="31-è°ƒè¯•ä¸­é—´æ’å…¥ç»“ç‚¹">3.1. è°ƒè¯•ä¸­é—´æ’å…¥ç»“ç‚¹</h3>

<p>è¯¦ç»†å¯ä»¥æŸ¥çœ‹ ziplistInsert æ¥å£æºç </p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">createTestlist</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistNew</span><span class="p">();</span>
    <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistPush</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="s">"2"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ZIPLIST_TAIL</span><span class="p">);</span>
    <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistPush</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="s">"5"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ZIPLIST_TAIL</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">test</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="p">));</span>

    <span class="c1">// æ’å…¥ä¸­é—´</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ziplistIndex</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">ziplistNext</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistInsert</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">zl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span> <span class="o">=</span> <span class="n">createTestlist</span><span class="p">();</span>
    <span class="n">ziplistRepr</span><span class="p">(</span><span class="n">zl</span><span class="p">);</span>
    <span class="n">zfree</span><span class="p">(</span><span class="n">zl</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ç»“æœ</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>total bytes 1046<span class="o">}</span> <span class="o">{</span>num entries 3<span class="o">}</span>
<span class="o">{</span><span class="nb">tail </span>offset 1039<span class="o">}</span>
<span class="o">{</span>
        addr 0x7fb31680060a,
        index  0,
        offset    10,
        hdr+entry len:     2,
        hdr len 2,
        prevrawlen:     0,
        prevrawlensize:  1,
        payload     0
        bytes: 00|f3|
        <span class="o">[</span>int]2
<span class="o">}</span>
<span class="o">{</span>
        addr 0x7fb31680060c,
        index  1,
        offset    12,
        hdr+entry len:  1027,
        hdr len 3,
        prevrawlen:     2,
        prevrawlensize:  1,
        payload  1024
        bytes: 02|44|00|61|61|...|61|
        <span class="o">[</span>str]aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
<span class="o">}</span>
<span class="o">{</span>
        addr 0x7fb316800a0f,
        index  2,
        offset  1039,
        hdr+entry len:     6,
        hdr len 6,
        prevrawlen:  1027,
        prevrawlensize:  5,
        payload     0
        bytes: fe|03|04|00|00|f6|
        <span class="o">[</span>int]5
<span class="o">}</span>
<span class="o">{</span>end<span class="o">}</span>
</code></pre></div></div>

<p>ä¸»è¦ç”»äº†éƒ¨åˆ†ä»¤äººè´¹è§£çš„åœ°æ–¹ã€‚</p>

<p><img src="/images/2020-02-20-16-45-26.png" alt="æ’å…¥æµç¨‹" data-action="zoom" /></p>

<hr />

<h2 id="4-æ¥å£">4. æ¥å£</h2>

<p>å¯ä»¥é€šè¿‡ <code class="highlighter-rouge">sorted set</code> ï¼ˆt_zset.cï¼‰æºç ç†è§£ <code class="highlighter-rouge">ziplist</code> çš„ä½¿ç”¨ã€‚</p>

<h3 id="41-æ’å…¥ç»“ç‚¹">4.1. æ’å…¥ç»“ç‚¹</h3>

<p>æ ¹æ® p æŒ‡å®šçš„ä½ç½®ï¼Œæ’å…¥æ•°æ®ã€‚</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Insert item at "p". */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__ziplistInsert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slen</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// è·å–å½“å‰æ•´ä¸ªå†…å­˜é•¿åº¦</span>
    <span class="kt">size_t</span> <span class="n">curlen</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_BYTES</span><span class="p">(</span><span class="n">zl</span><span class="p">)),</span> <span class="n">reqlen</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prevlensize</span><span class="p">,</span> <span class="n">prevlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nextdiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">123456789</span><span class="p">;</span> <span class="cm">/* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. */</span>
    <span class="n">zlentry</span> <span class="n">tail</span><span class="p">;</span>

    <span class="c1">// å¦‚æœä¸æ˜¯ç»“æŸç»“ç‚¹ï¼Œé‚£ä¹ˆå°±ä»å½“å‰ç»“ç‚¹è·å–å‰ä¸€ä¸ªç»“ç‚¹çš„é•¿åº¦ã€‚å¦‚æœæ˜¯ç»“æŸç»“ç‚¹ï¼Œå°±å–æœ«ç»“ç‚¹é•¿åº¦ï¼ˆæœ«ç»“ç‚¹ä¸æ˜¯ç»“æŸç»“ç‚¹ï¼‰ã€‚</span>
    <span class="cm">/* Find out prevlen for the entry that is inserted. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ZIP_DECODE_PREVLEN</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prevlensize</span><span class="p">,</span> <span class="n">prevlen</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// æœ«ç»“ç‚¹</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptail</span> <span class="o">=</span> <span class="n">ZIPLIST_ENTRY_TAIL</span><span class="p">(</span><span class="n">zl</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">prevlen</span> <span class="o">=</span> <span class="n">zipRawEntryLength</span><span class="p">(</span><span class="n">ptail</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// è·å–å†…å®¹é•¿åº¦ï¼Œå­—ç¬¦ä¸²ä¼šå…ˆå°è¯•è½¬åŒ–ä¸ºæ•´å‹ã€‚</span>
    <span class="cm">/* See if the entry can be encoded */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">zipTryEncoding</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">slen</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="o">&amp;</span><span class="n">encoding</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 'encoding' is set to the appropriate integer encoding */</span>
        <span class="n">reqlen</span> <span class="o">=</span> <span class="n">zipIntSize</span><span class="p">(</span><span class="n">encoding</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 'encoding' is untouched, however zipStoreEntryEncoding will use the
         * string length to figure out how to encode it. */</span>
        <span class="n">reqlen</span> <span class="o">=</span> <span class="n">slen</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* We need space for both the length of the previous entry and
     * the length of the payload. */</span>
    <span class="n">reqlen</span> <span class="o">+=</span> <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">prevlen</span><span class="p">);</span>
    <span class="n">reqlen</span> <span class="o">+=</span> <span class="n">zipStoreEntryEncoding</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">encoding</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>

    <span class="c1">// æ’å…¥ä½ç½®çš„åä¸€ä¸ªç»“ç‚¹çš„&lt;prevlen&gt;å‘ç”Ÿæ”¹å˜ï¼Œ nextdiff è®¡ç®— &lt;prevlen&gt; çš„ lensize ç›¸å·®å¤šå°‘ã€‚</span>
    <span class="cm">/* When the insert position is not equal to the tail, we need to
     * make sure that the next entry can hold this entry's length in
     * its prevlen field. */</span>
    <span class="kt">int</span> <span class="n">forcelarge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">nextdiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="o">?</span> <span class="n">zipPrevLenByteDiff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">reqlen</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// å‡å°‘æ’å…¥ä½ç½®åç»­ç»“ç‚¹çš„ &lt;prevlen&gt; lensize è¿é”ååº”é¢‘ç¹è°ƒç”¨ ziplistResize æŸè€—æ€§èƒ½ã€‚å¼ºåˆ¶ forcelarge å†™å…¥ã€‚</span>
    <span class="c1">// è¯¥é—®é¢˜ï¼Œè¯¦è§ï¼šhttps://segmentfault.com/a/1190000018878466?utm_source=tag-newest</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextdiff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">reqlen</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nextdiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">forcelarge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Store offset because a realloc may change the address of zl. */</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">;</span>
    <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistResize</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="n">curlen</span><span class="o">+</span><span class="n">reqlen</span><span class="o">+</span><span class="n">nextdiff</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">zl</span><span class="o">+</span><span class="n">offset</span><span class="p">;</span>

    <span class="cm">/* Apply memory move when necessary and update tail offset. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Subtract one because of the ZIP_END bytes */</span>
        <span class="n">memmove</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span><span class="n">p</span><span class="o">-</span><span class="n">nextdiff</span><span class="p">,</span><span class="n">curlen</span><span class="o">-</span><span class="n">offset</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">nextdiff</span><span class="p">);</span>

        <span class="cm">/* Encode this entry's raw length in the next entry. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">forcelarge</span><span class="p">)</span>
            <span class="n">zipStorePrevEntryLengthLarge</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span><span class="n">reqlen</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span><span class="n">reqlen</span><span class="p">);</span>

        <span class="cm">/* Update offset for tail */</span>
        <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span>
            <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">))</span><span class="o">+</span><span class="n">reqlen</span><span class="p">);</span>

        <span class="cm">/* When the tail contains more than one entry, we need to take
         * "nextdiff" in account as well. Otherwise, a change in the
         * size of prevlen doesn't have an effect on the *tail* offset. */</span>
        <span class="n">zipEntry</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">reqlen</span><span class="o">+</span><span class="n">tail</span><span class="p">.</span><span class="n">headersize</span><span class="o">+</span><span class="n">tail</span><span class="p">.</span><span class="n">len</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span>
                <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">))</span><span class="o">+</span><span class="n">nextdiff</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* This element will be the new tail. */</span>
        <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// &lt;entr&gt; ä¿å­˜äº† &lt;prevlen&gt;ï¼Œå‰ç»“ç‚¹æ”¹å˜äº†ï¼Œå¯¼è‡´é•¿åº¦ä¹Ÿæ”¹å˜äº†ï¼Œåé¢çš„ç»“ç‚¹è¿é”åæ˜ ï¼Œä¹Ÿéœ€è¦ä¿®æ”¹ &lt;prevlen&gt;</span>
    <span class="cm">/* When nextdiff != 0, the raw length of the next entry has changed, so
     * we need to cascade the update throughout the ziplist */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextdiff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">;</span>
        <span class="n">zl</span> <span class="o">=</span> <span class="n">__ziplistCascadeUpdate</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">zl</span><span class="o">+</span><span class="n">offset</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Write the entry */</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">prevlen</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="n">zipStoreEntryEncoding</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">encoding</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ZIP_IS_STR</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">zipSaveInteger</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">encoding</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ZIPLIST_INCR_LENGTH</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">zl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="5-é—®é¢˜">5. é—®é¢˜</h2>

<ul>
  <li>
    <p>åˆ†é…å†…å­˜
<code class="highlighter-rouge">ziplist</code> æ’å…¥åˆ é™¤æ•°æ®éœ€è¦é‡æ–°åˆ†é…å†…å­˜ã€‚</p>
  </li>
  <li>
    <p>è€¦åˆé—®é¢˜
<code class="highlighter-rouge">ziplist</code> ä¸ºäº†åœ¨è¿ç»­å†…å­˜ä¸Šè¿›è¡Œæ•°æ®ç®¡ç†ï¼Œå¯¹æ•°æ®è¿›è¡Œå‹ç¼©ï¼ŒèŠ‚çœå†…å­˜å¼€é”€ï¼Œä¹Ÿå‡å°‘å†…å­˜ç¢ç‰‡ã€‚ä½†æ˜¯ prevlen ä½œä¸ºæ•°æ®ç»“ç‚¹å¯¹ç»„æˆéƒ¨åˆ†ï¼Œè·Ÿå…¶å®ƒç»“ç‚¹ä¸¥é‡è€¦åˆï¼Œåªè¦åœ¨é“¾è¡¨ä¸­é—´æ’å…¥æˆ–è€…åˆ é™¤ç»“ç‚¹ï¼Œæœ‰å¯èƒ½éœ€è¦éå†æ›´æ–°æ’å…¥æˆ–åˆ é™¤ä½ç½®åç»­çš„æ‰€æœ‰ç»“ç‚¹ <code class="highlighter-rouge">&lt;prevlen&gt;</code>ã€‚</p>
  </li>
  <li>
    <p>æ•ˆç‡é—®é¢˜
åˆ—è¡¨é‡ç‚¹æ˜¯å‹ç¼©ï¼Œæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œæ’å…¥åˆ é™¤æ•°æ®ï¼Œæ•ˆç‡ä¸é«˜ï¼Œéœ€è¦é‡æ–°åˆ†é…å†…å­˜ã€‚å› ä¸ºæ˜¯åˆ—è¡¨ï¼ŒæŸ¥æ‰¾ç»“ç‚¹å¤æ‚åº¦$O(n)$ã€‚åœ¨ <code class="highlighter-rouge">sorted set</code> çš„å®ç°ä¸­ï¼Œå¯¹ <code class="highlighter-rouge">skiplist</code> çš„ä½¿ç”¨æ˜¯æœ‰é™åˆ¶çš„ã€‚</p>
  </li>
</ul>

<p>redis.conf</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zset-max-ziplist-entries 128
zset-max-ziplist-value 64
</code></pre></div></div>

<p>t_zset.c</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">zaddGenericCommand</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">zobj</span> <span class="o">=</span> <span class="n">lookupKeyWrite</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">zobj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="k">goto</span> <span class="n">reply_to_client</span><span class="p">;</span> <span class="cm">/* No key + XX option: nothing to do. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">zset_max_ziplist_entries</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
            <span class="n">server</span><span class="p">.</span><span class="n">zset_max_ziplist_value</span> <span class="o">&lt;</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">scoreidx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">zobj</span> <span class="o">=</span> <span class="n">createZsetObject</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">zobj</span> <span class="o">=</span> <span class="n">createZsetZiplistObject</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">dbAdd</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">zobj</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">zobj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">OBJ_ZSET</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">wrongtypeerr</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zsetAdd</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">zobj</span><span class="p">,</span> <span class="kt">double</span> <span class="n">score</span><span class="p">,</span> <span class="n">sds</span> <span class="n">ele</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">newscore</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">zobj</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">zzlInsert</span><span class="p">(</span><span class="n">zobj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">ele</span><span class="p">,</span><span class="n">score</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">zzlLength</span><span class="p">(</span><span class="n">zobj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">zset_max_ziplist_entries</span> <span class="o">||</span>
        <span class="n">sdslen</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">zset_max_ziplist_value</span><span class="p">)</span>
        <span class="n">zsetConvert</span><span class="p">(</span><span class="n">zobj</span><span class="p">,</span><span class="n">OBJ_ENCODING_SKIPLIST</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>å¤æ‚åº¦
æŒ‡é’ˆçš„åç§»è€ƒéªŒçš„æ˜¯æŠ€æœ¯åŠŸåº•ã€‚<code class="highlighter-rouge">ziplist</code> å®ç°ç®—æ˜¯æ¯”è¾ƒå¤æ‚äº†ï¼ˆå¯¹æˆ‘è€Œè¨€ï¼‰ã€‚å¦‚æœç”¨ä¼ ç»Ÿçš„åŒå‘é“¾è¡¨å®ç°è¦ç®€å•ä¸å°‘çš„ï¼Œå‹ç¼©ç›®çš„è¿˜æ˜¯èƒ½è¾¾åˆ°çš„ï¼Œç»“ç‚¹é—´çš„è€¦åˆæ¯”è¾ƒå°ã€‚</li>
</ul>

<hr />

<h2 id="6-å‚è€ƒ">6. å‚è€ƒ</h2>

<ul>
  <li>
    <p><a href="https://blog.csdn.net/yasi_xi/article/details/9263955">gdbä¸­çœ‹å†…å­˜(xå‘½ä»¤)</a></p>
  </li>
  <li>
    <p><a href="https://segmentfault.com/a/1190000018878466?utm_source=tag-newest">Redisçš„ä¸€ä¸ªå†å²bugåŠå…¶åç»­æ”¹è¿›</a></p>
  </li>
  <li>
    <p><a href="https://github.com/wenfh2020/redis/commit/c495d095ae495ea5253443ee4562aaa30681a854?diff=unified">Ziplist: insertion bug under particular conditions fixed.</a></p>
  </li>
</ul>

<hr />

<blockquote>
  <p>ğŸ”¥æ–‡ç« æ¥æºï¼š<a href="https://wenfh2020.com/">wenfh2020.com</a></p>
</blockquote>
:ET