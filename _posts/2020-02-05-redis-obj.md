---
layout: post
title:  "[redis æºç èµ°è¯»] å¯¹è±¡(redisObject)"
categories: redis
tags: redis object
author: wenfh2020
---

redis æ•°æ®ï¼ˆ`key-value`ï¼‰ï¼Œ`value` å¾€å¾€æ˜¯å¯¹è±¡çš„å½¢å¼å­˜åœ¨ï¼ˆ`redisObject`ï¼‰ã€‚



* content
{:toc}

---

## 1. å¯¹è±¡

![å¯¹è±¡å…³ç³»](/images/2020-02-20-14-09-19.png){: data-action="zoom"}

### 1.1. æ•°æ®ç»“æ„

```c
typedef struct redisObject {
    // å¯¹è±¡ç±»å‹
    unsigned type:4;
    // å¯¹è±¡ç¼–ç ç±»å‹
    unsigned encoding:4;
    // å¯¹è±¡æ“ä½œæ—¶é—´
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    // ä½¿ç”¨è®¡æ•°
    int refcount;
    // æ•°æ®å†…å®¹
    void *ptr;
} robj;
```

---

### 1.2. ç±»å‹ï¼ˆtypeï¼‰

```c
/* The actual Redis Object */
#define OBJ_STRING 0    /* String object. */
#define OBJ_LIST 1      /* List object. */
#define OBJ_SET 2       /* Set object. */
#define OBJ_ZSET 3      /* Sorted set object. */
#define OBJ_HASH 4      /* Hash object. */
```

---

### 1.3. ç¼–ç ï¼ˆencodingï¼‰

```c
/* Objects encoding. Some kind of objects like Strings and Hashes can be
 * internally represented in multiple ways. The 'encoding' field of the object
 * is set to one of this fields for this object. */
#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */
#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */
#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
```

---

### 1.4. å¼•ç”¨è®¡æ•°ï¼ˆrefcountï¼‰

ä¸ºäº†å†…å­˜èƒ½é‡å¤ä½¿ç”¨ï¼ŒèŠ‚çœå†…å­˜ç©ºé—´ï¼Œredis æ•°æ®å¯¹è±¡å¯èƒ½è¢«å…±äº«ï¼Œé€šè¿‡å¼•ç”¨è®¡æ•°ï¼Œç»Ÿè®¡å¯¹è±¡è¢«å¼•ç”¨çš„æ¬¡æ•°ã€‚åœ¨å†…å­˜å›æ”¶æ—¶ï¼Œå½“å¼•ç”¨è®¡æ•°ä¸º 1ï¼Œè¯´æ˜æ²¡æœ‰å…¶å®ƒé€»è¾‘æ­£åœ¨ä½¿ç”¨å®ƒï¼Œå¯ä»¥è¿›è¡Œå›æ”¶é”€æ¯ã€‚

object.c

```c
void incrRefCount(robj *o) {
    if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount++;
}

void decrRefCount(robj *o) {
    if (o->refcount == 1) {
        switch(o->type) {
        case OBJ_STRING: freeStringObject(o); break;
        case OBJ_LIST: freeListObject(o); break;
        case OBJ_SET: freeSetObject(o); break;
        case OBJ_ZSET: freeZsetObject(o); break;
        case OBJ_HASH: freeHashObject(o); break;
        case OBJ_MODULE: freeModuleObject(o); break;
        case OBJ_STREAM: freeStreamObject(o); break;
        default: serverPanic("Unknown object type"); break;
        }
        zfree(o);
    } else {
        if (o->refcount <= 0) serverPanic("decrRefCount against refcount <= 0");
        if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount--;
    }
}

void freeStreamObject(robj *o) {
    freeStream(o->ptr);
}
```

---

### 1.5. æœ€è¿‘æ“ä½œæ—¶é—´ï¼ˆlruï¼‰

lru ä¸»è¦æ˜¯è®°å½•å¯¹è±¡çš„æœ€è¿‘ä½¿ç”¨æ—¶é—´å’Œä½¿ç”¨é¢‘ç‡ï¼Œå…·ä½“ç”¨æ³•å¯ä»¥å‚è€ƒ [[redis æºç èµ°è¯»] maxmemory æ•°æ®æ·˜æ±°ç­–ç•¥](https://wenfh2020.com/2020/03/06/redis-max-memory/)

---

## 2. åˆ›å»ºå¯¹è±¡

```c
robj *createObject(int type, void *ptr) {
    robj *o = zmalloc(sizeof(*o));
    o->type = type;
    o->encoding = OBJ_ENCODING_RAW;
    o->ptr = ptr;
    o->refcount = 1;

    /* Set the LRU to the current lruclock (minutes resolution), or
     * alternatively the LFU counter. */
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;
    } else {
        o->lru = LRU_CLOCK();
    }
    return o;
}
```

## 3. å·¥ä½œæµç¨‹

å¯¹è±¡å®ç°å¯ä»¥é€šè¿‡è°ƒè¯•ï¼Œçœ‹çœ‹å®ç°é€»è¾‘ã€‚åˆšçœ‹å®Œ[æ•´æ•°é›†åˆ](https://wenfh2020.com/2020/02/04/redis-inset/)ï¼Œå¯ä»¥è·Ÿè¸ªä¸‹å®ç°æµç¨‹ã€‚

### 3.1. å‘½ä»¤

```shell
sadd keytest 1 2 3
```

---

### 3.2. å †æ ˆ

ä¸‹æ–­ç‚¹çœ‹çœ‹å‘½ä»¤å·¥ä½œæµç¨‹

```c
intsetNew() (/Users/xxx/src/other/redis/src/intset.c:100)
createIntsetObject() (/Users/xxx/src/other/redis/src/object.c:236)
setTypeCreate(sds value) (/Users/xxx/src/other/redis/src/t_set.c:44)
saddCommand(client * c) (/Users/xxx/src/other/redis/src/t_set.c:270)
...
aeMain(aeEventLoop * eventLoop) (/Users/xxx/src/other/redis/src/ae.c:515)
main(int argc, char ** argv) (/Users/xxx/src/other/redis/src/server.c:5054)
```

---

### 3.3. å‘½ä»¤ç»“æ„

```c
struct redisCommand {
    char *name;
    redisCommandProc *proc;
    int arity;
    char *sflags;   /* Flags as string representation, one char per flag. */
    uint64_t flags; /* The actual flags, obtained from the 'sflags' field. */
    /* Use a function to determine keys arguments in a command line.
     * Used for Redis Cluster redirect. */
    redisGetKeysProc *getkeys_proc;
    /* What keys should be loaded in background when calling this command? */
    int firstkey; /* The first argument that's a key (0 = no keys) */
    int lastkey;  /* The last argument that's a key */
    int keystep;  /* The step between first and last key */
    long long microseconds, calls;
    int id;     /* Command ID. This is a progressive ID starting from 0 that
                   is assigned at runtime, and is used in order to check
                   ACLs. A connection is able to execute a given command if
                   the user associated to the connection has this command
                   bit set in the bitmap of allowed commands. */
};
```

* åˆå§‹åŒ–å‘½ä»¤

```c

struct redisServer {
    ...
    dict *commands;             /* Command table */
    dict *orig_commands;        /* Command table before command renaming. */
    ...
};

struct redisCommand redisCommandTable[] = {
    ...
    {"sadd",saddCommand,-3,
     "write use-memory fast @set",
     0,NULL,1,1,1,0,0,0},
    ...
}

int main(int argc, char **argv) {
    ...
    initServerConfig();
    ...
}

void initServerConfig(void) {
    ...
    /* Command table -- we initiialize it here as it is part of the
     * initial configuration, since command names may be changed via
     * redis.conf using the rename-command directive. */
    server.commands = dictCreate(&commandTableDictType,NULL);
    server.orig_commands = dictCreate(&commandTableDictType,NULL);
    populateCommandTable();
    server.delCommand = lookupCommandByCString("del");
    ...
}

/* Populates the Redis Command Table starting from the hard coded list
 * we have on top of redis.c file. */
void populateCommandTable(void) {
    int j;
    int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);

    for (j = 0; j < numcommands; j++) {
        struct redisCommand *c = redisCommandTable+j;
        int retval1, retval2;

        /* Translate the command string flags description into an actual
         * set of flags. */
        if (populateCommandTableParseFlags(c,c->sflags) == C_ERR)
            serverPanic("Unsupported command flag");

        c->id = ACLGetCommandID(c->name); /* Assign the ID used for ACL. */
        retval1 = dictAdd(server.commands, sdsnew(c->name), c);
        /* Populate an additional dictionary that will be unaffected
         * by rename-command statements in redis.conf. */
        retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);
        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
    }
}
```

* æ ¹æ®å‘½ä»¤å­—ç¬¦ä¸²ï¼ŒæŸ¥æ‰¾å¯¹åº”çš„ `redisCommand`

```c
int processCommand(client *c) {
    /* Now lookup the command and check ASAP about trivial error conditions
     * such as wrong arity, bad command name and so forth. */
    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);
}
```

* å‘½ä»¤å¤„ç†å‡½æ•°

```c
void saddCommand(client *c) {
    robj *set;
    int j, added = 0;

    // æŸ¥æ‰¾ key æ˜¯å¦å·²ç»å­˜åœ¨
    set = lookupKeyWrite(c->db,c->argv[1]);
    if (set == NULL) {
        // æ ¹æ®å‘½ä»¤æ•°å€¼å»ç¡®å®šå®ç°ç¼–ç ã€‚
        set = setTypeCreate(c->argv[2]->ptr);
        dbAdd(c->db,c->argv[1],set);
    } else {
        if (set->type != OBJ_SET) {
            addReply(c,shared.wrongtypeerr);
            return;
        }
    }

    for (j = 2; j < c->argc; j++) {
        if (setTypeAdd(set,c->argv[j]->ptr)) added++;
    }
    if (added) {
        signalModifiedKey(c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[1],c->db->id);
    }
    server.dirty += added;
    addReplyLongLong(c,added);
}
```

* æ ¹æ®å­˜å‚¨çš„æ•°æ®ï¼Œåº•å±‚å†³å®šç”¨é‚£ç§ç¼–ç è¿›è¡Œä¿å­˜ã€‚

```c
/* Factory method to return a set that *can* hold "value". When the object has
 * an integer-encodable value, an intset will be returned. Otherwise a regular
 * hash table. */
robj *setTypeCreate(sds value) {
    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)
        return createIntsetObject();
    return createSetObject();
}

robj *createIntsetObject(void) {
    intset *is = intsetNew();
    robj *o = createObject(OBJ_SET,is);
    o->encoding = OBJ_ENCODING_INTSET;
    return o;
}

robj *createSetObject(void) {
    dict *d = dictCreate(&setDictType,NULL);
    robj *o = createObject(OBJ_SET,d);
    o->encoding = OBJ_ENCODING_HT;
    return o;
}
```

---

### 3.4. å…¶å®ƒ

ä»¥ä¸Šæ˜¯é›†åˆçš„å·¥ä½œæµç¨‹ï¼Œå…¶å®ƒåŠŸèƒ½ä½¿ç”¨æµç¨‹ä»¥æ­¤ç±»æ¨ï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥èµ°ä¸‹å“ˆå¸ŒåŠŸèƒ½ã€‚ç¼–ç æ˜¯ `dict` å’Œ `ziplist` çš„ç»“åˆã€‚æ¨ä¾‹å¦‚ï¼š

```shell
hset keytest filedtest valuetest
```

```c
robj *createHashObject(void) {
    unsigned char *zl = ziplistNew();
    robj *o = createObject(OBJ_HASH, zl);
    o->encoding = OBJ_ENCODING_ZIPLIST;
    return o;
}

void hsetCommand(client *c) {
    ...
    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
    hashTypeTryConversion(o,c->argv,2,c->argc-1);

    for (i = 2; i < c->argc; i += 2)
        created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,HASH_SET_COPY);
    ...
}

void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
    ...
    for (i = start; i <= end; i++) {
        if (sdsEncodedObject(argv[i]) &&
            sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)
        {
            hashTypeConvert(o, OBJ_ENCODING_HT);
            break;
        }
    }
}

int hashTypeSet(robj *o, sds field, sds value, int flags) {
    int update = 0;

    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
        ...
    } else if (o->encoding == OBJ_ENCODING_HT) {
        ...
    } else {
        serverPanic("Unknown hash encoding");
    }
}
```

---

## 4. åè®°

å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬ç†è§£é¢å‘å¯¹è±¡ï¼Œä¼šå•çº¯è®¤ä¸º `C++`ï¼Œ`java` ç­‰è¯­è¨€ã€‚æ‰€è°“é¢å‘å¯¹è±¡ï¼Œæ˜¯å¯¹äº‹ç‰©é€»è¾‘è¿›è¡ŒæŠ½è±¡ï¼Œæ— å…³è¯­è¨€ï¼Œä¾‹å¦‚ `c`è¯­è¨€å®ç°çš„ `redis` å¯¹è±¡ï¼Œå°±å¾ˆå¥½é˜è¿°äº†è¿™ä¸ªé—®é¢˜ã€‚

---

[redis æºç èµ°è¯»] ç³»åˆ—ï¼Œæ ¹æ® ã€Šredis è®¾è®¡ä¸å®ç°ã€‹ä¹¦ç±çš„ç›®å½•è·¯çº¿ï¼Œç»“åˆç›¸å…³å†…å®¹è¿›è¡Œæºç é˜…è¯»ã€‚è®¡åˆ’äº‹æ— å·¨ç»†èµ°è¯»æºç ï¼Œå‘ç°æ—¶é—´ä¸å…è®¸ï¼Œå¾ˆå¤šç»†èŠ‚åœ¨å®é™…åº”ç”¨ä¸­å¯ä»¥ä¸æ–­æŸ¥é˜…å·©å›ºï¼Œè€Œä¸”ä¸å°‘ä¹¦ç±åšå®¢ä¹Ÿæœ‰å¾ˆè¯¦å°½çš„è§£è¯´ã€‚redis åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œè‡ªå·±è¿˜æœ‰ä¸å°‘ç–‘æƒ‘ï¼Œå¸¦ç€é—®é¢˜ï¼Œåœ¨æŸ¥é˜…è¿‡èµ„æ–™åï¼Œåšä¸€äº›æ€»ç»“ï¼Œä¾¿äºé—å¿˜æŸ¥é˜…ã€‚

---

## 5. å‚è€ƒ

* ã€Šredis è®¾è®¡ä¸å®ç°ã€‹

---

> ğŸ”¥ æ–‡ç« æ¥æºï¼š[wenfh2020.com](https://wenfh2020.com/)
>
> ğŸ‘ å¤§å®¶è§‰å¾—æ–‡ç« å¯¹ä½ æœ‰äº›ä½œç”¨ï¼ å¦‚æœæƒ³ <font color=green>èµèµ</font>ï¼Œå¯ä»¥ç”¨å¾®ä¿¡æ‰«æä¸‹é¢çš„äºŒç»´ç ï¼Œæ„Ÿè°¢!
<div align=center><img src="/images/2020-08-06-15-49-47.png" width="120"/></div>
