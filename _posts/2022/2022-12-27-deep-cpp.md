---
layout: post
title:  "[c++] 深入探索 C++ 多态"
categories: c/c++
author: wenfh2020
---

最近翻阅侯捷先生的两本书：《深度探索 C++ 对象模型》 和 《C++ 虚拟与多态》，获益良多。

要理解多态的工作原理，得理解这几个知识点的关系：`虚函数`、`虚函数表`、`虚函数指针`、以及对象的 `内存布局`。




* content
{:toc}




---

## 1. 概念

本章主要探索 C++ 动态多态，我们先了解一下它的一些相关概念：

* `多态` 是 C++ 中的一个重要概念，它允许在派生类中 `重写` 基类中的函数，并以不同的方式处理相同的数据类型；多态的实现依赖于 `虚函数` 和 `动态绑定`。

* `虚函数` 是一种特殊的成员函数，它允许在派生类中重写基类中的函数。当一个函数被声明为虚函数时，编译器会在该类的虚函数表中添加一个条目，该条目指向该虚函数的地址。如果一个类继承了另一个类的虚函数，那么它将继承该类的虚函数表，并在其中添加自己的虚函数。

* `虚函数表` 是一个包含虚函数地址的表格，每个类都有一个虚函数表。虚函数表中的每个条目都是一个指向虚函数的指针。当一个类包含虚函数时，编译器会在该类的虚函数表中添加一个条目，该条目指向该虚函数的地址。如果一个类继承了另一个类的虚函数，那么它将继承该类的虚函数表，并在其中添加自己的虚函数。

* `虚函数指针` 是一个指向虚函数表的指针，它存储在每个对象的内存中。当一个对象被创建时，它的虚函数指针被初始化为指向该类的虚函数表。当一个虚函数被调用时，编译器会使用虚函数指针来查找该函数在虚函数表中的地址，并调用该函数。

* `动态绑定` 是一种在运行时确定函数调用的机制。当一个函数被声明为虚函数时，编译器会使用动态绑定来确定该函数的实际地址。当一个虚函数被调用时，编译器会使用虚函数指针来查找该函数在虚函数表中的地址，并调用该函数。

> 文字来源：ChatGPT

---

## 2. 实例

概念比较抽象，写个 demo，配合图片凑合着理解~

<div align=center><img src="/images/2023/2023-03-07-13-00-36.png" data-action="zoom"/></div>

* 源码。

```cpp
/* g++ -std='c++11' test.cpp -o t && ./t */
#include <iostream>

class Model {
 public:
    virtual void face() { std::cout << "model's face!" << std::endl; }
};

class Gril : public Model {
 public:
    virtual void face() { std::cout << "girl's face!" << std::endl; }
};

class Man : public Model {
 public:
    virtual void face() { std::cout << "man's face!" << std::endl; }
};

class Boy : public Model {
 public:
    virtual void face() { std::cout << "boy's face!" << std::endl; }
};

void take_photo(Model* m) { m->face(); }

int main() {
    Model* model = new Model;
    Model* girl = new Gril;
    Model* man = new Man;
    Model* boy = new Boy;
    take_photo(model);
    take_photo(girl);
    take_photo(man);
    take_photo(boy);
    return 0;
}
```

* 运行结果。

```shell
model's face!
girl's face!
man's face!
boy's face!
```

---

## 3. 关系链路

```shell
this -> vptr -> vbtl -> virtual function
```

<div align=center><img src="/images/2023/2023-03-26-13-56-36.png" data-action="zoom"></div>

```cpp
struct SA {
  int m_a = 0;
  void funcA() {}
};

class CA {
   public:
    int m_a = 0;
    void funcA() {}
};

class VA {
   public:
    int m_a = 0;
    virtual void funcA() {}
};
```

---

## 4. 工作环境

### 4.1. 系统

```shell
# cat /etc/redhat-release
CentOS Linux release 7.9.2009 (Core)
# cat /proc/version
Linux version 3.10.0-1127.19.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) 
(gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) )
```

---

### 4.2. 工具

<style> table th:first-of-type { width: 150px; } </style>

|工具|描述|
|:--:|:--|
|gdb| gdb 是 GNU 调试器的缩写，是一个用于调试程序的工具。|
|-fdump-class-hierarchy|-fdump-class-hierarchy 是 GCC 的一个编译器选项，用于在编译过程中生成类层次结构的信息。它会将类的继承关系以文本形式输出到一个文件中，以便开发人员可以查看和分析类之间的关系。——这个选项在调试和理解代码中的类继承关系时非常有用。|
|c++filt|c++filt 是一个用于解析C++符号的工具。它可以将由C++编译器生成的符号进行反解析，以便更容易理解和阅读。它可以将由C++编译器生成的符号转换为可读的函数名、类名和变量名。|
|objectdump|objectdump 是一个用于分析目标文件的工具。它可以显示目标文件的各个节（section）的内容，包括代码、数据、符号表等。它还可以反汇编目标文件的机器码，以便更深入地了解程序的执行过程|

> 部分文字来源于：ChatGPT

---

## 5. 多态重要数据结构

我在调试 dynamic_cast 内部源码时，发现一些数据结构：`__class_type_info`，`vtable_prefix`，它对理解多态原理有着非常重要的作用。

<div align=center><img src="/images/2023/2023-08-09-13-49-18.png" data-action="zoom"></div>

> 调试方式请参考：[《(ubuntu) vscode + gdb 调试 c++》](https://www.wenfh2020.com/2022/02/19/vscode-gdb-cpp/)

---

### 5.1. __class_type_info

`__class_type_info`：它是 `type_info` 的一个派生类， 是一个类的类型信息的数据结构，用于在运行时获取对象的类型信息。

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/typeinfo */
// The type_info class describes type information generated by an implementation.
class type_info {
 protected:
    const char* __name;
};

/* /usr/include/c++/4.8.2/cxxabi.h */
// Type information for a class.
class __class_type_info : public std::type_info {
 public:
    ...
};
```

---

### 5.2. 虚表描述结构

`vtable_prefix`：虚表描述结构，用于表示虚函数表的前缀。一个对象可能有多个虚指针，多个虚表描述结构；对象的每个虚指针指向对应的 `vtable_prefix.origin`。

1. whole_object：我认为改为：top_offset 会更贴切一点。对象内存中的离顶端偏移位置，因为对象有可能有多个虚表，通过偏移量可以找到对象内存布局上对应的虚指针。
2. whole_type: 类的类型信息。
3. origin：虚指针指向虚表的位置。

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/tinfo.h */
// Initial part of a vtable, this structure is used with offsetof, so we don't
// have to keep alignments consistent manually.
struct vtable_prefix {
    // Offset to most derived object.
    ptrdiff_t whole_object;

    // Pointer to most derived type_info.
    const __class_type_info *whole_type;
    
    // What a class's vptr points to.
    const void *origin;
};
```

结合下面动态绑定的测试代码，我们提前了解一下它在内存中的布局。

<div align=center><img src="/images/2023/2023-08-14-08-27-56.png" data-action="zoom"></div>

---

## 6. 动态绑定

C++ 多态是一个比较复杂的特性，从易到难，我们先了解一下无继承关系的多态类对象的 `动态绑定` 工作流程，下面通过汇编代码理解虚函数的调用流程：

1. a 对象的内存布局，首位存放的是指向虚表的 `虚指针`。
2. 找到虚指针后，查看虚指针指向的 `虚函数表`。
3. 从虚表上找到对应位置的 `虚函数` 地址。
4. 将 a（this）指针写入 rdi 寄存器，作为参数传递给虚函数调用。
5. call 命令调用虚函数（A::vfuncA2(this)）。

<div align=center><img src="/images/2023/2023-07-03-15-28-13.png" data-action="zoom"/></div>

* CPP 源码。

```cpp
// g++ -g -O0 -std=c++11 -fdump-class-hierarchy test_virtual.cpp -o t
#include <iostream>

class A {
   public:
    int m_a = 0;
    virtual void vfuncA1() {}
    virtual void vfuncA2() {}
};

int main(int argc, char** argv) {    
    A* a = new A;
    a->vfuncA2();
    return 0;
}
```

* 汇编源码。

```shell
int main(int argc, char** argv) {
  ;...
    A* a = new A;
  ;...
  40071d:       e8 8e 00 00 00          callq  4007b0 <_ZN1AC1Ev>
  ; 将 a 的对象（this）指针压栈到 -0x18(%rbp)
  400722:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    a->vfuncA2();
  ; 虚指针
  400726:       48 8b 45 e8             mov    -0x18(%rbp),%rax
  ; 虚表
  40072a:       48 8b 00                mov    (%rax),%rax
  ; 指向虚表上对应虚函数的位置
  40072d:       48 83 c0 08             add    $0x8,%rax
  ; 找到对应虚函数
  400731:       48 8b 00                mov    (%rax),%rax
  ; 通过寄存器传递 a 指针作为参数，传给虚函数使用
  400734:       48 8b 55 e8             mov    -0x18(%rbp),%rdx
  400738:       48 89 d7                mov    %rdx,%rdi
  ; 调用虚函数
  40073b:       ff d0                   callq  *%rax
    return 0;
  ;...
}
```

<div align=center><img src="/images/2023/2023-08-12-13-55-34.png" data-action="zoom"></div>

---

## 7. 继承关系

封装，继承，多态是 C++ 的三大特性，其中多态与继承有密切关系。C++ 语言支持三种继承关系：单一继承，多重继承，虚拟继承：

<div align=center><img src="/images/2023/2023-02-25-11-37-39.png" data-action="zoom" width="80%"/></div>

> 图片来源：《多型与虚拟》

<div align=center><img src="/images/2023/2023-08-11-10-36-46.png" data-action="zoom"></div>

---

### 7.1. 单一继承

* 测试代码。

```cpp
/* g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() {}
    virtual void vBaseFunc2() {}
    virtual void vBaseFunc3() {}

    double m_base_data;
    double m_base_data2;
};

class Base2 : public Base {
   public:
    virtual void vBaseFunc() {}
    virtual void vBase2Func() {}
    virtual void vBase2Func2() {}

    double m_base2_data;
    double m_base2_data2;
};

class Drived : public Base2 {
   public:
    virtual void vBaseFunc2() {}
    virtual void vBase2Func() {}
    virtual void vDrivedFunc() {}
    virtual void vDrivedFunc2() {}

    double m_drived_data;
    double m_drived_data2;
};

int main() {
    return 0;
}
```

* 类布局层次。

```shell
# g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test
# test.cpp.002t.class

Vtable for Base
Base::_ZTV4Base: 5u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI4Base)
16    (int (*)(...))Base::vBaseFunc
24    (int (*)(...))Base::vBaseFunc2
32    (int (*)(...))Base::vBaseFunc3

Class Base
   size=24 align=8
   base size=24 base align=8
Base (0x0x7fe6a109f180) 0
    vptr=((& Base::_ZTV4Base) + 16u)

Vtable for Base2
Base2::_ZTV5Base2: 7u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI5Base2)
16    (int (*)(...))Base2::vBaseFunc
24    (int (*)(...))Base::vBaseFunc2
32    (int (*)(...))Base::vBaseFunc3
40    (int (*)(...))Base2::vBase2Func
48    (int (*)(...))Base2::vBase2Func2

Class Base2
   size=40 align=8
   base size=40 base align=8
Base2 (0x0x7fe6a1056f70) 0
    vptr=((& Base2::_ZTV5Base2) + 16u)
  Base (0x0x7fe6a109f1e0) 0
      primary-for Base2 (0x0x7fe6a1056f70)

# 虚表的结构。
Vtable for Drived
Drived::_ZTV6Drived: 9u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI6Drived)
16    (int (*)(...))Base2::vBaseFunc
24    (int (*)(...))Drived::vBaseFunc2
32    (int (*)(...))Base::vBaseFunc3
40    (int (*)(...))Drived::vBase2Func
48    (int (*)(...))Base2::vBase2Func2
56    (int (*)(...))Drived::vDrivedFunc
64    (int (*)(...))Drived::vDrivedFunc2

# 类的层次结构。
Class Drived
   size=56 align=8
   base size=56 base align=8
Drived (0x0x7fe6a1056478) 0
    vptr=((& Drived::_ZTV6Drived) + 16u)
  Base2 (0x0x7fe6a1056a28) 0
      primary-for Drived (0x0x7fe6a1056478)
    Base (0x0x7fe6a109f240) 0
        primary-for Base2 (0x0x7fe6a1056a28)
```

结合上面单一继承的测试代码和类的布局层次，我们可以了解到它的整体的相关对象布局：

  1. 派生类重写的虚函数是如何重写覆盖基类的虚函数的。
  2. 虚表的数据结构的大致框架。
  3. 对象的各个关键点是如何联系起来的。
  
  > 部分细节没有写测试，有兴趣的朋友可以自己动手试试。

* 虚表整合。

<div align=center><img src="/images/2023/2023-08-12-14-39-06.png" data-action="zoom"></div>

* 对象整体对局。

<div align=center><img src="/images/2023/2023-08-12-14-40-07.png" data-action="zoom"></div>

---

### 7.2. 多重继承

* 测试代码。

```cpp
/* g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() {}
    virtual void vBaseFunc2() {}

    double m_base_data;
    double m_base_data2;
};

class Base2 {
   public:
    virtual void vBase2Func() {}
    virtual void vBase2Func2() {}

    double m_base2_data;
    double m_base2_data2;
};

class Base3 {
   public:
    virtual void vBase3Func() {}
    virtual void vBase3Func2() {}

    double m_base3_data;
    double m_base3_data2;
};

class Drived : public Base, public Base2, public Base3 {
   public:
    virtual void vBaseFunc() {}
    virtual void vBase2Func2() {}
    virtual void vBase3Func2() {}
    virtual void vDrivedFunc() {}
    virtual void vDrivedFunc2() {}

    double m_drived_data;
    double m_drived_data2;
};

int main() {
    return 0;
}
```

* 类内存布局层次。

```shell
# g++ -O0 -std=c++11 -fdump-class-hierarchy test.cpp -o test
# test.cpp.002t.class

Vtable for Base
Base::_ZTV4Base: 4u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI4Base)
16    (int (*)(...))Base::vBaseFunc
24    (int (*)(...))Base::vBaseFunc2

Class Base
   size=24 align=8
   base size=24 base align=8
Base (0x0x7f8e4bd3da80) 0
    vptr=((& Base::_ZTV4Base) + 16u)

Vtable for Base2
Base2::_ZTV5Base2: 4u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI5Base2)
16    (int (*)(...))Base2::vBase2Func
24    (int (*)(...))Base2::vBase2Func2

Class Base2
   size=24 align=8
   base size=24 base align=8
Base2 (0x0x7f8e4bd3dae0) 0
    vptr=((& Base2::_ZTV5Base2) + 16u)

Vtable for Base3
Base3::_ZTV5Base3: 4u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI5Base3)
16    (int (*)(...))Base3::vBase3Func
24    (int (*)(...))Base3::vBase3Func2

Class Base3
   size=24 align=8
   base size=24 base align=8
Base3 (0x0x7f8e4bd3db40) 0
    vptr=((& Base3::_ZTV5Base3) + 16u)

Vtable for Drived
Drived::_ZTV6Drived: 16u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI6Drived)
16    (int (*)(...))Drived::vBaseFunc
24    (int (*)(...))Base::vBaseFunc2
32    (int (*)(...))Drived::vBase2Func2
40    (int (*)(...))Drived::vBase3Func2
48    (int (*)(...))Drived::vDrivedFunc
56    (int (*)(...))Drived::vDrivedFunc2
64    (int (*)(...))-24
72    (int (*)(...))(& _ZTI6Drived)
80    (int (*)(...))Base2::vBase2Func
88    (int (*)(...))Drived::_ZThn24_N6Drived11vBase2Func2Ev
96    (int (*)(...))-48
104   (int (*)(...))(& _ZTI6Drived)
112   (int (*)(...))Base3::vBase3Func
120   (int (*)(...))Drived::_ZThn48_N6Drived11vBase3Func2Ev

Class Drived
   size=88 align=8
   base size=88 base align=8
Drived (0x0x7f8e4babcd98) 0
    vptr=((& Drived::_ZTV6Drived) + 16u)
  Base (0x0x7f8e4bd3dba0) 0
      primary-for Drived (0x0x7f8e4babcd98)
  Base2 (0x0x7f8e4bd3dc00) 24
      vptr=((& Drived::_ZTV6Drived) + 80u)
  Base3 (0x0x7f8e4bd3dc60) 48
      vptr=((& Drived::_ZTV6Drived) + 112u)
```

* 虚表整合。
  
  1. 首先派生类的虚表与第一个基类的虚表结合成一个虚表单元，并覆盖基类的虚函数。
  2. 其它的基类，作为一个独立虚表单元。当派生类虚函数有重写基类的虚函数时，基类对应虚函数，通过 [thunk 技术](https://zhuanlan.zhihu.com/p/496115833) ，跳转到第一个虚表单元的对应虚函数。

<div align=center><img src="/images/2023/2023-08-12-14-38-05.png" data-action="zoom"></div>

* 对象整体布局。由下图可见：

  1. 多重继承有多个虚指针，并指向对应的虚表。
  2. 如果派生类有 N 个多重继承单一基类，那么它的对象有 N 多虚指针和虚表。

<div align=center><img src="/images/2023/2023-08-12-14-36-56.png" data-action="zoom"></div>

---

### 7.3. 虚拟继承

虚拟继承的类层次关系结构有点复杂，有兴趣的朋友可以看看：[What is the VTT for a class?](https://blog.csdn.net/qq_30366449/article/details/85106115)。

---

## 8. dynamic_cast

`dynamic_cast` 是 C++ 中的一个类型转换运算符，用于在运行时进行类型转换。它可以将一个指向基类的指针或引用转换为指向派生类的指针或引用。dynamic_cast 会检查转换是否安全，如果转换不安全，则返回一个空指针或引发一个std::bad_cast异常。它主要用于在多态的情况下进行安全的向下转型。它的语法如下：

```cpp
dynamic_cast<new_type>(expression)
```

其中，`new_type` 是要转换的目标类型，`expression` 是要转换的表达式。dynamic_cast 会在运行时检查类型信息，如果转换是合法的，则返回指向目标类型的指针或引用，否则返回 `nullptr`。

需要注意的是，dynamic_cast 只能用于具有多态性的类层次结构中，即其中至少有一个虚函数。否则，编译器会报错。此外，dynamic_cast 的性能相对较低，因为它需要在运行时进行类型检查。因此，在使用 dynamic_cast 时要谨慎考虑性能问题。

> 部分文字来源：ChatGPT 3.5，详细定义请参考：[dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)

---

### 8.1. 测试实例

通过调试去观测 dynamic_cast 函数的内部源码相关数据信息。

* 源码。

```cpp
/* g++ -O0 -std=c++11 test.cpp -o test && ./test */
#include <iostream>

class Base {
   public:
    virtual void vBaseFunc() { std::cout << "Base::vBaseFunc2" << std::endl; }
    virtual void vBaseFunc2() { std::cout << "Base::vBaseFunc2" << std::endl; }
};

class Drived : public Base {
   public:
    virtual void vBaseFunc2() { std::cout << "Drived::vBaseFunc2" << std::endl; }
    virtual void vDrivedFunc() { std::cout << "Drived::vDrivedFunc" << std::endl; }
};

int main() {
    Base *b = new Drived;
    auto d = dynamic_cast<Drived *>(b);
    if (d) {
        d->vBaseFunc2();
    }
    return 0;
}
```

* 反汇编查看该函数的调用，以及变量参数数据。

<div align=center><img src="/images/2023/2023-08-09-13-51-26.png" data-action="zoom"></div>

```shell
# objdump -dS test > asm.log
  ; src2dst
  40098f:    b9 00 00 00 00           mov    $0x0,%ecx
  ; dst_type
  400994:    ba 70 0c 40 00           mov    $0x400c70,%edx
  ; src_ptr
  400999:    be 90 0c 40 00           mov    $0x400c90,%esi
  ; src_ptr
  40099e:    48 89 c7                 mov    %rax,%rdi
  ; 调用 dynamic_cast 函数
  4009a1:    e8 8a fe ff ff           callq  400830 <__dynamic_cast@plt>
```

* 通过调试，我们可以比较直观看到该函数的参数变量相关信息。

<div align=center><img src="/images/2023/2023-08-09-13-49-18.png" data-action="zoom"></div>

> 调试方式请参考：[《(ubuntu) vscode + gdb 调试 c++》](https://www.wenfh2020.com/2022/02/19/vscode-gdb-cpp/)

---

### 8.2. 源码剖析

`待续...`

```cpp
/* /usr/src/debug/gcc-4.8.5-20150702/libstdc++-v3/libsupc++/dyncast.cc */

// this is the external interface to the dynamic cast machinery
/* sub: source address to be adjusted; nonnull, and since the
 *      source object is polymorphic, *(void**)sub is a virtual pointer.
 * src: static type of the source object.
 * dst: destination type (the "T" in "dynamic_cast<T>(v)").
 * src2dst_offset: a static hint about the location of the
 *    source subobject with respect to the complete object;
 *    special negative values are:
 *       -1: no hint
 *       -2: src is not a public base of dst
 *       -3: src is a multiple public base type but never a virtual base type
 *    otherwise, the src type is a unique public nonvirtual
 *    base type of dst at offset src2dst_offset from the origin of dst.  */
extern "C" void *__dynamic_cast(
    const void *src_ptr,                // object started from
    const __class_type_info *src_type,  // type of the starting object
    const __class_type_info *dst_type,  // desired target type
    ptrdiff_t src2dst)                  // how src and dst are related
{
    const void *vtable = *static_cast<const void *const *>(src_ptr);
    const vtable_prefix *prefix =
        adjust_pointer<vtable_prefix>(vtable, -offsetof(vtable_prefix, origin));
    const void *whole_ptr = adjust_pointer<void>(src_ptr, prefix->whole_object);
    const __class_type_info *whole_type = prefix->whole_type;
    __class_type_info::__dyncast_result result;

    // If the whole object vptr doesn't refer to the whole object type, we're
    // in the middle of constructing a primary base, and src is a separate
    // base.  This has undefined behavior and we can't find anything outside
    // of the base we're actually constructing, so fail now rather than
    // segfault later trying to use a vbase offset that doesn't exist.
    const void *whole_vtable = *static_cast<const void *const *>(whole_ptr);
    const vtable_prefix *whole_prefix = adjust_pointer<vtable_prefix>(
        whole_vtable, -offsetof(vtable_prefix, origin));
    if (whole_prefix->whole_type != whole_type) {
        return NULL;
    }

    whole_type->__do_dyncast(src2dst, __class_type_info::__contained_public,
                             dst_type, whole_ptr, src_type, src_ptr, result);
    if (!result.dst_ptr) {
        return NULL;
    }
    if (contained_public_p(result.dst2src)) {
        // Src is known to be a public base of dst.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_public_p(__class_type_info::__sub_kind(result.whole2src &
                                                         result.whole2dst))) {
        // Both src and dst are known to be public bases of whole. Found a valid
        // cross cast.
        return const_cast<void *>(result.dst_ptr);
    }
    if (contained_nonvirtual_p(result.whole2src)) {
        // Src is known to be a non-public nonvirtual base of whole, and not a
        // base of dst. Found an invalid cross cast, which cannot also be a down
        // cast
        return NULL;
    }
    if (result.dst2src == __class_type_info::__unknown) {
        result.dst2src = dst_type->__find_public_src(src2dst, result.dst_ptr,
                                                     src_type, src_ptr);
    }
    if (contained_public_p(result.dst2src)) {
        // Found a valid down cast
        return const_cast<void *>(result.dst_ptr);
    }
    // Must be an invalid down cast, or the cross cast wasn't bettered
    return NULL;
}
```

---

## 9. 引用

* 《深度探索 C++ 对象模型》
* 《C++ 虚拟与多态》
* [多态及其基本原理](https://blog.csdn.net/tangya3158613488/article/details/88765539)
* [C++ 多态的实现原理分析](https://blog.csdn.net/afei__/article/details/82142775)
* [为什么要有虚继承？是为了解决什么问题？](https://www.jianshu.com/p/ab96f88e5285)
* [再议内存布局](https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247489554&idx=1&sn=f5d7e6cd5d23e8e01c413af1dc8fe9fd&chksm=c3377ed5f440f7c32c5596c962823e65ddd17382f621899d63f78d1cc93346918fa92cf50ca0&mpshare=1&scene=24&srcid=0214TisAPcO12I99OihwUdTH&sharer_sharetime=1676387821455&sharer_shareid=0b4fc3750818fb2c58eb60e71e3d1c6f#rd)
* [C++：从技术实现角度聊聊RTTI](http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247489382&idx=1&sn=203de64c6ff362eaea628523f1584330&chksm=c33771a1f440f8b77715d96dcbefd4b8e3a081ce94fa81907245d895ca29b54845b27db8aff9&mpshare=1&scene=24&srcid=0214fcH29d6PwaYZNonOZwAg&sharer_sharetime=1676387791668&sharer_shareid=0b4fc3750818fb2c58eb60e71e3d1c6f#rd)
* [c++对象内存布局](http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247484652&idx=1&sn=087f34d20572614a3273c4f1028a4be2&chksm=c337622bf440eb3d0875a5e115c3545c169cbbd5fd5cae834f9387479c202d5eff1c350b3f2f&mpshare=1&scene=24&srcid=0214RAacGDpYpm1JFHL7I8iV&sharer_sharetime=1676387723635&sharer_shareid=0b4fc3750818fb2c58eb60e71e3d1c6f#rd)
* [dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)
* [C++ 对象的内存布局（上）](https://haoel.blog.csdn.net/article/details/3081328)
* [C++ 对象的内存布局（下）](https://blog.csdn.net/haoel/article/details/3081385)
* [如何在vscode中编写汇编语言并在终端进行调试(保姆级别）](https://blog.csdn.net/m0_46973282/article/details/109250859)
* [C++ Virtual Table Tables(VTT)](https://nimrod.blog/posts/cpp-virtual-table-tables/)
* [虚继承的Vtable](https://qinglinmao8315.github.io/c++/2018/02/28/c++-vtable-in-virtual-inheritance.html)
* [godbolt.org](https://godbolt.org/)
* [深入理解C++对像模型--vtable 布局](https://zhuanlan.zhihu.com/p/496115833)
* [What is the VTT for a class?](https://blog.csdn.net/qq_30366449/article/details/85106115)
